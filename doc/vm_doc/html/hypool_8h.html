<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Harmony Class Library Porting: native-src/win.IA32/include/hypool.h File Reference</title>
<link href="hydoxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">native-src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_000001.html">win.IA32</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_000005.html">include</a></div>
<h1>hypool.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Pool Header. 
<p>

<p>
<code>#include &quot;hycomp.h&quot;</code><br>
<code>#include &quot;<a class="el" href="hyport_8h.html">hyport.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>HyPool</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>HyPoolState</b></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#a12">pool_do</a> (HyPool *aPool, void(*aFunction)(void *anElement, void *userData), void *userData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls a user provided function for each element in the list.  <a href="#a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#a15">pool_removeElement</a> (HyPool *aPool, void *anElement)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocates an element from a pool.  <a href="#a15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#a16">pool_numElements</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of elements in a given pool.  <a href="#a16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC void *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#a18">pool_newElement</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asks for the address of a new pool element.  <a href="#a18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC HyPool *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#a19">pool_forPortLib</a> (U_32 structSize, <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shortcut for <a class="el" href="pool_8c.html#pool_new">pool_new</a>, using the default malloc/free from the portLibrary.  <a href="#a19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#a20">pool_kill</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocates all memory associated with a pool.  <a href="#a20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#a21">pool_sortFree</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the free list of the current pool.  <a href="#a21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#a22">pool_clear</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the contents of a pool but not delete it.  <a href="#a22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#a23">pool_capacity</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total capacity of a pool.  <a href="#a23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#a24">pool_ensureCapacity</a> (HyPool *aPool, UDATA newCapacity)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensures that the pool is large enough for newCapacity elements.  <a href="#a24"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a23"></a><!-- doxytag: member="hypool.h::pool_capacity" ref="a23" args="(HyPool *aPool)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">HY_CFUNC UDATA VMCALL pool_capacity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>aPool</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the total capacity of a pool. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on error <p>
numElements in aPool otherwise</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a22"></a><!-- doxytag: member="hypool.h::pool_clear" ref="a22" args="(HyPool *aPool)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">HY_CFUNC void VMCALL pool_clear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>aPool</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clear the contents of a pool but not delete it. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Make no assumptions about the contents of the pool after invoking this method (it currently does not zero the memory)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool to clear</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12"></a><!-- doxytag: member="hypool.h::pool_do" ref="a12" args="(HyPool *aPool, void(*aFunction)(void *anElement, void *userData), void *userData)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">HY_CFUNC void VMCALL pool_do           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname" nowrap> <em>aPool</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void(*)(void *anElement, void *userData)&nbsp;</td>
          <td class="mdname" nowrap> <em>aFunction</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>userData</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calls a user provided function for each element in the list. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool to "do" things to </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aFunction</em>&nbsp;</td><td>Pointer to function which will "do" things to the elements of aPool </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>Pointer to data to be passed to "do" function, along with each pool-element</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>pool_startDo, pool_nextDo</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a24"></a><!-- doxytag: member="hypool.h::pool_ensureCapacity" ref="a24" args="(HyPool *aPool, UDATA newCapacity)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">HY_CFUNC UDATA VMCALL pool_ensureCapacity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname" nowrap> <em>aPool</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>UDATA&nbsp;</td>
          <td class="mdname" nowrap> <em>newCapacity</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Ensures that the pool is large enough for newCapacity elements. 
<p>
This has the side effect of setting the POOL_NEVER_FREE_PUDDLES flag. Without this, the pool could shrink back down to its original size. Note that this does not take into account the number of elements already used in the pool.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>newCapacity</em>&nbsp;</td><td>The desired new-size of the pool</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success <p>
-1 on failure</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a19"></a><!-- doxytag: member="hypool.h::pool_forPortLib" ref="a19" args="(U_32 structSize, HyPortLibrary *portLibrary)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">HY_CFUNC HyPool* VMCALL pool_forPortLib           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">U_32&nbsp;</td>
          <td class="mdname" nowrap> <em>structSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>portLibrary</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Shortcut for <a class="el" href="pool_8c.html#pool_new">pool_new</a>, using the default malloc/free from the portLibrary. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>structSize</em>&nbsp;</td><td>size of pool-element </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>pointer to a Pool</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>pool_new</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a20"></a><!-- doxytag: member="hypool.h::pool_kill" ref="a20" args="(HyPool *aPool)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">HY_CFUNC void VMCALL pool_kill           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>aPool</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deallocates all memory associated with a pool. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>Pool to be deallocated</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a18"></a><!-- doxytag: member="hypool.h::pool_newElement" ref="a18" args="(HyPool *aPool)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">HY_CFUNC void* VMCALL pool_newElement           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>aPool</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Asks for the address of a new pool element. 
<p>
If it succeeds, the address returned will have space for one element of the correct structure size. The contents of the element are undefined. If the current pool is full, a new one will be grafted onto the end of the pool chain and memory from there will be used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NULL on error <p>
pointer to a new element otherwise</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16"></a><!-- doxytag: member="hypool.h::pool_numElements" ref="a16" args="(HyPool *aPool)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">HY_CFUNC UDATA VMCALL pool_numElements           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>aPool</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of elements in a given pool. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on error <p>
the number of elements in the pool otherwise</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a15"></a><!-- doxytag: member="hypool.h::pool_removeElement" ref="a15" args="(HyPool *aPool, void *anElement)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">HY_CFUNC void VMCALL pool_removeElement           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname" nowrap> <em>aPool</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>anElement</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deallocates an element from a pool. 
<p>
It is safe to call <a class="el" href="pool_8c.html#a7">pool_removeElement()</a> while looping over the pool with <a class="el" href="pool_8c.html#pool_startDo">pool_startDo</a> / <a class="el" href="pool_8c.html#pool_nextDo">pool_nextDo</a> on the element returned by those calls. This is because the free element is always inserted at either the head of the free list or before the nextFree element in the pool_state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>anElement</em>&nbsp;</td><td>Pointer to the element to be removed</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a21"></a><!-- doxytag: member="hypool.h::pool_sortFree" ref="a21" args="(HyPool *aPool)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">HY_CFUNC void VMCALL pool_sortFree           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>aPool</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sorts the free list of the current pool. 
<p>
(ie: does not follow nextPool pointers...) This is a O(n) most of the time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool to be sorted</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
    </td>
  </tr>
</table>
<hr size="1">
<address style="text-align: center;">
  <small>
    (c) Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
  </small>
</address>
</body>
</html>
