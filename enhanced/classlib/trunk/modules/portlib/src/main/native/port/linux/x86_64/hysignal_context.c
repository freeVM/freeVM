/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

#include "hyport.h"
#include <unistd.h>
#include <string.h>
#include <sys/ucontext.h>
#include "hysignal_context.h"

void
fillInUnixSignalInfo (struct HyPortLibrary *portLibrary, void *contextInfo,
                          struct HyUnixSignalInfo *hyInfo)
{
  struct sigcontext *sigContext;
  ucontext_t *uContext;

  uContext = (ucontext_t *) contextInfo;
  sigContext = (struct sigcontext *) &uContext->uc_mcontext;

  hyInfo->platformSignalInfo.sigContext = sigContext;
  /* module info is filled on demand */
}


U_32
infoForSignal (struct HyPortLibrary *portLibrary,
               struct HyUnixSignalInfo *info, I_32 index,
               const char **name, void **value)
{
  *name = "";

  switch (index)
    {

    case HYPORT_SIG_SIGNAL_TYPE:
    case 0:
      *name = "HyGeneric_Signal_Number";
      *value = &info->portLibrarySignalType;
      return HYPORT_SIG_VALUE_32;

    case HYPORT_SIG_SIGNAL_PLATFORM_SIGNAL_TYPE:
    case 1:
      *name = "Signal_Number";
      *value = &info->sigInfo->si_signo;
      return HYPORT_SIG_VALUE_32;

    case HYPORT_SIG_SIGNAL_ERROR_VALUE:
    case 2:
      *name = "Error_Value";
      *value = &info->sigInfo->si_errno;
      return HYPORT_SIG_VALUE_32;

    case HYPORT_SIG_SIGNAL_CODE:
    case 3:
      *name = "Signal_Code";
      *value = &info->sigInfo->si_code;
      return HYPORT_SIG_VALUE_32;

    case HYPORT_SIG_SIGNAL_HANDLER:
    case 4:
      *name = "Handler1";
      *value = &info->handlerAddress;
      return HYPORT_SIG_VALUE_ADDRESS;

    case 5:
      *name = "Handler2";
      *value = &info->handlerAddress2;
      return HYPORT_SIG_VALUE_ADDRESS;

    case HYPORT_SIG_SIGNAL_INACCESSIBLE_ADDRESS:
    case 6:
      /* si_code > 0 indicates that the signal was generated by the kernel */
      if (info->sigInfo->si_code > 0)
        {
          if ((info->sigInfo->si_signo == SIGBUS)
              || (info->sigInfo->si_signo == SIGSEGV))
            {
              *name = "InaccessibleAddress";
              *value = &info->sigInfo->si_addr;
              return HYPORT_SIG_VALUE_ADDRESS;
            }
        }
      return HYPORT_SIG_VALUE_UNDEFINED;

    default:
      return HYPORT_SIG_VALUE_UNDEFINED;
    }
}


U_32
infoForFPR (struct HyPortLibrary *portLibrary,
            struct HyUnixSignalInfo *info, I_32 index, const char **name,
            void **value)
{
  static const char *n_xmm[] = {
    "xmm0",
    "xmm1",
    "xmm2",
    "xmm3",
    "xmm4",
    "xmm5",
    "xmm6",
    "xmm7"
  };

  switch (index)
    {
    default:
      return HYPORT_SIG_VALUE_UNDEFINED;
    }
}


U_32
infoForGPR (struct HyPortLibrary *portLibrary,
            struct HyUnixSignalInfo *info, I_32 index, const char **name,
            void **value)
{
  *name = "";

  switch (index)
    {
    case HYPORT_SIG_GPR_AMD64_RDI:
    case 0:
      *name = "RDI";
      *value = &info->platformSignalInfo.sigContext->rdi;
      return HYPORT_SIG_VALUE_ADDRESS;
    case HYPORT_SIG_GPR_AMD64_RSI:
    case 1:
      *name = "RSI";
      *value = &info->platformSignalInfo.sigContext->rsi;
      return HYPORT_SIG_VALUE_ADDRESS;
    case HYPORT_SIG_GPR_AMD64_RAX:
    case 2:
      *name = "RAX";
      *value = &info->platformSignalInfo.sigContext->rax;
      return HYPORT_SIG_VALUE_ADDRESS;
    case HYPORT_SIG_GPR_AMD64_RBX:
    case 3:
      *name = "RBX";
      *value = &info->platformSignalInfo.sigContext->rbx;
      return HYPORT_SIG_VALUE_ADDRESS;
    case HYPORT_SIG_GPR_AMD64_RCX:
    case 4:
      *name = "RCX";
      *value = &info->platformSignalInfo.sigContext->rcx;
      return HYPORT_SIG_VALUE_ADDRESS;
    case HYPORT_SIG_GPR_AMD64_RDX:
    case 5:
      *name = "RDX";
      *value = &info->platformSignalInfo.sigContext->rdx;
      return HYPORT_SIG_VALUE_ADDRESS;
    default:
      return HYPORT_SIG_VALUE_UNDEFINED;
    }

}


U_32
infoForControl (struct HyPortLibrary *portLibrary,
                struct HyUnixSignalInfo *info, I_32 index,
                const char **name, void **value)
{
  *name = "";
  U_8 *eip;

  switch (index)
    {
    case HYPORT_SIG_CONTROL_PC:
    case 0:
      *name = "RIP";
      *value = (void *) &(info->platformSignalInfo.sigContext->rip);
      return HYPORT_SIG_VALUE_ADDRESS;
    case HYPORT_SIG_CONTROL_SP:
    case 3:
      *name = "RSP";
      *value = (void *) &(info->platformSignalInfo.sigContext->rsp);
      return HYPORT_SIG_VALUE_ADDRESS;
    case 4:
      *name = "EFlags";
      *value = (void *) &(info->platformSignalInfo.sigContext->eflags);
      return HYPORT_SIG_VALUE_ADDRESS;
    case 5:
      *name = "CS";
      *value = (void *) &(info->platformSignalInfo.sigContext->cs);
      return HYPORT_SIG_VALUE_ADDRESS;
    case HYPORT_SIG_CONTROL_BP:
    case 6:
      *name = "RBP";
      *value = &info->platformSignalInfo.sigContext->rbp;
      return HYPORT_SIG_VALUE_ADDRESS;
    default:
      return HYPORT_SIG_VALUE_UNDEFINED;
    }
}


U_32
infoForModule (struct HyPortLibrary *portLibrary,
               struct HyUnixSignalInfo *info, I_32 index,
               const char **name, void **value)
{
  void *address;
  Dl_info *dl_info = &(info->platformSignalInfo.dl_info);
  *name = "";

  address = (void *) info->platformSignalInfo.sigContext->rip;
  int dl_result =
    dladdr ((void *) info->platformSignalInfo.sigContext->rip, dl_info);

  switch (index)
    {
    case HYPORT_SIG_MODULE_NAME:
    case 0:
      *name = "Module";
      if (dl_result)
        {
          *value = (void *) (dl_info->dli_fname);
          return HYPORT_SIG_VALUE_STRING;
        }
      return HYPORT_SIG_VALUE_UNDEFINED;
    case 1:
      *name = "Module_base_address";
      if (dl_result)
        {
          *value = (void *) &(dl_info->dli_fbase);
          return HYPORT_SIG_VALUE_ADDRESS;
        }
      return HYPORT_SIG_VALUE_UNDEFINED;
    case 2:
      *name = "Symbol";
      if (dl_result)
        {
          if (dl_info->dli_sname != NULL)
            {
              *value = (void *) (dl_info->dli_sname);
              return HYPORT_SIG_VALUE_STRING;
            }
        }
      return HYPORT_SIG_VALUE_UNDEFINED;
    case 3:
      *name = "Symbol_address";
      if (dl_result)
        {
          *value = (void *) &(dl_info->dli_saddr);
          return HYPORT_SIG_VALUE_ADDRESS;
        }
      return HYPORT_SIG_VALUE_UNDEFINED;
    default:
      return HYPORT_SIG_VALUE_UNDEFINED;
    }
}
