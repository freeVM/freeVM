<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
  
       http://www.apache.org/licenses/LICENSE-2.0
  
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<!--
Author: Marina V. Goldburt
Version: $Revision: 1.9.2.5 $
-->
<!-- 
    COMPONENT  BUILDER  executes  a   target  for  a  component.   The
    component's name has  to be set in ant  property ${_component} and
    the target's name in the ${_target} property.
    
    The static information, that the  script uses to build a component
    is defined  in components'  descriptors.  All files  in components
    directory are components' descriptors.   To add a component, add a
    component descriptor for the component to components directory and
    the component builder'll be able to build it.

    To learn  what information has to  be defined in  the descriptor -
    see comments in descriptors.
    
    The component  builder supports  unlimited amount of  targets. All
    files in  targets directory are  targets for the builder.   To add
    new target, add xml file  with the target to targets directory and
    the  component builder  will be  able  to execute  the target  for
    components.
    
    Some  build properties  must  be predefined  before the  component
    builder is called:
        
    ${build.semi.dir}  - property that points to directory, the builder
                         stores results of executed targets
    ${build.cfg}       - configuration, supported values: debug/release
    ${build.os.short}  - operation system, supported values:  lnx/win
    ${build.os.family} - OS, supported values:  unix/win
    ${build.arch}      - supported values: ia32/em64t/ipf
    ${build.cxx}       - c/cpp source code compiler, supported values:
                         msvc/icl for Windows, gcc/icc for Linux
    ${build.is.debug}  - true/false - used in build target    
    
    ${build.CLASSLIB.home} - directory with classlib src
    ${build.VM.home}       - directory with vm src
    
    The  component builder  generates build.xml  file  with components
    dependencies and  build_${component}.xml files for  all components
    and stores  the files  in ${build.semi.dir} directory.   The files
    depend  on  build configuration,  to  select  information for  the
    concrete  build   configuration,  we  process   every  component's
    descriptor   with    xslt   processor   with   build_component.xsl
    stylesheet.      Then      the     component     builder     calls
    ${_target}_${_component} target  in build.xml file  to execute the
    targer for the concrete component.
-->

<project name="COMPONENT_BUILDER">
    <!-- calls the target for the component in generated build.xml -->
    <target name="build" depends="construct_build">
        <property name="build.script" value="${build.semi.dir}/build.tmp.xml" />
        <ant antfile="${build.script}" target="${_target}_${_component}" inheritAll="true" inheritRefs="true" />
    </target>

    <!-- generates build xml files on basis of components' descriptors and targets-->
    <target name="construct_build" depends="is.build.constructed" unless="build.constructed">
        <antcall target="generate" inheritAll="true" inheritRefs="true" />
    </target>

    <target name="generate" depends="generate.init, generate.targets, generate.build" />
    <!-- tests is the build.xml is up-to-date -->
    <target name="is.build.constructed">
        <dependset>
            <srcfileset dir="components" includes="**/*.xml" />
            <srcfilelist dir="." files="deploy.xml,selector.xsl,build_component.xsl,build_component.xml" />
            <targetfileset dir="${build.semi.dir}" includes="done.txt" />
        </dependset>
        <available file="${build.semi.dir}/done.txt" property="build.constructed" />
    </target>

    <!-- sets some properties used by the build construction -->
    <target name="generate.init" unless="build.constructed">
        <mkdir dir="${build.semi.dir}/build" />
        <property name="build.file" value="${build.semi.dir}/build.tmp.xml" />
        <echo file="${build.file}">
            <![CDATA[            
<project name="BUILD_ALL" >            
            ]]>
        </echo>

        <!-- start the semis/build_targets.xml -->
        <property name="build.targets.file" value="${build.semi.dir}/build_targets.xml" />
        <echo file="${build.targets.file}">
            <![CDATA[            
<project name="BUILD_TARGETS" >            
            ]]>
        </echo>
    </target>

    <!-- generates semis/build_targets.xml -->
    <target name="generate.targets" unless="build.constructed">
        <echo file="${build.targets.file}" append="true">
            <![CDATA[
     <import file="${build.semi.dir}/build/init_${component}.xml" /> 
            ]]>
        </echo>
        <var name="targets.list.var" value="" />
        <property name="target.target.file" value="" />
        <for param="target">
            <fileset dir="targets">
                <include name="**" />
                <exclude name="*test*"/>
            </fileset>

            <sequential>
                <basename property="@{target}.name" file="@{target}" />
                <!-- target name (with suffix and .xml)-->
                <propertycopy name="targetname" override="true" from="@{target}.name" />
                <echo file="${build.targets.file}" append="true">
                    <![CDATA[
    <import file="${basedir}/targets/${targetname}" />
                    ]]>
                </echo>

                <!-- load the content of the semis/build/targets/${targetname} -->
                <var name="target.target.file" unset="true" />
                <loadfile property="target.target.file" srcfile="targets/${targetname}" />

                <!-- ${t.file} = ${targetname}.file (file content) -->
                <propertycopy override="true" name="t.file" from="target.target.file" />

                <!-- ${tname} = 'build.java' from 'build.java.xml' -->
                <propertyregex property="tname" override="true" input="${targetname}" regexp="(.*)\.xml" replace="\1" defaultValue="${targetname}" />

                <!-- get 'java.native.c' from
                     [target name='build.native' depends='java.native.c'] -->
                <propertyregex property="${tname}.depends.on.targets" override="true" input="${t.file}" regexp="&lt;target[^&gt;]*name=&quot;${tname}&quot;[^&gt;]*depends=&quot;([^&quot;]*)&quot;" select="\1" defaultValue="" />

                <!-- accumulate all target names ('build.java',etc)
                     in ${targets.list.var} -->
                <var name="targets.list.var" value="${targets.list.var},${tname}" />
            </sequential>
        </for>

        <!-- remove the last ',' from the target list 'build.java,build.jar,' -->
        <propertyregex property="targets.list" input="${targets.list.var}" regexp=",+$" replace="" defaultValue="${targets.list.var}" />

        <!-- finish with the semis/build_targets.xml -->
        <echo file="${build.targets.file}" append="true">
            <![CDATA[
</project> 
            ]]>
        </echo>
    </target>

    <!-- processes descriptors with xslt - to get init_${component}.xml
         with init target for the component and generates build.xml
         with component dependencies
         (we get the dependencies from component descriptors) -->
    <target name="generate.build" unless="build.constructed">
        <!-- for all components we generate separate
             build_${component}.xml, that build the component.
             The xml will be called by build.xml after resolving
             dependencies -->
        <property name="component.init.file" value="" />

        <for param="file">
            <!-- all files in components directory are components
                 descriptors for the build -->
            <fileset dir="components">
                <include name="**/*.xml" />
            </fileset>

            <sequential>
                <antcall target="process_component" inheritAll="true" inheritRefs="true">
                    <param name="file" value="@{file}" />
                </antcall>
            </sequential>
        </for>

        <antcall target="add_deploy_component" inheritAll="true" />

        <echo file="${build.file}" append="true">
            <![CDATA[ 
</project>
        ]]>
     </echo>
        <echo file="${build.semi.dir}/done.txt" message="done" />
    </target>

    <target name="add_deploy_component">
        <propertyregex property="deploy.depends" override="true" input="${build.deploy.all.components}" regexp=" " replace="," global="true" defaultValue="${build.deploy.all.components}" />
        <for param="target.name" list="${targets.list}" delimiter=",">
            <sequential>

                <propertyregex property="deploy.target.depends" override="true" input="${deploy.depends}" regexp="([^,]+)" replace="@{target.name}_\1" defaultValue="" />

                <echo file="${build.file}" append="true">
                    <![CDATA[ 
                <target name="@{target.name}_deploy" depends="${deploy.target.depends}" />
                      ]]>                                
                </echo>

            </sequential>
        </for>
    </target>

    <target name="process_component">
        <!-- convert:
             'c:\home\smith\build\components\vm.xml' to
             'c:/home/smith/build/components/vm.xml' -->
        <propertyregex override="yes" property="file.with.linux.separator" input="${file}" regexp="\\" replace="/" global="true" defaultValue="${file}" />

        <!-- Getting the path of the descriptor under the
             directory components.
             Gets 'vm/vmcore' from './components/vm/vmcore.xml' -->
        <propertyregex override="yes" property="sub.path" input="${file.with.linux.separator}" regexp=".*/components/([^\.]*)\.xml" replace="\1" />

        <!-- Getting the full name of the component
             (vm.vmcore.jit_utils for example).
             Convert: 'vm/vmcore' to 'vm.vmcore'. -->
        <propertyregex override="yes" property="component.name" input="${sub.path}" regexp="/" replace="\." defaultValue="${sub.path}" />
        <echo message="${component.name}" />
        <!-- file generated xslt from component descriptor
             (it contains init target, select tags filtered) -->
        <var name="init.component.file" value="${build.semi.dir}/build/init_${component.name}.xml" />

        <!-- calling the xslt to generate ant file with init target from descriptor -->
        <property name="${component.name}.cfg" value="${build.cfg}" />
        <propertycopy name="cfg" from="${component.name}.cfg" override="yes" />

        <xslt in="${file}" out="${init.component.file}" style="./build_component.xsl">
            <param name="cfg" expression="${cfg}" />
            <param name="os" expression="${build.os.short}" />
            <param name="osfamily" expression="${build.os.family}" />
            <param name="arch" expression="${build.arch}" />
            <param name="cxx" expression="${build.cxx}" />
            <param name="hynosig" expression="${hy.no.sig}" />
            <param name="hylocalzlib" expression="${hy.local.zlib}" />
        </xslt>

        <!-- Load the semis/build/init_${component.name}.xml content. -->
        <var name="component.init.file" unset="true" />
        <loadfile property="component.init.file" srcFile="${init.component.file}" />

        <for param="target.name" list="${targets.list}" delimiter=",">
            <sequential>
                <propertyregex property="target.depends" override="true" input="${component.init.file}" regexp="&lt;property\s+value=&quot;(.*)&quot;\s+name=&quot;@{target.name}.depends&quot;" select="\1" defaultValue="" />
                <propertyregex property="target.depends" override="true" input="${component.init.file}" regexp="&lt;property\s+name=&quot;@{target.name}.depends&quot;\s+value=&quot;(.*)&quot;" select="\1" defaultValue="${target.depends}" />

                <propertycopy override="true" name="t.depends" from="@{target.name}.depends.on.targets" />
                <propertyregex property="t.depends.whithout.spaces" override="true" input="${t.depends}" regexp="\s+" replace="" defaultValue="${t.depends}" />

                <var name="complete.depends" value="${target.depends}" />

                <for param="depend.target" list="${t.depends.whithout.spaces}" delimiter=",">
                    <sequential>
                        <propertyregex property="depend.target.depends" override="true" input="${component.init.file}" regexp="&lt;property\s+value=&quot;(.*)&quot;\s+name=&quot;@{depend.target}.depends&quot;" select="\1" defaultValue="" />
                        <propertyregex property="depend.target.depends" override="true" input="${component.init.file}" regexp="&lt;property\s+name=&quot;@{depend.target}.depends&quot;\s+value=&quot;(.*)&quot;" select="\1" defaultValue="${depend.target.depends}" />
                        <var name="complete.depends" value="${depend.target.depends},${complete.depends}" />
                    </sequential>
                </for>

                <!-- removing leading and ending ','-->
                <propertyregex property="complete.depends" override="true" input="${complete.depends}" regexp="^,+" replace="" defaultValue="${complete.depends}" />
                <propertyregex property="complete.depends" override="true" input="${complete.depends}" regexp=",+$" replace="" defaultValue="${complete.depends}" />

                <propertyregex property="target.depends.whithout.spaces" override="true" input="${complete.depends}" regexp="\s+" replace="" defaultValue="${complete.depends}" />

                <propertyregex property="comp.depends" override="true" input="${target.depends.whithout.spaces}" regexp="([^,]+)" replace="@{target.name}_\1" defaultValue="" />

                <!-- adding the target with dependencies to
                     the build.xml we use antfetch to call the
                     concrete build_component.xml to return
                     some properties, that share between
                     components - $component.libname,
                     $component.jarname, $component.src and
                     also we set $component.libdir that point
                     to the directory the component is built
                     to. -->

                <echo file="${build.file}" append="true">
                    <![CDATA[ 
                <target name="@{target.name}_${component.name}" depends="${comp.depends}" >
                    <property name="${component.name}.cfg" value="${cfg}" />

                    <antfetch antfile="${build.targets.file}"
                              target="@{target.name}"
                              inheritRefs="true"
                              return="${component.name}.libdir,
                                      ${component.name}.libname,
                                      ${component.name}.src,
                                      ${component.name}.includes,
                                      ${component.name}.jardir,
                                      ${component.name}.jarname,
                                      ${component.name}.srcjarname" >
                        <property name="component"
                                  value="${component.name}" />
                        <property name="build.dir"
                                  value="${build.semi.dir}/${sub.path}" />
                    </antfetch>

                    <propertycopy name="${component.name}.lib"
                                  from="${component.name}.libname"
                                  silent="true" />

                    <!-- default value for libname and jarname
                        (set if no libname was in the descriptor -->
                    <property name="${component.name}.lib" value="${component.name}" />
                    <property name="${component.name}.jarname"
                              value="${component.name}.jarname" />
                    <property name="${component.name}.jar"
                              value="${component.name}.jarname" />
                </target>
                  ]]>                                
                </echo>

        </sequential>
    </for>
</target>

</project>
