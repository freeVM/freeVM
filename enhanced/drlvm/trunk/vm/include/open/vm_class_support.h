/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
/** 
 * @author Intel, Pavel Pervov
 * @version $Revision: 1.6 $
 */  

#ifndef _VM_CLASS_SUPPORT_H
#define _VM_CLASS_SUPPORT_H

/**
 * @file
 * Class Support interface exposed by VM.
 *
 * This file combines separate groups of interfaces commonly reffered to as
 * Class Support.
 *
 * If you do not know which part of Class Support interfaces you need,
 * include this file.
 */

#include "vm_class_loading.h"
#include "vm_class_manipulation.h"
#include "vm_method_access.h"
#include "vm_field_access.h"
#include "vm_type_access.h"


/* Inclusion of all these functions into class support interface is yet to decide. */

/* "through VM" method */
/* NOTE: reference to internal type Byte */

/**
 * Called by a EE to have the VM replace a section of executable code in a thread-safe fashion. 
 */
void vm_patch_code_block(Byte* code_block, Byte* new_code, size_t size);

/**
 * Called by a EE in order to be notified whenever the vtable entries for the given method 
 * are changed. This could happen, e.g., when a method is first compiled, or when it is 
 * recompiled.  The callback_data pointer will be passed back to the JIT during the callback.  
 * The callback method is JIT_recompiled_method_callback.
 */
void vm_register_jit_recompiled_method_callback(JIT_Handle jit, Method_Handle method, void* callback_data);

/**
 * Called by a JIT in order to be notified whenever the given method is overridden by a newly 
 * loaded class. The callback_data pointer will be passed back to the JIT during the callback.  
 * The callback function is JIT_overridden_method_callback.
 */
void vm_register_jit_overridden_method_callback(JIT_Handle jit, Method_Handle method, void* callback_data);

/**
 * Called by a JIT in order to be notified whenever the given class is extended.
 * The callback_data pointer will be passed back to the JIT during the callback. 
 * The callback function is JIT_extended_class_callback.
 */
void vm_register_jit_extended_class_callback(JIT_Handle jit, Class_Handle clss, void* callback_data);

/**
 * A set of functions is used by the code generated by the JIT.
 * The address of a function is obtained from the VM by invoking the
 * function vm_get_rt_support_addr (see below).
 */
void* vm_get_rt_support_addr(VM_RT_SUPPORT f);

/**
 * Temporary interface addition
 * same as vm_get_rt_support_addr, but tries to optimize the stubs it creates,
 * by specializing them.
 */
void* vm_get_rt_support_addr_optimized(VM_RT_SUPPORT f, Class_Handle c);

/**
 * Set the information about an exception handler in the code generated by
 * the JIT.
 */
void method_set_target_handler_info(Method_Handle method, JIT_Handle j, unsigned eh_number, void* start_ip, void* end_ip, void* handler_ip, Class_Handle catch_cl, Boolean exc_obj_is_dead);

/**
 * Get the size of the memory block allocated earlier by
 * method_allocate_info_block().
 */
unsigned method_get_info_block_size_jit(Method_Handle method, JIT_Handle j);

/**
 * Get the size of the memory block allocated earlier by
 * method_allocate_code_block().
 * A triple <method, jit, id> uniquely identifies a code block.
 */
VMEXPORT unsigned method_get_code_block_size_jit(Method_Handle method, JIT_Handle j, int id);

/**
 * Retrieve the memory block allocated earlier by
 * method_allocate_code_block().
 * A triple <method, jit, id> uniquely identifies a code block.
 */
Byte* method_get_code_block_addr_jit(Method_Handle method, JIT_Handle j, int id);

/**
 * Allocated a "read-only" data block.
 *
 * This function is deprecated.  In all new code, use
 * method_allocate_data_block() only.  At some point, we will revisit
 * this interface to have more control over the layout of various
 * memory blocks allocated by the VM.
 */
Byte* method_allocate_jit_data_block(Method_Handle method, JIT_Handle j, size_t size, size_t alignment);

/**
 * Called by a JIT to have the VM recompile a method using the specified JIT. After 
 * recompilation, the corresponding vtable entries will be updated, and the necessary 
 * callbacks to JIT_recompiled_method_callback will be made. It is a requirement that 
 * the method has not already been compiled by the given JIT; this means that multiple 
 * instances of a JIT may need to be active at the same time. (See vm_clone_jit.)
 */
void vm_recompile_method(JIT_Handle jit, Method_Handle method);

/// FIXME - This isn't method interface function!
// Replaces method_get_JIT_id
JIT_Handle
compilation_get_JIT_id(Compile_Handle compile_handle);

/**
 * Enables allocation of multiple chunks of code with different heat values. 
 * 
 * The JIT compiler is responsible for specifying  unique IDs of code chunks within one method.
 * The first instruction of the chunk with id=0 is the entry point of the method.
 *
 * @param method    - the method handle
 * @param jit       - the JIT handle
 * @param size      - the size of the allocated code block
 * @param alignment - the memory block aligment
 * @param heat      - ?
 * @param id        - code chunk id
 * @param action    - the resulting return action
 *
 * @return The pointer to the allocated code block with the following specifics: 
 *                 <ul>
 *                     <li>If the CAA_Allocate argument is specified, memory is allocated and the function returns the pointer
 *                          to this memory.
 *                     <li>If the CAA_Simulate argument is specified, no memory is allocated and the function returns the address 
 *                         that would have been allocated if CAA_Allocate was specified and all the other arguments were the same. 
 *                 </ul>
 *                 The function may also return <code>NULL</code> when CAA_Simulate is specified. For example, this may happen
 *                 when multiple heat values are mapped to the same code pool or when the specified size require a new code pool.
 *
 * @note FIXME This has to go to the compilation infrastructure interface. 
 */
Open_Native_Code_Ptr
method_allocate_code_block(Open_Method_Handle method,
                           JIT_Handle jit,
                           size_t size,
                           size_t alignment,
                           unsigned heat,
                           int id,
                           Code_Allocation_Action action);

/**
 * Allocates the "read-write" data block for the given method.
 *
 * This block is intended for data that may be required during program execution, 
 * for example, tables for switch statements. This block cannot be retrieved later. 
 *
 * Separation of data allocated by <i>method_allocate_data_block</i> and
 * <i>method_allocate_info_block</i> may help improve locality of references
 * to data accessed during execution of compiled code and data accessed during
 * stack unwinding.
 *
 * @param method    - the method handle
 * @param jit       - the JIT handle
 * @param size      - the size of the allocated code block
 * @param alignment - the memory block aligment
 *
 * @return The pointer to the allocated data block.
 *
 * @note Reference to type <i>Byte</i>.
 * @note FIXME This has to go to the compilation infrastructure interface.
 *
 * @see method_allocate_info_block
 */
Byte*
method_allocate_data_block(Open_Method_Handle method,
                           JIT_Handle jit,
                           size_t size,
                           size_t alignment);

/**
 * Returns the class handle corresponding to a given allocation handle.
 */
Class_Handle allocation_handle_get_class(Allocation_Handle ah);

/**
 * Returns the offset to the vtable pointer in an object.
 */
int object_get_vtable_offset();

/**
 * Returns the offset from the start of the vtable at which the
 * superclass hierarchy is stored.  This is for use with fast type
 * checking.
 */
int vtable_get_super_array_offset();

/**
 * Returns TRUE if vtable pointers within objects are to be treated
 * as offsets rather than raw pointers.
 */
Boolean vm_vtable_pointers_are_compressed();

/**
 * @return the number of bytes allocated by VM in VTable
 *         for use by GC.
 */
size_t vm_number_of_gc_bytes_in_vtable();

/**
 * Returns the base address of the vtable memory area.  This value will
 * never change and can be cached at startup.
 */
POINTER_SIZE_INT vm_get_vtable_base();

/**
 * Returns the width in bytes (e.g. 4 or 8) of the vtable type
 * information in each object's header.  This is typically used
 * by the JIT for generating type-checking code, e.g. for inlined
 * type checks or for inlining of virtual methods.
 */
unsigned vm_get_runtime_type_handle_width();

/**
 * Returns the number of superclass hierarchy elements that are
 * stored within the vtable.  This is for use with fast type checking.
 */
int vm_max_fast_instanceof_depth();

/* array object access */

/**
 * allocate new vector.
 *
 * @param array_class Class structure of array to be allocated.
 * @param length length of array to be allocated.
 * @return pointer to the allocated array,
 *         NULL if exception occured, and context is not unwindable,
 *         no-return if exception occured in unwindable context.
 *           
 * @throws OutOfMemoryError
 * @note in case that this method is called from jitted code,
 *       unwinding is performed, and this method never returns.
 *       In all other cases, current thread exception is set,
 *       and control is returned.
 * @note implemented in vm_arrays.cpp
 *           
 * NOTE: reference to internal type Class
 */
Vector_Handle vm_new_vector(Class* array_class, int length);

/** 
 * allocate new primitive vector.
 *
 * @copydoc vm_new_vector() 
 *
 * @note attempt to pass non-primitive array class to this function
 *       will cause undefined results.
 *
 * NOTE: reference to internal type Class
 */
Vector_Handle vm_new_vector_primitive(Class* vector_class, int length);

/**
 * Return the offset to the length field of the array.  That field has
 * the same offset for vectors of all types.
 */
int vector_length_offset();

/**
 * Return the offset to the first element of the vector of the given type.
 * Assume that the elements are boxed. Byte offset.
 */
int vector_first_element_offset_class_handle(Class_Handle element_type);

/**
 * Return the offset to the first element of the vector of the given type.
 * Assume that the elements are boxed. Byte offset.
 */
int vector_first_element_offset_vtable_handle(VTable_Handle element_type);

/**
 * Return the offset to the first element of the vector of the given type.
 * This function is provided for the cases when the class handle of the
 * element is not available.
 */
int vector_first_element_offset(VM_Data_Type element_type);

/**
 * Return the offset to the first element of the vector of the given type.
 * If the class is a value type, assume that elements are unboxed.
 * If the class is not a value type, assume that elements are references.
 */
int vector_first_element_offset_unboxed(Class_Handle element_type);

/* object allocation */


/**
 * allocate new object using its Class structure.
 *
 * @param clss Class structure of the object.
 * @note XXX exception and out of memory semantics are not specified -salikh
 * NOTE: reference to internal types Java_java_lang_Object, Class
 */
Java_java_lang_Object* class_alloc_new_object(Class* clss);

/**
 * allocates new object using its VTable structure.
 *
 * @param vtable VTable structure of the object.
 * @note XXX exception and out of memory semantics are not specified -salikh
 * NOTE: reference to internal types Java_java_lang_Object, VTable
 */
Java_java_lang_Object* class_alloc_new_object_using_vtable(VTable *vtable);

/* Kernel */

/**
 * Find Class With Class Loader.
 *
 * NOTE: reference to internal type ClassLoader
 */
jclass FindClassWithClassLoader(const char* name, ClassLoader* loader);

/**
 * Find Class With Class Loader.
 *
 * NOTE: reference to internal type ClassLoader
 */
jclass SignatureToClass (JNIEnv* env_ext, const char* sig, ClassLoader* class_loader);

/**
 * Find field.
 *
 * NOTE: reference to internal types Field, Class
 */
Field* LookupField(Class* clss, const char* name);

/**
 * Find method.
 *
 * NOTE: reference to internal types Method, Class
 */
Method* LookupMethod (Class* clss, const char* mname, const char* msig);
/* NOTE: reference to internal type ClassLoader */

/**
 * Get Method Parameter Types.
 */
jclass* GetMethodParameterTypes (JNIEnv* env, const char* sig, unsigned short* nparams, ClassLoader* class_loader);

#endif /* _VM_CLASS_SUPPORT_H */
