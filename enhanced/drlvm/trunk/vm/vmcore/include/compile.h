/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
/** 
 * @author Intel, Alexei Fedotov
 * @version $Revision: 1.1.2.1.4.3 $
 */  


#ifndef _COMPILE_H_
#define _COMPILE_H_

#include "vm_core_types.h"
#include "environment.h"

class JIT;

extern JIT *jit_compilers[];

void vm_add_jit(JIT *jit);
void vm_delete_all_jits();
void vm_initialize_all_jits();

// Protect arguments from GC
// The arguments are those passed to the last M2nFrame
// The given method's signature describes what arguments were passed
void compile_protect_arguments(Method_Handle method, GcFrame* gc);

// Code has been generated by writing it to memory.
// Ensure that it is visible to all instruction fetchers.
// The first function flushes a particular block of code,
// the other should be called after all blocks are flushed.
void compile_flush_generated_code_block(Byte*, size_t);
void compile_flush_generated_code();

/**
 * Execution manager uses this method to call back to VM to compile
 * a method using a specific JIT.
 */
JIT_Result compile_do_compilation_jit(Method* method, JIT* jit);

NativeCodePtr compile_gen_compile_me(Method_Handle method);
//NativeCodePtr compile_gen_compile_me_exc_throw(int exp);

void patch_code_with_threads_suspended(Byte *code_block, Byte *new_code, size_t size);

typedef char * Emitter_Handle;

struct Compilation_Handle {
    Global_Env* env;
    JIT*        jit;
};

Global_Env* compile_handle_to_environment(Compile_Handle);

// Create a LIL stub for JNI interfacing
NativeCodePtr compile_create_lil_jni_stub(Method_Handle method, void* func, NativeStubOverride nso);

// Create a LIL stub for JNI interfacing
NativeCodePtr interpreter_compile_create_lil_jni_stub(Method_Handle method, void* func, NativeStubOverride nso);


// Create a LIL stub for PINVOKE interfacing
NativeCodePtr compile_create_lil_pinvoke_stub(Method_Handle method, void* func, NativeStubOverride nso);

//
// Support for stub override code sequences 
//

typedef void (Override_Generator)(Emitter_Handle, Method *);
typedef unsigned (Override_Size)(Method *);

typedef struct Stub_Override_Entry {
    char *class_name;
    char *method_name;
    char *descriptor;
    Override_Generator *override_generator;
    Override_Size *override_size;
} Stub_Override_Entry;

// Points to an an array of override entries with sizeof_stub_override_entries entries.
extern Stub_Override_Entry *stub_override_entries;

extern int sizeof_stub_override_entries;

// does this method need an override?
bool needs_override(Method*);


struct DynamicCode
{
    const char *name;
    const void *address;
    jint length;
    DynamicCode *next;
};

// Adding dynamic generated code info to global list
// Is used in JVMTI and native frames interface
DynamicCode* compile_get_dynamic_code_list(void);
// Adding dynamic generated code info to global list
void compile_add_dynamic_generated_code_chunk(const char* name, const void* address, jint length);
void compile_clear_dynamic_code_list(DynamicCode* list);

#endif
