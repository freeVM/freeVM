/*
 * Copyright 2006 The Apache Software Foundation or its licensors, as applicable
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @author Oleg Oleinik
 * @version $Revision: 1.1 $
 */

package org.apache.harmony.test.reliability.api.nio.charset;

import org.apache.harmony.test.reliability.share.Test;

import java.io.UnsupportedEncodingException;
import java.util.SortedMap;
import java.util.Random;
import java.nio.CharBuffer;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CodingErrorAction;

/**
 * Goal: find memory leaks invoking decodings for each available charset using different 
 *       combinations of onUnmappable/onMalformed.
 *
 * The test does:
 *    1. Reads parameters, which are:
 *          param[0] - number of iterations. For each string, each decoding -
 *                     - number of cycles with all combinations of malformed, unmappable actions flags.
 *
 *    2. Creates 2 byte arrays of length 0xFF:
 *       byte[0][] = array of chars for which isJavaIdentifierPart(ch) returns true converted to bytes via UTF-8
 *       byte[1][] = randomly generated bytes
 *
 *    3. For each of the byte array:
 *          1) receives all charsets through availableCharsets().
 *          2) for each charset:
 *              2.1) starts a cycle of param[0] iterations. On each iteration:
 *                   a) sets replaceWith(String) string
 *                   b) choses next combination of onUnmappable/onMalformed
 *                   c) invokes decode(ByteBuffer, CharBuffer, false)
 *                   d) repeats b-c until all 9 combinations of onUnmappable/onMalformed are chosen
 *              2.2) runs System.gc()
 *
 */


public class DecodingModesTest extends Test {

    public int callSystemGC = 1;

    public int SWITCH_ITERATIONS = 100;


    public static void main(String[] args) {
        System.exit(new DecodingModesTest().test(args));
    }


    public int test(String[] params) {

        parseParams(params);

        byte[][] bytes_to_decode = new byte[2][];

        bytes_to_decode[0] = BytesCreator.getUTFBytes(0xFF, "UTF-8");
        bytes_to_decode[1] = BytesCreator.getRandomBytes(0xFF);

        CodingErrorAction[] action = {CodingErrorAction.REPLACE, CodingErrorAction.IGNORE, CodingErrorAction.REPORT};

        for (int k = 0; k < bytes_to_decode.length; ++k) {

            SortedMap allCharsets = Charset.availableCharsets();

            Object[] names = allCharsets.keySet().toArray();

            for (int i = 0; i < names.length; ++i){

                Charset chset = (Charset) allCharsets.get(names[i]);

                CharsetDecoder de = chset.newDecoder().reset();

                ByteBuffer bytes;
                CharBuffer chars;

                // log.add("Charset " + names[i]); 

                for (int j = 0; j < SWITCH_ITERATIONS; ++j) {

                    for (int x = 0; x < action.length; ++x) {

                        for (int y = 0; y < action.length; ++y) {

                            try {

                                bytes = ByteBuffer.wrap(bytes_to_decode[k]);
                                de = de.replaceWith(getReplacementString());
                                de.onMalformedInput(action[x]);
                                de.onUnmappableCharacter(action[y]);
                                de.decode(bytes, CharBuffer.wrap(new char[bytes_to_decode.length]), false);
  
                            } catch (Throwable t) {
                                // log.add(t);
                            }
                        }
                    }

                }

                if (callSystemGC !=0 ){
                    System.gc();
                }

            }

        }

        return pass("OK");
    }


    public void parseParams(String[] params) {

        if (params.length >= 1) {
            SWITCH_ITERATIONS = Integer.parseInt(params[0]);
        }        

    }


    public String getReplacementString() {
        return "a";
    }


}

class BytesCreator {

    public static final int START_TO_END = 2;

    public static final int RANDOM = 3;

    public static byte[] getRandomBytes(int size) {
        
        // creates a byte array of 'size' size with random bytes

        byte[] b = new byte[size];
  
        Random rand = new Random(1);

        int i = 0;

        while (i < b.length) { 

            b[i++] = (byte)rand.nextInt(Byte.MAX_VALUE);

        }

        return b;
    }


    public static byte[] getUTFBytes(int size, String encoding) {

        // creates a byte array of 'size' size with bytes, received
        // by String.getBytes(encoding), where encoding must be Unicode 
        // encoding scheme ("UTG-8", "UTG-16*", etc.) 

        String s = StringCreator.getValidString((char)0, (char)size, StringCreator.START_TO_END);

        try {

            return s.getBytes(encoding);

        } catch (UnsupportedEncodingException uee){

            // log.add("UnsupportedEncodingException :" + encoding);

            return new byte[0];
        }

    }


}



