<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>VM Infrastructure: stack_walker.h File Reference</title>
<link href="hydoxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Packages</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>stack_walker.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="stack_walking.html">Stack Walking subsystem</a> 
<p>
This module contains the interfaces to provide stack walking functionality. Note, that this interfaces are common to all types of stack frames. See specific modules for more on information on particular types of stack frames, e.g. <a class="el" href="native__frame_8h.html" title="native_frame">native_frame.h</a> 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stack_iterator.html">StackIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stack iterator structure.  <a href="struct_stack_iterator.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef unsigned *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#88b916762a6ba313e8d6ab071a542ccf">NativeCodePtr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to code.  <a href="#88b916762a6ba313e8d6ab071a542ccf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef ExecutionEngine *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#d0fe2b1cb2f881b185691a0757e02c07">Execution_Engine_Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque pointer to execution engine.  <a href="#d0fe2b1cb2f881b185691a0757e02c07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="stack__walker_8h.html#60bb34011b37b846d7d5cf2e4abd6391">Execution_Context</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#60bb34011b37b846d7d5cf2e4abd6391">Execution_Context</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Machine-dependent thread context (fully or partly filled): register values.  <a href="#60bb34011b37b846d7d5cf2e4abd6391"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#856bf0f48d7d9c89d1e4216a6f0394e5">ContextType</a> { <a class="el" href="stack__walker_8h.html#856bf0f48d7d9c89d1e4216a6f0394e5eaed122795a562e2d61fb061b20d7017">EC_CT_IP</a>, 
<a class="el" href="stack__walker_8h.html#856bf0f48d7d9c89d1e4216a6f0394e593641e0eb45bf1369a519384d4d103fc">EC_CT_RETIP</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kinds of values stored in executed context.  <a href="stack__walker_8h.html#856bf0f48d7d9c89d1e4216a6f0394e5">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#89236a1fa6bed8f8fb75b6e2f3b211b7">SF_Kind</a> { <br>
&nbsp;&nbsp;<a class="el" href="stack__walker_8h.html#89236a1fa6bed8f8fb75b6e2f3b211b721738de7f0cab58158d0f95bc247c645">SF_JAVA_REAL</a> =  0x1, 
<a class="el" href="stack__walker_8h.html#89236a1fa6bed8f8fb75b6e2f3b211b7add89864677176e65e66a591682ef130">SF_JAVA_INLINED</a> =  0x2, 
<a class="el" href="stack__walker_8h.html#89236a1fa6bed8f8fb75b6e2f3b211b7bf1b83c4c35eaf88491ad1331592e534">SF_JNI</a> =  0x4, 
<a class="el" href="stack__walker_8h.html#89236a1fa6bed8f8fb75b6e2f3b211b7d6f36e58e511409a3e89b8c8c41f96ce">SF_VM</a> =  0x8, 
<br>
&nbsp;&nbsp;<a class="el" href="stack__walker_8h.html#89236a1fa6bed8f8fb75b6e2f3b211b7eb26f07c36f0ff418a1ec858cad00089">SF_JAVA</a> =  SF_JAVA_REAL | SF_JAVA_INLINED, 
<a class="el" href="stack__walker_8h.html#89236a1fa6bed8f8fb75b6e2f3b211b783d1c69d94e1311b98a0bece42179c90">SF_OTHER</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kinds of stack frame.  <a href="stack__walker_8h.html#89236a1fa6bed8f8fb75b6e2f3b211b7">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="stack__walker_8h.html#60bb34011b37b846d7d5cf2e4abd6391">Execution_Context</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#17b1a2a84423e7962996daf340ce499e">ec_get_current</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return execution context of current thread.  <a href="#17b1a2a84423e7962996daf340ce499e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="stack__walker_8h.html#60bb34011b37b846d7d5cf2e4abd6391">Execution_Context</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#e3527f5fb22e9be0cbdd65129567aae4">ec_get_suspended</a> (Thread_Handle <a class="el" href="jvmti__types_8h.html#f4792ab343238a594fcb4f8250056e9a">thread</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return execution context of suspended thread.  <a href="#e3527f5fb22e9be0cbdd65129567aae4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#00fe70dbd5363a37832dcece0dbe6a19">ec_update_current</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">On architectures with register stacks, ensure that the register stack of the current thread is consistent with its backing store, as the backing store might have been modified by stack walking code.  <a href="#00fe70dbd5363a37832dcece0dbe6a19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ContextValue&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#5442c3af64619804aa5c4453576bb0f3">ec_get</a> (<a class="el" href="stack__walker_8h.html#60bb34011b37b846d7d5cf2e4abd6391">Execution_Context</a> context, <a class="el" href="stack__walker_8h.html#856bf0f48d7d9c89d1e4216a6f0394e5">ContextType</a> type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns value contained in specified executing context for specified register.  <a href="#5442c3af64619804aa5c4453576bb0f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#005e5e053c229bcd669a1839d143a6ef">ec_set</a> (<a class="el" href="stack__walker_8h.html#60bb34011b37b846d7d5cf2e4abd6391">Execution_Context</a> context, <a class="el" href="stack__walker_8h.html#856bf0f48d7d9c89d1e4216a6f0394e5">ContextType</a> type, ContextValue value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets value contained in specified executing context for specified register.  <a href="#005e5e053c229bcd669a1839d143a6ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#9ebf8dd7fe3bec5189ee9fafeefd0b3a">si_create</a> (<a class="el" href="stack__walker_8h.html#60bb34011b37b846d7d5cf2e4abd6391">Execution_Context</a> *context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create stack iterator for the specified execution context.  <a href="#9ebf8dd7fe3bec5189ee9fafeefd0b3a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#6432bce157f3a43b34081d54d4aea1f3">si_dup</a> (<a class="el" href="struct_stack_iterator.html">StackIterator</a> *iterator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate stack iterator.  <a href="#6432bce157f3a43b34081d54d4aea1f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#ccd47148f0a10be29b457ac2a95c062b">si_free</a> (<a class="el" href="struct_stack_iterator.html">StackIterator</a> *iterator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory used by stack iterator.  <a href="#ccd47148f0a10be29b457ac2a95c062b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="stack__walker_8h.html#89236a1fa6bed8f8fb75b6e2f3b211b7">SF_Kind</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#582542b808dd5adb0000c724a81cc30c">si_get_kind</a> (<a class="el" href="struct_stack_iterator.html">StackIterator</a> *iterator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the kind of the current stack frame.  <a href="#582542b808dd5adb0000c724a81cc30c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#e5a413b666fc5d7881a1f9504c564280">si_next</a> (<a class="el" href="struct_stack_iterator.html">StackIterator</a> *iterator, <a class="el" href="stack__walker_8h.html#89236a1fa6bed8f8fb75b6e2f3b211b7">SF_Kind</a> kind)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate to next stack frame.  <a href="#e5a413b666fc5d7881a1f9504c564280"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#2a8a57aaffc989b13a63c4739908bcc9">si_done</a> (<a class="el" href="struct_stack_iterator.html">StackIterator</a> *iterator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if iteration is over.  <a href="#2a8a57aaffc989b13a63c4739908bcc9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#015adbeb3f92e34ae7296dd0ab936c7a">si_is_unwindable</a> (<a class="el" href="struct_stack_iterator.html">StackIterator</a> *iterator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if current stack frame is unwindable.  <a href="#015adbeb3f92e34ae7296dd0ab936c7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#221a2d4a5dc9019725f37946d45e528f">si_unwind</a> (<a class="el" href="struct_stack_iterator.html">StackIterator</a> *iterator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unwind current stack frame with restoring the values of saved registers.  <a href="#221a2d4a5dc9019725f37946d45e528f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#c3bbd007c784e3b4eeca4e5d888371d2">si_transfer_control</a> (<a class="el" href="struct_stack_iterator.html">StackIterator</a> *iterator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resume current stack frame on current thread.  <a href="#c3bbd007c784e3b4eeca4e5d888371d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="stack__walker_8h.html#60bb34011b37b846d7d5cf2e4abd6391">Execution_Context</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#b401b83ee59f00f258741c44a56d1364">si_get_context</a> (<a class="el" href="struct_stack_iterator.html">StackIterator</a> *iterator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return pointer to context structure of the current stack frame context.  <a href="#b401b83ee59f00f258741c44a56d1364"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="stack__walker_8h.html#d0fe2b1cb2f881b185691a0757e02c07">Execution_Engine_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#597b5845d937c4624f0311353fcdcdc6">si_get_owner</a> (<a class="el" href="struct_stack_iterator.html">StackIterator</a> *iterator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the pointer to the owner of the stack frame (i.e.  <a href="#597b5845d937c4624f0311353fcdcdc6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#8568360d3ddebe3290ea30fb3da71134">si_enumerate</a> (<a class="el" href="struct_stack_iterator.html">StackIterator</a> *iterator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerate live pointers in current stack frame.  <a href="#8568360d3ddebe3290ea30fb3da71134"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#9061eebf8a39045ced5cb744edd90e25">si_get_info</a> (<a class="el" href="struct_stack_iterator.html">StackIterator</a> *iterator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves information associated with current stack frame.  <a href="#9061eebf8a39045ced5cb744edd90e25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#3692e66f50f8b69f30a3295c6430023d">si_get_method</a> (<a class="el" href="struct_stack_iterator.html">StackIterator</a> *iterator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the method handle of the current stack frame.  <a href="#3692e66f50f8b69f30a3295c6430023d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#3e1a5d15e02c7f954b76055139564ad9">si_get_trace_file</a> (<a class="el" href="struct_stack_iterator.html">StackIterator</a> *iterator, char *buf, int <a class="el" href="jvmti__types_8h.html#1ee8a4cdc2176352791e9feef77e1fd5">length</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the file name corresponding to the current stack frame.  <a href="#3e1a5d15e02c7f954b76055139564ad9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#4568dd09de73d82ba26deb5944455879">si_get_trace_line</a> (<a class="el" href="struct_stack_iterator.html">StackIterator</a> *iterator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the line number corresponding to the current stack frame.  <a href="#4568dd09de73d82ba26deb5944455879"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stack__walker_8h.html#19d7daffb5d26f572f2592dc2b082178">si_get_debug_info</a> (<a class="el" href="struct_stack_iterator.html">StackIterator</a> *iterator, char *buf, int <a class="el" href="jvmti__types_8h.html#1ee8a4cdc2176352791e9feef77e1fd5">length</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves debug information associated with the current stack frame.  <a href="#19d7daffb5d26f572f2592dc2b082178"></a><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="88b916762a6ba313e8d6ab071a542ccf"></a><!-- doxytag: member="stack_walker.h::NativeCodePtr" ref="88b916762a6ba313e8d6ab071a542ccf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned* <a class="el" href="stack__walker_8h.html#88b916762a6ba313e8d6ab071a542ccf">NativeCodePtr</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to code. 
<p>

</div>
</div><p>
<a class="anchor" name="d0fe2b1cb2f881b185691a0757e02c07"></a><!-- doxytag: member="stack_walker.h::Execution_Engine_Handle" ref="d0fe2b1cb2f881b185691a0757e02c07" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ExecutionEngine* <a class="el" href="stack__walker_8h.html#d0fe2b1cb2f881b185691a0757e02c07">Execution_Engine_Handle</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opaque pointer to execution engine. 
<p>

</div>
</div><p>
<a class="anchor" name="60bb34011b37b846d7d5cf2e4abd6391"></a><!-- doxytag: member="stack_walker.h::Execution_Context" ref="60bb34011b37b846d7d5cf2e4abd6391" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="stack__walker_8h.html#60bb34011b37b846d7d5cf2e4abd6391">Execution_Context</a> <a class="el" href="stack__walker_8h.html#60bb34011b37b846d7d5cf2e4abd6391">Execution_Context</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Machine-dependent thread context (fully or partly filled): register values. 
<p>

</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="856bf0f48d7d9c89d1e4216a6f0394e5"></a><!-- doxytag: member="stack_walker.h::ContextType" ref="856bf0f48d7d9c89d1e4216a6f0394e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="stack__walker_8h.html#856bf0f48d7d9c89d1e4216a6f0394e5">ContextType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Kinds of values stored in executed context. 
<p>
This clasification is machine dependent, but there are common part like IP and return IP. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="856bf0f48d7d9c89d1e4216a6f0394e5eaed122795a562e2d61fb061b20d7017"></a><!-- doxytag: member="EC_CT_IP" ref="856bf0f48d7d9c89d1e4216a6f0394e5eaed122795a562e2d61fb061b20d7017" args="" -->EC_CT_IP</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="856bf0f48d7d9c89d1e4216a6f0394e593641e0eb45bf1369a519384d4d103fc"></a><!-- doxytag: member="EC_CT_RETIP" ref="856bf0f48d7d9c89d1e4216a6f0394e593641e0eb45bf1369a519384d4d103fc" args="" -->EC_CT_RETIP</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="89236a1fa6bed8f8fb75b6e2f3b211b7"></a><!-- doxytag: member="stack_walker.h::SF_Kind" ref="89236a1fa6bed8f8fb75b6e2f3b211b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="stack__walker_8h.html#89236a1fa6bed8f8fb75b6e2f3b211b7">SF_Kind</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Kinds of stack frame. 
<p>
This classification is intended for security manager to be able to distinguish stack frames it does not need to take into account, for example, VM stack frames.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>XXX <ul>
</ul>
fact, two different orthogonal classifications exist: by the owner: interpreter, JIT, VM, JNI by the java spec: java, JNI, other  Current vision is that owner classification is available through <a class="el" href="stack__walker_8h.html#597b5845d937c4624f0311353fcdcdc6" title="Get the pointer to the owner of the stack frame (i.e.">si_get_owner()</a>. </dd></dl>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="89236a1fa6bed8f8fb75b6e2f3b211b721738de7f0cab58158d0f95bc247c645"></a><!-- doxytag: member="SF_JAVA_REAL" ref="89236a1fa6bed8f8fb75b6e2f3b211b721738de7f0cab58158d0f95bc247c645" args="" -->SF_JAVA_REAL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="89236a1fa6bed8f8fb75b6e2f3b211b7add89864677176e65e66a591682ef130"></a><!-- doxytag: member="SF_JAVA_INLINED" ref="89236a1fa6bed8f8fb75b6e2f3b211b7add89864677176e65e66a591682ef130" args="" -->SF_JAVA_INLINED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="89236a1fa6bed8f8fb75b6e2f3b211b7bf1b83c4c35eaf88491ad1331592e534"></a><!-- doxytag: member="SF_JNI" ref="89236a1fa6bed8f8fb75b6e2f3b211b7bf1b83c4c35eaf88491ad1331592e534" args="" -->SF_JNI</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="89236a1fa6bed8f8fb75b6e2f3b211b7d6f36e58e511409a3e89b8c8c41f96ce"></a><!-- doxytag: member="SF_VM" ref="89236a1fa6bed8f8fb75b6e2f3b211b7d6f36e58e511409a3e89b8c8c41f96ce" args="" -->SF_VM</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="89236a1fa6bed8f8fb75b6e2f3b211b7eb26f07c36f0ff418a1ec858cad00089"></a><!-- doxytag: member="SF_JAVA" ref="89236a1fa6bed8f8fb75b6e2f3b211b7eb26f07c36f0ff418a1ec858cad00089" args="" -->SF_JAVA</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="89236a1fa6bed8f8fb75b6e2f3b211b783d1c69d94e1311b98a0bece42179c90"></a><!-- doxytag: member="SF_OTHER" ref="89236a1fa6bed8f8fb75b6e2f3b211b783d1c69d94e1311b98a0bece42179c90" args="" -->SF_OTHER</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="17b1a2a84423e7962996daf340ce499e"></a><!-- doxytag: member="stack_walker.h::ec_get_current" ref="17b1a2a84423e7962996daf340ce499e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stack__walker_8h.html#60bb34011b37b846d7d5cf2e4abd6391">Execution_Context</a> ec_get_current           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return execution context of current thread. 
<p>

</div>
</div><p>
<a class="anchor" name="e3527f5fb22e9be0cbdd65129567aae4"></a><!-- doxytag: member="stack_walker.h::ec_get_suspended" ref="e3527f5fb22e9be0cbdd65129567aae4" args="(Thread_Handle thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stack__walker_8h.html#60bb34011b37b846d7d5cf2e4abd6391">Execution_Context</a> ec_get_suspended           </td>
          <td>(</td>
          <td class="paramtype">Thread_Handle&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return execution context of suspended thread. 
<p>

</div>
</div><p>
<a class="anchor" name="00fe70dbd5363a37832dcece0dbe6a19"></a><!-- doxytag: member="stack_walker.h::ec_update_current" ref="00fe70dbd5363a37832dcece0dbe6a19" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ec_update_current           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
On architectures with register stacks, ensure that the register stack of the current thread is consistent with its backing store, as the backing store might have been modified by stack walking code. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>rename of the function si_reload_registers </dd></dl>

</div>
</div><p>
<a class="anchor" name="5442c3af64619804aa5c4453576bb0f3"></a><!-- doxytag: member="stack_walker.h::ec_get" ref="5442c3af64619804aa5c4453576bb0f3" args="(Execution_Context context, ContextType type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ContextValue ec_get           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stack__walker_8h.html#60bb34011b37b846d7d5cf2e4abd6391">Execution_Context</a>&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stack__walker_8h.html#856bf0f48d7d9c89d1e4216a6f0394e5">ContextType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns value contained in specified executing context for specified register. 
<p>

</div>
</div><p>
<a class="anchor" name="005e5e053c229bcd669a1839d143a6ef"></a><!-- doxytag: member="stack_walker.h::ec_set" ref="005e5e053c229bcd669a1839d143a6ef" args="(Execution_Context context, ContextType type, ContextValue value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ec_set           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stack__walker_8h.html#60bb34011b37b846d7d5cf2e4abd6391">Execution_Context</a>&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stack__walker_8h.html#856bf0f48d7d9c89d1e4216a6f0394e5">ContextType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContextValue&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets value contained in specified executing context for specified register. 
<p>

</div>
</div><p>
<a class="anchor" name="9ebf8dd7fe3bec5189ee9fafeefd0b3a"></a><!-- doxytag: member="stack_walker.h::si_create" ref="9ebf8dd7fe3bec5189ee9fafeefd0b3a" args="(Execution_Context *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_stack_iterator.html">StackIterator</a>* si_create           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stack__walker_8h.html#60bb34011b37b846d7d5cf2e4abd6391">Execution_Context</a> *&nbsp;</td>
          <td class="paramname"> <em>context</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create stack iterator for the specified execution context. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>consolidation of si_create_from_registers() and si_create_from_native(thread) </dd></dl>

</div>
</div><p>
<a class="anchor" name="6432bce157f3a43b34081d54d4aea1f3"></a><!-- doxytag: member="stack_walker.h::si_dup" ref="6432bce157f3a43b34081d54d4aea1f3" args="(StackIterator *iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_stack_iterator.html">StackIterator</a>* si_dup           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Duplicate stack iterator. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>used only once in current VM. Probably may be eliminated. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ccd47148f0a10be29b457ac2a95c062b"></a><!-- doxytag: member="stack_walker.h::si_free" ref="ccd47148f0a10be29b457ac2a95c062b" args="(StackIterator *iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void si_free           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free memory used by stack iterator. 
<p>

</div>
</div><p>
<a class="anchor" name="582542b808dd5adb0000c724a81cc30c"></a><!-- doxytag: member="stack_walker.h::si_get_kind" ref="582542b808dd5adb0000c724a81cc30c" args="(StackIterator *iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stack__walker_8h.html#89236a1fa6bed8f8fb75b6e2f3b211b7">SF_Kind</a> si_get_kind           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the kind of the current stack frame. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="stack__walker_8h.html#89236a1fa6bed8f8fb75b6e2f3b211b7" title="Kinds of stack frame.">SF_Kind</a> </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>How to compute the kind of the stack frame? </dd></dl>

</div>
</div><p>
<a class="anchor" name="e5a413b666fc5d7881a1f9504c564280"></a><!-- doxytag: member="stack_walker.h::si_next" ref="e5a413b666fc5d7881a1f9504c564280" args="(StackIterator *iterator, SF_Kind kind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool si_next           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stack__walker_8h.html#89236a1fa6bed8f8fb75b6e2f3b211b7">SF_Kind</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterate to next stack frame. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator</em>&nbsp;</td><td>- the pointer to the stack frame</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if iterator still points to a stack frame, false if iteration is complete. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>rename of si_goto_previous() </dd></dl>

</div>
</div><p>
<a class="anchor" name="2a8a57aaffc989b13a63c4739908bcc9"></a><!-- doxytag: member="stack_walker.h::si_done" ref="2a8a57aaffc989b13a63c4739908bcc9" args="(StackIterator *iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool si_done           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if iteration is over. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>rename of si_is_past_end()</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator</em>&nbsp;</td><td>- the pointer to the stack frame </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="015adbeb3f92e34ae7296dd0ab936c7a"></a><!-- doxytag: member="stack_walker.h::si_is_unwindable" ref="015adbeb3f92e34ae7296dd0ab936c7a" args="(StackIterator *iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool si_is_unwindable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if current stack frame is unwindable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator</em>&nbsp;</td><td>- the pointer to the stack frame </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="221a2d4a5dc9019725f37946d45e528f"></a><!-- doxytag: member="stack_walker.h::si_unwind" ref="221a2d4a5dc9019725f37946d45e528f" args="(StackIterator *iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void si_unwind           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unwind current stack frame with restoring the values of saved registers. 
<p>
The synchronization objects must be carefully released by this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator</em>&nbsp;</td><td>- the pointer to the stack frame </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c3bbd007c784e3b4eeca4e5d888371d2"></a><!-- doxytag: member="stack_walker.h::si_transfer_control" ref="c3bbd007c784e3b4eeca4e5d888371d2" args="(StackIterator *iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void si_transfer_control           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resume current stack frame on current thread. 
<p>
This function frees the iterator and does not return.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Equivalent to transfer_control(si_get_context(iterator)) and may be eliminated as such.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator</em>&nbsp;</td><td>- the pointer to the stack frame </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b401b83ee59f00f258741c44a56d1364"></a><!-- doxytag: member="stack_walker.h::si_get_context" ref="b401b83ee59f00f258741c44a56d1364" args="(StackIterator *iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stack__walker_8h.html#60bb34011b37b846d7d5cf2e4abd6391">Execution_Context</a>* si_get_context           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return pointer to context structure of the current stack frame context. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator</em>&nbsp;</td><td>- the pointer to the stack frame </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="597b5845d937c4624f0311353fcdcdc6"></a><!-- doxytag: member="stack_walker.h::si_get_owner" ref="597b5845d937c4624f0311353fcdcdc6" args="(StackIterator *iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stack__walker_8h.html#d0fe2b1cb2f881b185691a0757e02c07">Execution_Engine_Handle</a> si_get_owner           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the pointer to the owner of the stack frame (i.e. 
<p>
JIT or interpreter).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>We may want to have a dummy execution engine corresponding to the native C++ compiler in order to provide more functionality for VM code.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator</em>&nbsp;</td><td>- the pointer to the stack frame </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8568360d3ddebe3290ea30fb3da71134"></a><!-- doxytag: member="stack_walker.h::si_enumerate" ref="8568360d3ddebe3290ea30fb3da71134" args="(StackIterator *iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void si_enumerate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumerate live pointers in current stack frame. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Real enumeration is delegated to the exucution engine owning the current stack frame. This method may be completely eliminated in favour of using EE interfaces directly.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator</em>&nbsp;</td><td>- the pointer to the stack frame </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9061eebf8a39045ced5cb744edd90e25"></a><!-- doxytag: member="stack_walker.h::si_get_info" ref="9061eebf8a39045ced5cb744edd90e25" args="(StackIterator *iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* si_get_info           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves information associated with current stack frame. 
<p>
For native or interpreter frames it is likely to return pointer to the actual frame structure, for jitted frames may return the value of base stack register.<p>
The returned value may be used as a parameter to functions provided by the execution engine owning the stack frame.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator</em>&nbsp;</td><td>- the pointer to the stack frame </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3692e66f50f8b69f30a3295c6430023d"></a><!-- doxytag: member="stack_walker.h::si_get_method" ref="3692e66f50f8b69f30a3295c6430023d" args="(StackIterator *iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_method.html">Method_Handle</a> si_get_method           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the method handle of the current stack frame. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator</em>&nbsp;</td><td>- the pointer to the stack frame </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3e1a5d15e02c7f954b76055139564ad9"></a><!-- doxytag: member="stack_walker.h::si_get_trace_file" ref="3e1a5d15e02c7f954b76055139564ad9" args="(StackIterator *iterator, char *buf, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void si_get_trace_file           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the file name corresponding to the current stack frame. 
<p>
If no information is available, an empty string is written to the buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator</em>&nbsp;</td><td>- the pointer to the stack frame </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- the buffer to be filled </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>- the size of the buffer. If the size is not sufficient to hold the file name, then file name is truncated.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>the request is delegated to execution engine. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4568dd09de73d82ba26deb5944455879"></a><!-- doxytag: member="stack_walker.h::si_get_trace_line" ref="4568dd09de73d82ba26deb5944455879" args="(StackIterator *iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int si_get_trace_line           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the line number corresponding to the current stack frame. 
<p>
If the number is not available, returns 0.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator</em>&nbsp;</td><td>- the pointer to the stack frame </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the line number corresponding to the current stack frame, where routine is working now. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The request is delegated to execution engine. </dd></dl>

</div>
</div><p>
<a class="anchor" name="19d7daffb5d26f572f2592dc2b082178"></a><!-- doxytag: member="stack_walker.h::si_get_debug_info" ref="19d7daffb5d26f572f2592dc2b082178" args="(StackIterator *iterator, char *buf, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void si_get_debug_info           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_stack_iterator.html">StackIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves debug information associated with the current stack frame. 
<p>
The format of this information is implementation-dependent.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator</em>&nbsp;</td><td>- the pointer to the stack frame</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>the request is delegated to execution engine. </dd></dl>

</div>
</div><p>
<hr size="1">
<address style="text-align: center;">
  <small>
    <p>Genereated on Tue Mar 11 19:25:58 2008 by Doxygen.</p>
    <p>(c) Copyright 2005, 2008 The Apache Software Foundation or its licensors, as applicable. </p>
  </small>
</address>
</body>
</html>
