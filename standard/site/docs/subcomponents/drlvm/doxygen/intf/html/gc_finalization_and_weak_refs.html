<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Inter-component Interfaces: Finalization and weak references design in GC</title>
<link href="hydoxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Packages</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1><a class="anchor" name="gc_finalization_and_weak_refs">Finalization and weak references design in GC</a></h1><h2><a class="anchor" name="gc_finalization">
Finalization</a></h2>
According to the JVM specification, VM must call non-trivial finalization methods before reclaiming the spaced used by object. Java API specification adds more requiremens by stating that soft references must be cleared before weak references, weak references must be cleared before object becomes eligible for finalization, and that phantom references must be cleared last. JNI specification adds a little bit more by specifying global weak references strength to be about the same as phantom reference strengh, however, without requiring any particular interaction from them. (In the code we sometimes refer to weak references as <em>short weak references<em>, and call JNI weak global references <em>long weak references</em>.</em></em><p>
<em><em> <dl class="see" compact><dt><b>See also:</b></dt><dd><code><a class="el" href="gc_8h.html#5f0dc3bc779ca12d08de0180aeb1b0b2" title="Is called by the VM to enumerate weak root reference.">gc_add_weak_root_set_entry()</a></code> for more details</dd></dl>
The requirements described above can be met using following algorithm. <ul>
<li>All weak reference classes can be identified on the stage of class preparation, when VM calls <code><a class="el" href="gc_8h.html#76617bcedc9e24a83e47731bae2f1c30" title="The VM calls this function after a new class has been prepared.">gc_class_prepared()</a></code> callback. </li>
<li>We start marking with regular (strong) roots, and traverse only strong references. During the process of marking all objects of the reference classes are collected to the reference lists. As we traverse only strong references, only strongly reachable reference will be scheduled for clearing and enqueueing. </li>
<li>At the end of marking we have strongly reachable objects marked. Unmarked objects may be any of softly, weakly, f-, or phantomly reachable. </li>
<li>Then we consider all strongly reachable soft references, and make a decision on whether we need to clear them, based on the pending allocation request (if any), the current heap size, the information collected during marking and information about general GC dynamics. </li>
<li>Soft references which were chosen for clearing are reset, and other soft references are retraced, this time by both strong and soft references. Technically speaking, we add soft reference object pointers to the roots array, and add referent offset to the reference field array of SoftReference class, then restart regular mark task. During this trace, all softly reachable objects will be marked, and all softly (and strongly reachable) weak reference objects collected in a reference list. </li>
<li>Next we consider the list of weak references, and clear the references which point to dead (unmarked) objects. Note, that ordering of handling of soft and weak references is important and gives as the guarantees required by the Java specifications. </li>
<li>Short weak root handling is similar to weak references. </li>
<li>Finalizable objects are considered to find out objects, which became unreachable during this collection. Objects to be finalized are then revived by adding the finalizable queue to the root set and restarting mark process. </li>
<li>Phantom references are considered, and the references to unmarked objects are cleared. </li>
<li>Long weak roots are handled in exactly the same way as short weak roots. </li>
<li>Note, that as the references are cleared, they are also added to the list of references to be enqueued. This list is later transferred to the VM using <code><a class="el" href="vm__gc_8h.html#5a4a3e7955a318471d6bed2003520429" title="GC should call this function when an phantom reference object is to be enqueued,...">vm_enqueue_reference()</a></code> function. </li>
<li>Weak reference objects require special handling of their referent field, because it needs to be reported as an updatable slot before compaction. This is performed as a last step, when we have a guarantee that all unmarked objects are dead at that moment.</li>
</ul>
</em></em><h2><a class="anchor" name="gc_finalization_and_weak_refs_requirements">
Adopted Requirements</a></h2>
<em><em> Current implementation of weak references places the following requirements <ul>
<li>All reference objects must have exactly one non-regulur object reference, and this reference must be at the same offset for references of all types. GC calls <code><a class="el" href="vm__gc_8h.html#70b8e9b45e83bc88d8d10cedffaa1758" title="Returns non-zero value if the class represented by Class_Handle is a descendant of...">class_is_reference()</a></code> to find out whether the class represents weak reference and finds out the referent offset by calling VM function <code><a class="el" href="vm__gc_8h.html#028c764fd020d6c285b315ca860f3c86" title="Returns the offset of the referent field in the java.lang.ref.Reference object.">class_get_referent_offset()</a></code>. Note, that referent offset being constant for all kinds of references is not enforced by this interface. </li>
<li>VM must not enqueue references during call of <code><a class="el" href="vm__gc_8h.html#5a4a3e7955a318471d6bed2003520429" title="GC should call this function when an phantom reference object is to be enqueued,...">vm_enqueue_reference()</a></code> because this may lead to deadlocks on reference queue monitors due to the fact that <code><a class="el" href="vm__gc_8h.html#5a4a3e7955a318471d6bed2003520429" title="GC should call this function when an phantom reference object is to be enqueued,...">vm_enqueue_reference()</a></code> is called during stop-the-world phase of garbage collection. </li>
</ul>
</em></em><hr size="1">
<address style="text-align: center;">
  <small>
    <p>Genereated on Tue Mar 11 19:25:23 2008 by Doxygen.</p>
    <p>(c) Copyright 2005, 2008 The Apache Software Foundation or its licensors, as applicable. </p>
  </small>
</address>
</body>
</html>
