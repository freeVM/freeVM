<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Porting Layer: EncoderBase Class Reference</title>
<link href="hydoxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Packages</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>EncoderBase Class Reference</h1><!-- doxytag: class="EncoderBase" --><code>#include &lt;enc_base.h&gt;</code>
<p>
<a href="class_encoder_base-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Basic facilities for generation of processor's instructions. 
<p>
The class <a class="el" href="class_encoder_base.html" title="Basic facilities for generation of processor's instructions.">EncoderBase</a> represents the basic facilities for the encoding of processor's instructions on IA32 and EM64T platforms.<p>
The class provides general interface to generate the instructions as well as to retrieve some static data about instructions (number of arguments, their roles, etc).<p>
Currently, the <a class="el" href="class_encoder_base.html" title="Basic facilities for generation of processor's instructions.">EncoderBase</a> class is used for both LIL and Jitrino code generators. Each of these code generators has its own wrapper to adapt this general interface for specific needs - see <a class="el" href="encoder_8h.html" title="Simple interface for generating processor instructions.">encoder.h</a> for LIL wrappers and Ia32Encoder.h for Jitrino's adapter.<p>
Interface is provided through static methods, no instances of <a class="el" href="class_encoder_base.html" title="Basic facilities for generation of processor's instructions.">EncoderBase</a> to be created.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>RIP-based addressing on EM64T - it's not yet supported currently. </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#d615cb4cbfdb6fcd420d48975d3f90ef">encode</a> (char *stream, <a class="el" href="enc__defs_8h.html#9f4c39258cc8dc05ca58cfb84306107e">Mnemonic</a> mn, const <a class="el" href="class_encoder_base_1_1_operands.html">Operands</a> &amp;opnds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates processor's instruction.  <a href="#d615cb4cbfdb6fcd420d48975d3f90ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#f574754673109a00082b940ce0b9ebc1">nops</a> (char *stream, unsigned howMany)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates the smallest possible number of NOP-s.  <a href="#f574754673109a00082b940ce0b9ebc1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#a98f51aa2d999278ced044ce4da280ef">prefix</a> (char *stream, <a class="el" href="enc__defs_8h.html#4ba40f381ec1b1eeb03fb3cab87a5c6a">InstPrefix</a> pref)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts a prefix into the code buffer.  <a href="#a98f51aa2d999278ced044ce4da280ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="struct_encoder_base_1_1_mnemonic_desc.html">MnemonicDesc</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#f8f5fce5333f198cd78711d3cc094820">getMnemonicDesc</a> (<a class="el" href="enc__defs_8h.html#9f4c39258cc8dc05ca58cfb84306107e">Mnemonic</a> mn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns MnemonicDesc by the given Mnemonic.  <a href="#f8f5fce5333f198cd78711d3cc094820"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="enc__defs_8h.html#9f4c39258cc8dc05ca58cfb84306107e">Mnemonic</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#b7d458f3329085c75579bd3e7424a87e">str2mnemonic</a> (const char *mn_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a Mnemonic for the given name.  <a href="#b7d458f3329085c75579bd3e7424a87e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#ceee55eba598d92c1a5c39532e9c92be">getMnemonicString</a> (<a class="el" href="enc__defs_8h.html#9f4c39258cc8dc05ca58cfb84306107e">Mnemonic</a> mn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a string representation of the given Mnemonic.  <a href="#ceee55eba598d92c1a5c39532e9c92be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#28d8d646cd08878e8c2cb1b3d80fb01e">toStr</a> (<a class="el" href="enc__defs_8h.html#9f4c39258cc8dc05ca58cfb84306107e">Mnemonic</a> mn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="enc__defs_8h.html#dced35d4c26ef0991ba446901b88b34f">OpndRole</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#b8270d654a04a1f3707e08ed911fd223">getOpndRoles</a> (<a class="el" href="struct_encoder_base_1_1_opnd_roles_desc.html">OpndRolesDesc</a> ord, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts appropriate OpndRole for a given operand.  <a href="#b8270d654a04a1f3707e08ed911fd223"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#8c9af1bd6d109ee24cec63d7dcc3ea03">buildTable</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#f0a8818d3f58d58dccbc38b9d49ea6c3">buildMnemonicDesc</a> (const <a class="el" href="struct_mnemonic_info.html">MnemonicInfo</a> *minfo)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#fd0be52bf28720b9e99d8f3550607901">getHash</a> (const <a class="el" href="struct_opcode_info.html">OpcodeInfo</a> *odesc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes hash value for the given operands.  <a href="#fd0be52bf28720b9e99d8f3550607901"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#88bf5c19de4dc735983419f06a774546">HASH_MAX</a> = 8192</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Magic number, shows a maximum value a hash code can take.  <a href="#88bf5c19de4dc735983419f06a774546"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#5305444c285df9c7c28fbe5e71b8c078">NOHASH</a> = 0xFF</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Empty value, used in hash-to-opcode map to show an empty slot.  <a href="#5305444c285df9c7c28fbe5e71b8c078"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#31acb1d53c4e5fb596d723a959f950a0">HASH_BITS_PER_OPERAND</a> = 5</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The name says it all.  <a href="#31acb1d53c4e5fb596d723a959f950a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#dc4656551a60b38fb01d2b3513aefafc">size_hash</a> [OpndSize_64+1]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A table used for the fast computation of hash value.  <a href="#dc4656551a60b38fb01d2b3513aefafc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#1f9e3fc865a588d45ac88c0f855038d4">kind_hash</a> [OpndKind_Mem+1]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A table used for the fast computation of hash value.  <a href="#1f9e3fc865a588d45ac88c0f855038d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#30f87fd2b9c33846b46575b2018694de">MAX_OPCODES</a> = 32</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum number of opcodes used for a single mnemonic.  <a href="#30f87fd2b9c33846b46575b2018694de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#ad12d20c697e9893fbf423011ff126b3">opcodesHashMap</a> [Mnemonic_Count][<a class="el" href="class_encoder_base.html#88bf5c19de4dc735983419f06a774546">HASH_MAX</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mapping between operands hash code and operands.  <a href="#ad12d20c697e9893fbf423011ff126b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="struct_encoder_base_1_1_mnemonic_desc.html">MnemonicDesc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#8bd8e1ac4474b54de8443dadcd6d9b03">mnemonics</a> [Mnemonic_Count]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of mnemonics.  <a href="#8bd8e1ac4474b54de8443dadcd6d9b03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="union_encoder_base_1_1_opcode_desc.html">OpcodeDesc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#bb52365702866b57937a385a9ae9a489">opcodes</a> [Mnemonic_Count][<a class="el" href="class_encoder_base.html#30f87fd2b9c33846b46575b2018694de">MAX_OPCODES</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of available opcodes.  <a href="#bb52365702866b57937a385a9ae9a489"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base.html#2c17413b4ed86b32bd983293557cf898">dummy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dummy variable, for automatic invocation of <a class="el" href="class_encoder_base.html#8c9af1bd6d109ee24cec63d7dcc3ea03">buildTable()</a> at startup.  <a href="#2c17413b4ed86b32bd983293557cf898"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_encoder_base_1_1_mnemonic_desc.html">MnemonicDesc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">General info about mnemonic.  <a href="struct_encoder_base_1_1_mnemonic_desc.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_encoder_base_1_1_opcode_desc.html">OpcodeDesc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Info about single opcode - its opcode bytes, operands, operands' roles.  <a href="union_encoder_base_1_1_opcode_desc.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base_1_1_operand.html">Operand</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains info about a single instructions's operand - its location, size and a value for immediate or RegName for register operands.  <a href="class_encoder_base_1_1_operand.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoder_base_1_1_operands.html">Operands</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple container for up to 3 Operand-s.  <a href="class_encoder_base_1_1_operands.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_encoder_base_1_1_opnd_desc.html">OpndDesc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Description of operand.  <a href="struct_encoder_base_1_1_opnd_desc.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_encoder_base_1_1_opnd_roles_desc.html">OpndRolesDesc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Description of operands' roles in instruction.  <a href="struct_encoder_base_1_1_opnd_roles_desc.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d615cb4cbfdb6fcd420d48975d3f90ef"></a><!-- doxytag: member="EncoderBase::encode" ref="d615cb4cbfdb6fcd420d48975d3f90ef" args="(char *stream, Mnemonic mn, const Operands &amp;opnds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static char* EncoderBase.encode           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="enc__defs_8h.html#9f4c39258cc8dc05ca58cfb84306107e">Mnemonic</a>&nbsp;</td>
          <td class="paramname"> <em>mn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_encoder_base_1_1_operands.html">Operands</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>opnds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generates processor's instruction. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>- a buffer to generate into </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mn</em>&nbsp;</td><td>- <a class="el" href="">mnemonic </a> of the instruction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opnds</em>&nbsp;</td><td>- operands for the instruction </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>(stream + length of the just generated instruction) </dd></dl>

</div>
</div><p>
<a class="anchor" name="f574754673109a00082b940ce0b9ebc1"></a><!-- doxytag: member="EncoderBase::nops" ref="f574754673109a00082b940ce0b9ebc1" args="(char *stream, unsigned howMany)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static char* EncoderBase.nops           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>howMany</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generates the smallest possible number of NOP-s. 
<p>
Effectively generates the smallest possible number of instructions, which are NOP-s for CPU. Normally used to make a code alignment.<p>
The method inserts exactly number of bytes specified. It's a caller's responsibility to make sure the buffer is big enough.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>- buffer where to generate code into, can not be NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>howMany</em>&nbsp;</td><td>- how many bytes to fill with NOP-s </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code></code>(stream+howMany) </dd></dl>

</div>
</div><p>
<a class="anchor" name="a98f51aa2d999278ced044ce4da280ef"></a><!-- doxytag: member="EncoderBase::prefix" ref="a98f51aa2d999278ced044ce4da280ef" args="(char *stream, InstPrefix pref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static char* EncoderBase.prefix           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="enc__defs_8h.html#4ba40f381ec1b1eeb03fb3cab87a5c6a">InstPrefix</a>&nbsp;</td>
          <td class="paramname"> <em>pref</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts a prefix into the code buffer. 
<p>
The method writes no more than one byte into the buffer. This is a caller's responsibility to make sure the buffer is big enough.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>- buffer where to insert the prefix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pref</em>&nbsp;</td><td>- prefix to be inserted. If it's InstPrefix_Null, then no action performed and return value is <code>stream</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code></code>(stream+1) if pref is not InstPrefix_Null, or <code>stream</code> otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="f8f5fce5333f198cd78711d3cc094820"></a><!-- doxytag: member="EncoderBase::getMnemonicDesc" ref="f8f5fce5333f198cd78711d3cc094820" args="(Mnemonic mn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="struct_encoder_base_1_1_mnemonic_desc.html">MnemonicDesc</a>* EncoderBase.getMnemonicDesc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="enc__defs_8h.html#9f4c39258cc8dc05ca58cfb84306107e">Mnemonic</a>&nbsp;</td>
          <td class="paramname"> <em>mn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns MnemonicDesc by the given Mnemonic. 
<p>

</div>
</div><p>
<a class="anchor" name="b7d458f3329085c75579bd3e7424a87e"></a><!-- doxytag: member="EncoderBase::str2mnemonic" ref="b7d458f3329085c75579bd3e7424a87e" args="(const char *mn_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="enc__defs_8h.html#9f4c39258cc8dc05ca58cfb84306107e">Mnemonic</a> EncoderBase.str2mnemonic           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mn_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a Mnemonic for the given name. 
<p>
The lookup is case insensitive, if no mnemonic found for the given string, then Mnemonic_Null returned. 
</div>
</div><p>
<a class="anchor" name="ceee55eba598d92c1a5c39532e9c92be"></a><!-- doxytag: member="EncoderBase::getMnemonicString" ref="ceee55eba598d92c1a5c39532e9c92be" args="(Mnemonic mn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const char* EncoderBase.getMnemonicString           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="enc__defs_8h.html#9f4c39258cc8dc05ca58cfb84306107e">Mnemonic</a>&nbsp;</td>
          <td class="paramname"> <em>mn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a string representation of the given Mnemonic. 
<p>
If invalid mnemonic passed, then the behavior is unpredictable. 
</div>
</div><p>
<a class="anchor" name="28d8d646cd08878e8c2cb1b3d80fb01e"></a><!-- doxytag: member="EncoderBase::toStr" ref="28d8d646cd08878e8c2cb1b3d80fb01e" args="(Mnemonic mn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const char* EncoderBase.toStr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="enc__defs_8h.html#9f4c39258cc8dc05ca58cfb84306107e">Mnemonic</a>&nbsp;</td>
          <td class="paramname"> <em>mn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b8270d654a04a1f3707e08ed911fd223"></a><!-- doxytag: member="EncoderBase::getOpndRoles" ref="b8270d654a04a1f3707e08ed911fd223" args="(OpndRolesDesc ord, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="enc__defs_8h.html#dced35d4c26ef0991ba446901b88b34f">OpndRole</a> EncoderBase.getOpndRoles           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_encoder_base_1_1_opnd_roles_desc.html">OpndRolesDesc</a>&nbsp;</td>
          <td class="paramname"> <em>ord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extracts appropriate OpndRole for a given operand. 
<p>
The order of operands is left-to-right, i.e. for MOV, it would be 'MOV op0, op1' 
</div>
</div><p>
<a class="anchor" name="8c9af1bd6d109ee24cec63d7dcc3ea03"></a><!-- doxytag: member="EncoderBase::buildTable" ref="8c9af1bd6d109ee24cec63d7dcc3ea03" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int EncoderBase.buildTable           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f0a8818d3f58d58dccbc38b9d49ea6c3"></a><!-- doxytag: member="EncoderBase::buildMnemonicDesc" ref="f0a8818d3f58d58dccbc38b9d49ea6c3" args="(const MnemonicInfo *minfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void EncoderBase.buildMnemonicDesc           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_mnemonic_info.html">MnemonicInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>minfo</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="fd0be52bf28720b9e99d8f3550607901"></a><!-- doxytag: member="EncoderBase::getHash" ref="fd0be52bf28720b9e99d8f3550607901" args="(const OpcodeInfo *odesc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned short EncoderBase.getHash           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_opcode_info.html">OpcodeInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>odesc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes hash value for the given operands. 
<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="88bf5c19de4dc735983419f06a774546"></a><!-- doxytag: member="EncoderBase::HASH_MAX" ref="88bf5c19de4dc735983419f06a774546" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="class_encoder_base.html#88bf5c19de4dc735983419f06a774546">EncoderBase.HASH_MAX</a> = 8192<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Magic number, shows a maximum value a hash code can take. 
<p>
For meaning and arithmetics see enc_tabl.cpp.<p>
The value was increased from '5155' to '8192' to make it aligned for faster access in EncoderBase.lookup(). 
</div>
</div><p>
<a class="anchor" name="5305444c285df9c7c28fbe5e71b8c078"></a><!-- doxytag: member="EncoderBase::NOHASH" ref="5305444c285df9c7c28fbe5e71b8c078" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="class_encoder_base.html#5305444c285df9c7c28fbe5e71b8c078">EncoderBase.NOHASH</a> = 0xFF<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Empty value, used in hash-to-opcode map to show an empty slot. 
<p>

</div>
</div><p>
<a class="anchor" name="31acb1d53c4e5fb596d723a959f950a0"></a><!-- doxytag: member="EncoderBase::HASH_BITS_PER_OPERAND" ref="31acb1d53c4e5fb596d723a959f950a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="class_encoder_base.html#31acb1d53c4e5fb596d723a959f950a0">EncoderBase.HASH_BITS_PER_OPERAND</a> = 5<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The name says it all. 
<p>

</div>
</div><p>
<a class="anchor" name="dc4656551a60b38fb01d2b3513aefafc"></a><!-- doxytag: member="EncoderBase::size_hash" ref="dc4656551a60b38fb01d2b3513aefafc" args="[OpndSize_64+1]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="class_encoder_base.html#dc4656551a60b38fb01d2b3513aefafc">EncoderBase.size_hash</a>[OpndSize_64+1]<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A table used for the fast computation of hash value. 
<p>
A change must be strictly balanced with hash-related functions and data in <a class="el" href="enc__base_8h.html" title="Main encoding routines and structures.">enc_base.h</a>/.cpp. 
</div>
</div><p>
<a class="anchor" name="1f9e3fc865a588d45ac88c0f855038d4"></a><!-- doxytag: member="EncoderBase::kind_hash" ref="1f9e3fc865a588d45ac88c0f855038d4" args="[OpndKind_Mem+1]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="class_encoder_base.html#1f9e3fc865a588d45ac88c0f855038d4">EncoderBase.kind_hash</a>[OpndKind_Mem+1]<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A table used for the fast computation of hash value. 
<p>
A change must be strictly balanced with hash-related functions and data in <a class="el" href="enc__base_8h.html" title="Main encoding routines and structures.">enc_base.h</a>/.cpp. 
</div>
</div><p>
<a class="anchor" name="30f87fd2b9c33846b46575b2018694de"></a><!-- doxytag: member="EncoderBase::MAX_OPCODES" ref="30f87fd2b9c33846b46575b2018694de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="class_encoder_base.html#30f87fd2b9c33846b46575b2018694de">EncoderBase.MAX_OPCODES</a> = 32<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum number of opcodes used for a single mnemonic. 
<p>
No arithmetics behind the number, simply estimated. 
</div>
</div><p>
<a class="anchor" name="ad12d20c697e9893fbf423011ff126b3"></a><!-- doxytag: member="EncoderBase::opcodesHashMap" ref="ad12d20c697e9893fbf423011ff126b3" args="[Mnemonic_Count][HASH_MAX]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="class_encoder_base.html#ad12d20c697e9893fbf423011ff126b3">EncoderBase.opcodesHashMap</a>[Mnemonic_Count][<a class="el" href="class_encoder_base.html#88bf5c19de4dc735983419f06a774546">HASH_MAX</a>]<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mapping between operands hash code and operands. 
<p>

</div>
</div><p>
<a class="anchor" name="8bd8e1ac4474b54de8443dadcd6d9b03"></a><!-- doxytag: member="EncoderBase::mnemonics" ref="8bd8e1ac4474b54de8443dadcd6d9b03" args="[Mnemonic_Count]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_encoder_base_1_1_mnemonic_desc.html">MnemonicDesc</a> <a class="el" href="class_encoder_base.html#8bd8e1ac4474b54de8443dadcd6d9b03">EncoderBase.mnemonics</a>[Mnemonic_Count]<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array of mnemonics. 
<p>

</div>
</div><p>
<a class="anchor" name="bb52365702866b57937a385a9ae9a489"></a><!-- doxytag: member="EncoderBase::opcodes" ref="bb52365702866b57937a385a9ae9a489" args="[Mnemonic_Count][MAX_OPCODES]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_encoder_base_1_1_opcode_desc.html">OpcodeDesc</a> <a class="el" href="class_encoder_base.html#bb52365702866b57937a385a9ae9a489">EncoderBase.opcodes</a>[Mnemonic_Count][<a class="el" href="class_encoder_base.html#30f87fd2b9c33846b46575b2018694de">MAX_OPCODES</a>]<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array of available opcodes. 
<p>

</div>
</div><p>
<a class="anchor" name="2c17413b4ed86b32bd983293557cf898"></a><!-- doxytag: member="EncoderBase::dummy" ref="2c17413b4ed86b32bd983293557cf898" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_encoder_base.html#2c17413b4ed86b32bd983293557cf898">EncoderBase.dummy</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dummy variable, for automatic invocation of <a class="el" href="class_encoder_base.html#8c9af1bd6d109ee24cec63d7dcc3ea03">buildTable()</a> at startup. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="enc__base_8h.html">enc_base.h</a></ul>
<hr size="1">
<address style="text-align: center;">
  <small>
    <p>Genereated on Tue Mar 11 19:25:42 2008 by Doxygen.</p>
    <p>(c) Copyright 2005, 2008 The Apache Software Foundation or its licensors, as applicable. </p>
  </small>
</address>
</body>
</html>
