<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>VM-JIT: jit_import.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>jit_import.h File Reference</h1>
<p>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &quot;<a class="el" href="jit__export_8h-source.html">jit_export.h</a>&quot;</code><br>
<code>#include &quot;open/types.h&quot;</code><br>
<code>#include &quot;open/vm.h&quot;</code><br>
<code>#include &quot;<a class="el" href="jit__import__rt_8h-source.html">jit_import_rt.h</a>&quot;</code><br>
<code>#include &quot;vm_core_types.h&quot;</code><br>

<p>
<a href="jit__import_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Method-related functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#a77fd4fd328329985b8071e31acc535f">CODE_BLOCK_HEAT_COLD</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The following values should be used as the "heat" argument for calls like <code>malloc_fixed_code_for_jit()</code>.  <a href="#a77fd4fd328329985b8071e31acc535f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#6ea5607f3bb3fb9274bf0274789fd29b">CODE_BLOCK_HEAT_DEFAULT</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#80586882d34f45bd3fa2a477ad91f195">CODE_BLOCK_HEAT_MAX</a>&nbsp;&nbsp;&nbsp;20</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#3729e2c296cb57388588f2baf3f1faf0">METHOD_JIT_ITER_END</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#e3a6ce1d60e9f1b632fb5daaa8d0db45">Code_Allocation_ActionEnum</a> { <a class="el" href="jit__import_8h.html#e3a6ce1d60e9f1b632fb5daaa8d0db4570e988c6d7379f3b019c0a110ad01f6f">CAA_Simulate</a>, 
<a class="el" href="jit__import_8h.html#e3a6ce1d60e9f1b632fb5daaa8d0db451e7dba71a54f3ea77059c7a626a0cf92">CAA_Allocate</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="jit__import_8h.html#53a0a624f74e9596c940e9feb26c4562" title="This function allows allocation of multiple chunks of code with different heat values...">method_allocate_code_block</a> </dd></dl>
 <a href="jit__import_8h.html#e3a6ce1d60e9f1b632fb5daaa8d0db45">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#43c0064f6bb160fea02d050b199767cc">CodeBlockHeat</a> { <a class="el" href="jit__import_8h.html#43c0064f6bb160fea02d050b199767ccfcbce6ec6c284d08c64970e712e385df">CodeBlockHeatMin</a>, 
<a class="el" href="jit__import_8h.html#43c0064f6bb160fea02d050b199767cc1cf40c8ff307792e821234ab32acd099">CodeBlockHeatDefault</a>, 
<a class="el" href="jit__import_8h.html#43c0064f6bb160fea02d050b199767cc9d8b1de6ed9a9421895399209b60600b">CodeBlockHeatMax</a>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef enum <a class="el" href="jit__import_8h.html#e3a6ce1d60e9f1b632fb5daaa8d0db45">Code_Allocation_ActionEnum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#27a1bb1e763efda10c5a374dac41ff6f">Code_Allocation_Action</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="jit__import_8h.html#53a0a624f74e9596c940e9feb26c4562" title="This function allows allocation of multiple chunks of code with different heat values...">method_allocate_code_block</a> </dd></dl>
 <a href="#27a1bb1e763efda10c5a374dac41ff6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT const Byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#20a59f30c70f240c7c324b160d37e582">method_get_byte_code_addr</a> (Method_Handle method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to the buffer containing the bytecodes for this method.  <a href="#20a59f30c70f240c7c324b160d37e582"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#752ca88782264996dffe60a9b263b379">method_get_byte_code_size</a> (Method_Handle method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size if the buffer returned by <a class="el" href="jit__import_8h.html#20a59f30c70f240c7c324b160d37e582" title="Get a pointer to the buffer containing the bytecodes for this method.">method_get_byte_code_addr()</a>.  <a href="#752ca88782264996dffe60a9b263b379"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#aa7d7c0c7d3a364d4002aa0d64590d14">method_get_max_stack</a> (Method_Handle method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum depth of the evaluation stack in this method.  <a href="#aa7d7c0c7d3a364d4002aa0d64590d14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#e72a9461c286ebc8a194e1a14091d15a">method_get_indirect_address</a> (Method_Handle method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The address where the code pointer for a given method is. </dd></dl>
 <a href="#e72a9461c286ebc8a194e1a14091d15a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#20db11284ce1dd20285ee53949e19f49">method_get_offset</a> (Method_Handle method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The offset in bytes from the start of the vtable to the entry for a given method. </dd></dl>
 <a href="#20db11284ce1dd20285ee53949e19f49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#f1769aabf8bda6e55b9bcf394f0fd538">method_allocate_data_block</a> (Method_Handle method, JIT_Handle j, size_t size, size_t alignment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate the "read-write" data block for this method.  <a href="#f1769aabf8bda6e55b9bcf394f0fd538"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#00c4f07b958ad8a3f473df2bb42a0a44">method_allocate_jit_data_block</a> (Method_Handle method, JIT_Handle j, size_t size, size_t alignment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocated a "read-only" data block.  <a href="#00c4f07b958ad8a3f473df2bb42a0a44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#53a0a624f74e9596c940e9feb26c4562">method_allocate_code_block</a> (Method_Handle m, JIT_Handle j, size_t size, size_t alignment, <a class="el" href="jit__import_8h.html#43c0064f6bb160fea02d050b199767cc">CodeBlockHeat</a> heat, int id, <a class="el" href="jit__import_8h.html#27a1bb1e763efda10c5a374dac41ff6f">Code_Allocation_Action</a> action)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function allows allocation of multiple chunks of code with different heat values.  <a href="#53a0a624f74e9596c940e9feb26c4562"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#6f3b0851ecf3c9d5b259a29f12cf7aae">method_set_relocatable</a> (Method_Handle m, JIT_Handle j, NativeCodePtr code_address, Boolean is_relocatable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#9dbebe9d9e18eb32cc37b67be04300cc">method_allocate_info_block</a> (Method_Handle method, JIT_Handle j, size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an info block for this method.  <a href="#9dbebe9d9e18eb32cc37b67be04300cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#eed63d9e877a754daa97beb6d14b4ad9">method_get_code_block_addr_jit</a> (Method_Handle method, JIT_Handle j)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the memory block allocated earlier by <a class="el" href="jit__import_8h.html#53a0a624f74e9596c940e9feb26c4562" title="This function allows allocation of multiple chunks of code with different heat values...">method_allocate_code_block()</a>.  <a href="#eed63d9e877a754daa97beb6d14b4ad9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#8607a50da71133d793f2aba0573b8596">method_get_code_block_size_jit</a> (Method_Handle method, JIT_Handle j)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the size of the memory block allocated earlier by <a class="el" href="jit__import_8h.html#53a0a624f74e9596c940e9feb26c4562" title="This function allows allocation of multiple chunks of code with different heat values...">method_allocate_code_block()</a>.  <a href="#8607a50da71133d793f2aba0573b8596"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#774c7fc9e3a148552806eecad74fb438">method_get_code_block_addr_jit_new</a> (Method_Handle method, JIT_Handle j, int id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the memory block allocated earlier by <a class="el" href="jit__import_8h.html#53a0a624f74e9596c940e9feb26c4562" title="This function allows allocation of multiple chunks of code with different heat values...">method_allocate_code_block()</a>.  <a href="#774c7fc9e3a148552806eecad74fb438"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#600e8aa138898644a3204e9d07968da6">method_get_code_block_size_jit_new</a> (Method_Handle method, JIT_Handle j, int id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the size of the memory block allocated earlier by <a class="el" href="jit__import_8h.html#53a0a624f74e9596c940e9feb26c4562" title="This function allows allocation of multiple chunks of code with different heat values...">method_allocate_code_block()</a>.  <a href="#600e8aa138898644a3204e9d07968da6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#4479e4c12d82ec466b5aa8685b861991">method_get_info_block_jit</a> (Method_Handle method, JIT_Handle j)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the memory block allocated earlier by <a class="el" href="jit__import_8h.html#9dbebe9d9e18eb32cc37b67be04300cc" title="Allocate an info block for this method.">method_allocate_info_block()</a>.  <a href="#4479e4c12d82ec466b5aa8685b861991"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#6d32da39260daddcadcb490d1699a6f2">method_get_info_block_size_jit</a> (Method_Handle method, JIT_Handle j)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the size of the memory block allocated earlier by <a class="el" href="jit__import_8h.html#9dbebe9d9e18eb32cc37b67be04300cc" title="Allocate an info block for this method.">method_allocate_info_block()</a>.  <a href="#6d32da39260daddcadcb490d1699a6f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="jit__import_8h.html#dc8eb362645670871f2628cafab93dfc">Method_Iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#725923c31380cc0c02f107991037cb74">method_get_first_method_jit</a> (JIT_Handle j)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Here are the obvious three functions to iterate over all methods compiled by a given JIT.  <a href="#725923c31380cc0c02f107991037cb74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="jit__import_8h.html#dc8eb362645670871f2628cafab93dfc">Method_Iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#0782c4da19fd6eb1712ea1fafa2e1304">method_get_next_method_jit</a> (<a class="el" href="jit__import_8h.html#dc8eb362645670871f2628cafab93dfc">Method_Iterator</a> mi)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Method_Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#c42f7f05e237bacd66571481ad4369b1">method_get_method_jit</a> (<a class="el" href="jit__import_8h.html#dc8eb362645670871f2628cafab93dfc">Method_Iterator</a> mi)</td></tr>

<tr><td colspan="2"><br><h2>Experimental functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#6734adc5b6fb3a4ce29155c62cab4239">CallingConvention</a> { <br>
&nbsp;&nbsp;<a class="el" href="jit__import_8h.html#6734adc5b6fb3a4ce29155c62cab42399a000c5904635df097708507c788adf5">CC_Vm</a>, 
<a class="el" href="jit__import_8h.html#6734adc5b6fb3a4ce29155c62cab42396ab9893cbc07b501979b38d26f06906b">CC_Jrockit</a>, 
<a class="el" href="jit__import_8h.html#6734adc5b6fb3a4ce29155c62cab4239d90b5b8053f7d2863e787add66457ad5">CC_Rotor</a>, 
<a class="el" href="jit__import_8h.html#6734adc5b6fb3a4ce29155c62cab42390e9d472f07e812a26032ba0dcd1cd4dc">CC_Stdcall</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="jit__import_8h.html#6734adc5b6fb3a4ce29155c62cab4239d45765c8f9eee8362f48c10efb8b1074">CC_Cdecl</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#3838b9a36cc0176280e9069dd3cc0f64">jit_may_inline_object_synchronization</a> (unsigned *thread_id_register, unsigned *sync_header_offset, unsigned *sync_header_width, unsigned *lock_owner_offset, unsigned *lock_owner_width, Boolean *jit_clears_ccv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">These functions are currently not part of the official interface, although they may be promoted in some form in the future.  <a href="#3838b9a36cc0176280e9069dd3cc0f64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="jit__import_8h.html#6734adc5b6fb3a4ce29155c62cab4239">CallingConvention</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#c3efb6e88f2b9e398c7136bb8b55f254">vm_managed_calling_convention</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#dc8eb362645670871f2628cafab93dfc">Method_Iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">These are the functions that a JIT built as a DLL may call.  <a href="#dc8eb362645670871f2628cafab93dfc"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Direct call-related functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#9fa39e20a5f8e2166cadc2c7cfa1881e">vm_register_jit_extended_class_callback</a> (JIT_Handle jit, Class_Handle clss, void *callback_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">These functions allow a JIT to be notified whenever a VM data structure changes that would require code patching or recompilation.  <a href="#9fa39e20a5f8e2166cadc2c7cfa1881e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#2250942e26c1c5e2cc97e4abc1f5d924">vm_register_jit_overridden_method_callback</a> (JIT_Handle jit, Method_Handle method, void *callback_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by a JIT in order to be notified whenever the given method is overridden by a newly loaded class.  <a href="#2250942e26c1c5e2cc97e4abc1f5d924"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#2fae6e65e8ccebd3234259646fc08fcb">vm_register_jit_recompiled_method_callback</a> (JIT_Handle jit, Method_Handle method, void *callback_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by a JIT in order to be notified whenever the vtable entries for the given method are changed.  <a href="#2fae6e65e8ccebd3234259646fc08fcb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#18fe543e82826312a8eefb8e5e3c9b5f">vm_patch_code_block</a> (Byte *code_block, Byte *new_code, size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by a JIT to have the VM replace a section of executable code in a thread-safe fashion.  <a href="#18fe543e82826312a8eefb8e5e3c9b5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#dbc874e527427aed60d6c77b76051bad">vm_recompile_method</a> (JIT_Handle jit, Method_Handle method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by a JIT to have the VM recompile a method using the specified JIT.  <a href="#dbc874e527427aed60d6c77b76051bad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT JIT_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#0a56b7a7b40f7e9fc7d67cb19f29974f">vm_compile_method</a> (JIT_Handle jit, Method_Handle method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by a JIT to have VM synchronously (in the same thread) compile a method It is a requirement that JIT calls this routine only during compilation of other method, not during run-time.  <a href="#0a56b7a7b40f7e9fc7d67cb19f29974f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Exception-related compile-time functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#38afea4c1f21d7097b4c1afe4ecb031f">method_get_num_handlers</a> (Method_Handle method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of exception handlers defined for this method in the bytecodes. </dd></dl>
 <a href="#38afea4c1f21d7097b4c1afe4ecb031f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#e6753f73d2887788c716fdfced93fe67">method_get_handler_info_full</a> (Method_Handle method, unsigned handler_id, unsigned *begin_offset, unsigned *end_offset, unsigned *handler_offset, unsigned *handler_len, unsigned *filter_offset, unsigned *handler_class_index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deprecated.  <a href="#e6753f73d2887788c716fdfced93fe67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#921859bd2654b1cd36e49ec1725f5ff2">method_get_handler_info</a> (Method_Handle method, unsigned handler_id, unsigned *begin_offset, unsigned *end_offset, unsigned *handler_offset, unsigned *handler_class_index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a simpler version of <a class="el" href="jit__import_8h.html#e6753f73d2887788c716fdfced93fe67" title="Deprecated.">method_get_handler_info_full()</a> that works only for JVM.  <a href="#921859bd2654b1cd36e49ec1725f5ff2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#781ab197ca9d0c220adc706d33a8e3dd">method_handler_has_finally</a> (Method_Handle method, unsigned handler_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deprecated.  <a href="#781ab197ca9d0c220adc706d33a8e3dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#4d7deb8b39f1de662a68b696eeb33e7a">method_handler_has_filter</a> (Method_Handle method, unsigned handler_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deprecated.  <a href="#4d7deb8b39f1de662a68b696eeb33e7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#fc6149a644b042f7cce80727a7cc1ca9">method_handler_has_fault</a> (Method_Handle method, unsigned handler_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deprecated.  <a href="#fc6149a644b042f7cce80727a7cc1ca9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#804f5a02315492191c6b333da084b90a">method_set_num_target_handlers</a> (Method_Handle method, JIT_Handle j, unsigned num_handlers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the number of exception handlers in the code generated by the JIT <code>j</code> for a given method.  <a href="#804f5a02315492191c6b333da084b90a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#7893f0babd69fb35613368918cf54a6e">method_set_target_handler_info</a> (Method_Handle method, JIT_Handle j, unsigned eh_number, void *start_ip, void *end_ip, void *handler_ip, Class_Handle catch_cl, Boolean exc_obj_is_dead)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the information about an exception handler in the code generated by the JIT.  <a href="#7893f0babd69fb35613368918cf54a6e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Resolution-related functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Class_Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#6dd3608689fd9ecc61ce859d0067b13d">vm_resolve_class</a> (<a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a> h, Class_Handle ch, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolve a class.  <a href="#6dd3608689fd9ecc61ce859d0067b13d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Class_Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#0fe513f848bf94d4e83000ad4449ae78">vm_resolve_class_new</a> (<a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a> h, Class_Handle c, unsigned index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolve a class and provide error checking if the class cannot have an instance, i.e.  <a href="#0fe513f848bf94d4e83000ad4449ae78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Field_Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#ce1c9fbb82c7f43f2573638b55330b56">resolve_nonstatic_field</a> (<a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a> h, Class_Handle ch, unsigned idx, unsigned putfield)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolve a reference to a non-static field.  <a href="#ce1c9fbb82c7f43f2573638b55330b56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Field_Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#736dad3de9362f4dc08475151a21112c">resolve_static_field</a> (<a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a> h, Class_Handle ch, unsigned idx, unsigned putfield)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolve constant pool reference to a static field.  <a href="#736dad3de9362f4dc08475151a21112c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Method_Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#26d4901c2bc23ce3476a273ca11c738f">resolve_method</a> (<a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a> h, Class_Handle ch, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolve a method.  <a href="#26d4901c2bc23ce3476a273ca11c738f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Method_Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#4703da3fd552d5a565e4aab3e921f4a3">resolve_virtual_method</a> (<a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a> h, Class_Handle c, unsigned index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolve a method.  <a href="#4703da3fd552d5a565e4aab3e921f4a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Method_Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#4894905345a05cd733a8c78ccc5f0547">resolve_static_method</a> (<a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a> h, Class_Handle c, unsigned index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolve a method.  <a href="#4894905345a05cd733a8c78ccc5f0547"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Method_Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#2abe0f59944e9532cb7838d6465bbc2d">resolve_interface_method</a> (<a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a> h, Class_Handle c, unsigned index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolve a method.  <a href="#2abe0f59944e9532cb7838d6465bbc2d"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#4e52e79b695a29ce3671d20e9cf062da">class_get_const_string</a> (Class_Handle ch, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>A UTF8 representation of a string declared in a class. </dd></dl>
 <a href="#4e52e79b695a29ce3671d20e9cf062da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#b94a93d4861167bf67724a4f34b97dce">class_get_const_string_intern_addr</a> (Class_Handle ch, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The address where the interned version of the string is stored. </dd></dl>
 <a href="#b94a93d4861167bf67724a4f34b97dce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT VM_Data_Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#b512a8eaad7baa234fd931449c61ee7c">class_get_const_type</a> (Class_Handle ch, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The type of a compile-time constant. </dd></dl>
 <a href="#b512a8eaad7baa234fd931449c61ee7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#b1cdba2dac18b0c89a6d1e25b20adba6">class_get_cp_entry_signature</a> (Class_Handle src_class, unsigned short cp_index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The signature for field or (interface) method in constant pool entry. </dd></dl>
 <a href="#b1cdba2dac18b0c89a6d1e25b20adba6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT VM_Data_Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#0fdbcbf34b368142354cbb5736218b0f">class_get_cp_field_type</a> (Class_Handle src_class, unsigned short cp_index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The data type for field in constant pool entry. </dd></dl>
 <a href="#0fdbcbf34b368142354cbb5736218b0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#52a266cfc13ee2ffca6856d9116edcf8">class_get_const_addr</a> (Class_Handle ch, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the location where the constant is stored. </dd></dl>
 <a href="#52a266cfc13ee2ffca6856d9116edcf8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#25ad03471a96553a0979300f0edf0881">method_get_native_func_addr</a> (Method_Handle method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks for a method in native libraries of a class loader.  <a href="#25ad03471a96553a0979300f0edf0881"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT JIT_Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="jit__import_8h.html#07f25e7e353ea19b2c0a7a2730414abf">method_get_JIT_id</a> (<a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a> h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The JIT handle for a the current compilation. </dd></dl>
 <a href="#07f25e7e353ea19b2c0a7a2730414abf"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a77fd4fd328329985b8071e31acc535f"></a><!-- doxytag: member="jit_import.h::CODE_BLOCK_HEAT_COLD" ref="a77fd4fd328329985b8071e31acc535f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CODE_BLOCK_HEAT_COLD&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The following values should be used as the "heat" argument for calls like <code>malloc_fixed_code_for_jit()</code>. 
<p>
FIXME merge with CodeBlockHeat enumeration 
</div>
</div><p>
<a class="anchor" name="6ea5607f3bb3fb9274bf0274789fd29b"></a><!-- doxytag: member="jit_import.h::CODE_BLOCK_HEAT_DEFAULT" ref="6ea5607f3bb3fb9274bf0274789fd29b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CODE_BLOCK_HEAT_DEFAULT&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="80586882d34f45bd3fa2a477ad91f195"></a><!-- doxytag: member="jit_import.h::CODE_BLOCK_HEAT_MAX" ref="80586882d34f45bd3fa2a477ad91f195" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CODE_BLOCK_HEAT_MAX&nbsp;&nbsp;&nbsp;20          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3729e2c296cb57388588f2baf3f1faf0"></a><!-- doxytag: member="jit_import.h::METHOD_JIT_ITER_END" ref="3729e2c296cb57388588f2baf3f1faf0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define METHOD_JIT_ITER_END&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="27a1bb1e763efda10c5a374dac41ff6f"></a><!-- doxytag: member="jit_import.h::Code_Allocation_Action" ref="27a1bb1e763efda10c5a374dac41ff6f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="jit__import_8h.html#e3a6ce1d60e9f1b632fb5daaa8d0db45">Code_Allocation_ActionEnum</a> <a class="el" href="jit__import_8h.html#27a1bb1e763efda10c5a374dac41ff6f">Code_Allocation_Action</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="jit__import_8h.html#53a0a624f74e9596c940e9feb26c4562" title="This function allows allocation of multiple chunks of code with different heat values...">method_allocate_code_block</a> </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="dc8eb362645670871f2628cafab93dfc"></a><!-- doxytag: member="jit_import.h::Method_Iterator" ref="dc8eb362645670871f2628cafab93dfc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="jit__import_8h.html#dc8eb362645670871f2628cafab93dfc">Method_Iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
These are the functions that a JIT built as a DLL may call. 
<p>

</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="6734adc5b6fb3a4ce29155c62cab4239"></a><!-- doxytag: member="jit_import.h::CallingConvention" ref="6734adc5b6fb3a4ce29155c62cab4239" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="jit__import_8h.html#6734adc5b6fb3a4ce29155c62cab4239">CallingConvention</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="6734adc5b6fb3a4ce29155c62cab42399a000c5904635df097708507c788adf5"></a><!-- doxytag: member="CC_Vm" ref="6734adc5b6fb3a4ce29155c62cab42399a000c5904635df097708507c788adf5" args="" -->CC_Vm</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="6734adc5b6fb3a4ce29155c62cab42396ab9893cbc07b501979b38d26f06906b"></a><!-- doxytag: member="CC_Jrockit" ref="6734adc5b6fb3a4ce29155c62cab42396ab9893cbc07b501979b38d26f06906b" args="" -->CC_Jrockit</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="6734adc5b6fb3a4ce29155c62cab4239d90b5b8053f7d2863e787add66457ad5"></a><!-- doxytag: member="CC_Rotor" ref="6734adc5b6fb3a4ce29155c62cab4239d90b5b8053f7d2863e787add66457ad5" args="" -->CC_Rotor</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="6734adc5b6fb3a4ce29155c62cab42390e9d472f07e812a26032ba0dcd1cd4dc"></a><!-- doxytag: member="CC_Stdcall" ref="6734adc5b6fb3a4ce29155c62cab42390e9d472f07e812a26032ba0dcd1cd4dc" args="" -->CC_Stdcall</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="6734adc5b6fb3a4ce29155c62cab4239d45765c8f9eee8362f48c10efb8b1074"></a><!-- doxytag: member="CC_Cdecl" ref="6734adc5b6fb3a4ce29155c62cab4239d45765c8f9eee8362f48c10efb8b1074" args="" -->CC_Cdecl</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="e3a6ce1d60e9f1b632fb5daaa8d0db45"></a><!-- doxytag: member="jit_import.h::Code_Allocation_ActionEnum" ref="e3a6ce1d60e9f1b632fb5daaa8d0db45" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="jit__import_8h.html#e3a6ce1d60e9f1b632fb5daaa8d0db45">Code_Allocation_ActionEnum</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="jit__import_8h.html#53a0a624f74e9596c940e9feb26c4562" title="This function allows allocation of multiple chunks of code with different heat values...">method_allocate_code_block</a> </dd></dl>

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="e3a6ce1d60e9f1b632fb5daaa8d0db4570e988c6d7379f3b019c0a110ad01f6f"></a><!-- doxytag: member="CAA_Simulate" ref="e3a6ce1d60e9f1b632fb5daaa8d0db4570e988c6d7379f3b019c0a110ad01f6f" args="" -->CAA_Simulate</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="e3a6ce1d60e9f1b632fb5daaa8d0db451e7dba71a54f3ea77059c7a626a0cf92"></a><!-- doxytag: member="CAA_Allocate" ref="e3a6ce1d60e9f1b632fb5daaa8d0db451e7dba71a54f3ea77059c7a626a0cf92" args="" -->CAA_Allocate</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="43c0064f6bb160fea02d050b199767cc"></a><!-- doxytag: member="jit_import.h::CodeBlockHeat" ref="43c0064f6bb160fea02d050b199767cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="jit__import_8h.html#43c0064f6bb160fea02d050b199767cc">CodeBlockHeat</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="43c0064f6bb160fea02d050b199767ccfcbce6ec6c284d08c64970e712e385df"></a><!-- doxytag: member="CodeBlockHeatMin" ref="43c0064f6bb160fea02d050b199767ccfcbce6ec6c284d08c64970e712e385df" args="" -->CodeBlockHeatMin</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="43c0064f6bb160fea02d050b199767cc1cf40c8ff307792e821234ab32acd099"></a><!-- doxytag: member="CodeBlockHeatDefault" ref="43c0064f6bb160fea02d050b199767cc1cf40c8ff307792e821234ab32acd099" args="" -->CodeBlockHeatDefault</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="43c0064f6bb160fea02d050b199767cc9d8b1de6ed9a9421895399209b60600b"></a><!-- doxytag: member="CodeBlockHeatMax" ref="43c0064f6bb160fea02d050b199767cc9d8b1de6ed9a9421895399209b60600b" args="" -->CodeBlockHeatMax</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="52a266cfc13ee2ffca6856d9116edcf8"></a><!-- doxytag: member="jit_import.h::class_get_const_addr" ref="52a266cfc13ee2ffca6856d9116edcf8" args="(Class_Handle ch, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT const void* class_get_const_addr           </td>
          <td>(</td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the location where the constant is stored. </dd></dl>

<p>
The <code>idx</code> parameter is interpreted as a constant pool index for JVM. This function shouldn't be called for constant strings. Instead, either:<br>
 <ul>
<li>
The jitted code should get the string object at runtime by calling <code>VM_RT_LDC_STRING</code>, or </li>
<li>
Use <a class="el" href="jit__import_8h.html#b94a93d4861167bf67724a4f34b97dce" title="The address where the interned version of the string is stored.">class_get_const_string_intern_addr()</a>. </li>
</ul>

</div>
</div><p>
<a class="anchor" name="4e52e79b695a29ce3671d20e9cf062da"></a><!-- doxytag: member="jit_import.h::class_get_const_string" ref="4e52e79b695a29ce3671d20e9cf062da" args="(Class_Handle ch, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT const char* class_get_const_string           </td>
          <td>(</td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A UTF8 representation of a string declared in a class. </dd></dl>

<p>
The <code>idx</code> parameter is interpreted as a constant pool index for JVM. <code>class_get_const_string</code> is generally only for JIT internal use, e.g. printing a string pool constant in a bytecode disassembler. The resulting const char* should of course not be inserted into the jitted code. 
</div>
</div><p>
<a class="anchor" name="b94a93d4861167bf67724a4f34b97dce"></a><!-- doxytag: member="jit_import.h::class_get_const_string_intern_addr" ref="b94a93d4861167bf67724a4f34b97dce" args="(Class_Handle ch, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void* class_get_const_string_intern_addr           </td>
          <td>(</td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The address where the interned version of the string is stored. </dd></dl>

<p>
Calling <code>class_get_const_string_intern_addr</code> has a side-effect of interning the string, so that the JIT can load a reference to the interned string without checking if it is null. 
</div>
</div><p>
<a class="anchor" name="b512a8eaad7baa234fd931449c61ee7c"></a><!-- doxytag: member="jit_import.h::class_get_const_type" ref="b512a8eaad7baa234fd931449c61ee7c" args="(Class_Handle ch, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT VM_Data_Type class_get_const_type           </td>
          <td>(</td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The type of a compile-time constant. </dd></dl>

<p>
The <code>idx</code> parameter is interpreted as a constant pool index for JVM. 
</div>
</div><p>
<a class="anchor" name="b1cdba2dac18b0c89a6d1e25b20adba6"></a><!-- doxytag: member="jit_import.h::class_get_cp_entry_signature" ref="b1cdba2dac18b0c89a6d1e25b20adba6" args="(Class_Handle src_class, unsigned short cp_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT const char* class_get_cp_entry_signature           </td>
          <td>(</td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>src_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>cp_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The signature for field or (interface) method in constant pool entry. </dd></dl>

<p>
The <code>cp_index</code> parameter is interpreted as a constant pool index for JVM. 
</div>
</div><p>
<a class="anchor" name="0fdbcbf34b368142354cbb5736218b0f"></a><!-- doxytag: member="jit_import.h::class_get_cp_field_type" ref="0fdbcbf34b368142354cbb5736218b0f" args="(Class_Handle src_class, unsigned short cp_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT VM_Data_Type class_get_cp_field_type           </td>
          <td>(</td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>src_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>cp_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The data type for field in constant pool entry. </dd></dl>

<p>
The <code>cp_index</code> parameter is interpreted as a constant pool index for JVM. 
</div>
</div><p>
<a class="anchor" name="3838b9a36cc0176280e9069dd3cc0f64"></a><!-- doxytag: member="jit_import.h::jit_may_inline_object_synchronization" ref="3838b9a36cc0176280e9069dd3cc0f64" args="(unsigned *thread_id_register, unsigned *sync_header_offset, unsigned *sync_header_width, unsigned *lock_owner_offset, unsigned *lock_owner_width, Boolean *jit_clears_ccv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean jit_may_inline_object_synchronization           </td>
          <td>(</td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>thread_id_register</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>sync_header_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>sync_header_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>lock_owner_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>lock_owner_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean *&nbsp;</td>
          <td class="paramname"> <em>jit_clears_ccv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
These functions are currently not part of the official interface, although they may be promoted in some form in the future. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the VM's functionality for monitorenter and monitorexit may be inlined by the JIT; otherwise, <code>FALSE</code>.</dd></dl>
If <code>TRUE</code> is returned, then the output arguments will be filled in with the synchronization parameters.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread_id_register</em>&nbsp;</td><td>- the register number that holds the thread ID which is used to identify the locking thread </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sync_header_offset</em>&nbsp;</td><td>- the offset in bytes of the synchronization header from the start of the object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sync_header_width</em>&nbsp;</td><td>- the width in bytes of the synchronization header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lock_owner_offset</em>&nbsp;</td><td>- the offset in bytes of the lock owner field from the start of the object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lock_owner_width</em>&nbsp;</td><td>- the width in bytes of the lock owner field in the synchronization header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>jit_clears_ccv</em>&nbsp;</td><td>- <code>TRUE</code> if the JIT-generated code needs to clear the <code>ar.ccv</code> register, <code>FALSE</code> if the VM ensures it is already cleared</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This is useful only for <code>monitorenter/monitorexit</code>, but not <code>monitorenter_static/monitorexit_static</code>, since the JIT doesn't know how to map the <code>class_handle</code> to an object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="53a0a624f74e9596c940e9feb26c4562"></a><!-- doxytag: member="jit_import.h::method_allocate_code_block" ref="53a0a624f74e9596c940e9feb26c4562" args="(Method_Handle m, JIT_Handle j, size_t size, size_t alignment, CodeBlockHeat heat, int id, Code_Allocation_Action action)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Byte* method_allocate_code_block           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="jit__import_8h.html#43c0064f6bb160fea02d050b199767cc">CodeBlockHeat</a>&nbsp;</td>
          <td class="paramname"> <em>heat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="jit__import_8h.html#27a1bb1e763efda10c5a374dac41ff6f">Code_Allocation_Action</a>&nbsp;</td>
          <td class="paramname"> <em>action</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function allows allocation of multiple chunks of code with different heat values. 
<p>
The JIT is responsible for specifying ids that are unique within the same method. The first instruction of the chunk with <code>id=0</code> is the entry point of the method.<p>
Deprecated.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>If the <code>CAA_Allocate</code> argument is specified, memory is allocated and a pointer to it is returned. If the <code>CAA_Simulate</code> argument is specified, no memory is allocated - the same as pass parameter size = 0 - function returns only current address for allocation in pool but no memory is allocated. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f1769aabf8bda6e55b9bcf394f0fd538"></a><!-- doxytag: member="jit_import.h::method_allocate_data_block" ref="f1769aabf8bda6e55b9bcf394f0fd538" args="(Method_Handle method, JIT_Handle j, size_t size, size_t alignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Byte* method_allocate_data_block           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate the "read-write" data block for this method. 
<p>
This memory block cannot be retrieved later. The intention is to use the data block for data that may be needed during the program execution (e.g. tables for switch statements).<p>
Separation of data allocated by <a class="el" href="jit__import_8h.html#f1769aabf8bda6e55b9bcf394f0fd538" title="Allocate the "read-write" data block for this method.">method_allocate_data_block()</a> and <a class="el" href="jit__import_8h.html#9dbebe9d9e18eb32cc37b67be04300cc" title="Allocate an info block for this method.">method_allocate_info_block()</a> may help improve locality of references to data accessed during execution of compiled code and data accessed during stack uwinding.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="jit__import_8h.html#9dbebe9d9e18eb32cc37b67be04300cc" title="Allocate an info block for this method.">method_allocate_info_block</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9dbebe9d9e18eb32cc37b67be04300cc"></a><!-- doxytag: member="jit_import.h::method_allocate_info_block" ref="9dbebe9d9e18eb32cc37b67be04300cc" args="(Method_Handle method, JIT_Handle j, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Byte* method_allocate_info_block           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate an info block for this method. 
<p>
An info block can be later retrieved by the JIT. The JIT may for instance store GC maps for root set enumeration and stack unwinding in the onfo block.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="jit__import_8h.html#f1769aabf8bda6e55b9bcf394f0fd538" title="Allocate the "read-write" data block for this method.">method_allocate_data_block</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="00c4f07b958ad8a3f473df2bb42a0a44"></a><!-- doxytag: member="jit_import.h::method_allocate_jit_data_block" ref="00c4f07b958ad8a3f473df2bb42a0a44" args="(Method_Handle method, JIT_Handle j, size_t size, size_t alignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Byte* method_allocate_jit_data_block           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocated a "read-only" data block. 
<p>
(? 20030314) This function is deprecated. In all new code, use <a class="el" href="jit__import_8h.html#f1769aabf8bda6e55b9bcf394f0fd538" title="Allocate the "read-write" data block for this method.">method_allocate_data_block()</a> only. At some point, we will revisit this interface to have more control over the layout of various memory blocks allocated by the VM. 
</div>
</div><p>
<a class="anchor" name="20a59f30c70f240c7c324b160d37e582"></a><!-- doxytag: member="jit_import.h::method_get_byte_code_addr" ref="20a59f30c70f240c7c324b160d37e582" args="(Method_Handle method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT const Byte* method_get_byte_code_addr           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a pointer to the buffer containing the bytecodes for this method. 
<p>
Bytecodes are either JVML instructions or CIL instructions. 
</div>
</div><p>
<a class="anchor" name="752ca88782264996dffe60a9b263b379"></a><!-- doxytag: member="jit_import.h::method_get_byte_code_size" ref="752ca88782264996dffe60a9b263b379" args="(Method_Handle method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT size_t method_get_byte_code_size           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Size if the buffer returned by <a class="el" href="jit__import_8h.html#20a59f30c70f240c7c324b160d37e582" title="Get a pointer to the buffer containing the bytecodes for this method.">method_get_byte_code_addr()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="eed63d9e877a754daa97beb6d14b4ad9"></a><!-- doxytag: member="jit_import.h::method_get_code_block_addr_jit" ref="eed63d9e877a754daa97beb6d14b4ad9" args="(Method_Handle method, JIT_Handle j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Byte* method_get_code_block_addr_jit           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the memory block allocated earlier by <a class="el" href="jit__import_8h.html#53a0a624f74e9596c940e9feb26c4562" title="This function allows allocation of multiple chunks of code with different heat values...">method_allocate_code_block()</a>. 
<p>
A pair <code>&lt;method, jit&gt;</code> uniquely identifies a code block. 
</div>
</div><p>
<a class="anchor" name="774c7fc9e3a148552806eecad74fb438"></a><!-- doxytag: member="jit_import.h::method_get_code_block_addr_jit_new" ref="774c7fc9e3a148552806eecad74fb438" args="(Method_Handle method, JIT_Handle j, int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Byte* method_get_code_block_addr_jit_new           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the memory block allocated earlier by <a class="el" href="jit__import_8h.html#53a0a624f74e9596c940e9feb26c4562" title="This function allows allocation of multiple chunks of code with different heat values...">method_allocate_code_block()</a>. 
<p>
A triple <code>&lt;method, jit, id&gt;</code> uniquely identifies a code block. 
</div>
</div><p>
<a class="anchor" name="8607a50da71133d793f2aba0573b8596"></a><!-- doxytag: member="jit_import.h::method_get_code_block_size_jit" ref="8607a50da71133d793f2aba0573b8596" args="(Method_Handle method, JIT_Handle j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned method_get_code_block_size_jit           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the size of the memory block allocated earlier by <a class="el" href="jit__import_8h.html#53a0a624f74e9596c940e9feb26c4562" title="This function allows allocation of multiple chunks of code with different heat values...">method_allocate_code_block()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="600e8aa138898644a3204e9d07968da6"></a><!-- doxytag: member="jit_import.h::method_get_code_block_size_jit_new" ref="600e8aa138898644a3204e9d07968da6" args="(Method_Handle method, JIT_Handle j, int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned method_get_code_block_size_jit_new           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the size of the memory block allocated earlier by <a class="el" href="jit__import_8h.html#53a0a624f74e9596c940e9feb26c4562" title="This function allows allocation of multiple chunks of code with different heat values...">method_allocate_code_block()</a>. 
<p>
A triple <code>&lt;method, jit, id&gt;</code> uniquely identifies a code block. 
</div>
</div><p>
<a class="anchor" name="725923c31380cc0c02f107991037cb74"></a><!-- doxytag: member="jit_import.h::method_get_first_method_jit" ref="725923c31380cc0c02f107991037cb74" args="(JIT_Handle j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="jit__import_8h.html#dc8eb362645670871f2628cafab93dfc">Method_Iterator</a> method_get_first_method_jit           </td>
          <td>(</td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>j</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Here are the obvious three functions to iterate over all methods compiled by a given JIT. 
<p>

</div>
</div><p>
<a class="anchor" name="921859bd2654b1cd36e49ec1725f5ff2"></a><!-- doxytag: member="jit_import.h::method_get_handler_info" ref="921859bd2654b1cd36e49ec1725f5ff2" args="(Method_Handle method, unsigned handler_id, unsigned *begin_offset, unsigned *end_offset, unsigned *handler_offset, unsigned *handler_class_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void method_get_handler_info           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>handler_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>begin_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>end_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>handler_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>handler_class_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is a simpler version of <a class="el" href="jit__import_8h.html#e6753f73d2887788c716fdfced93fe67" title="Deprecated.">method_get_handler_info_full()</a> that works only for JVM. 
<p>

</div>
</div><p>
<a class="anchor" name="e6753f73d2887788c716fdfced93fe67"></a><!-- doxytag: member="jit_import.h::method_get_handler_info_full" ref="e6753f73d2887788c716fdfced93fe67" args="(Method_Handle method, unsigned handler_id, unsigned *begin_offset, unsigned *end_offset, unsigned *handler_offset, unsigned *handler_len, unsigned *filter_offset, unsigned *handler_class_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void method_get_handler_info_full           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>handler_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>begin_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>end_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>handler_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>handler_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>filter_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>handler_class_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deprecated. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="jit__import_8h.html#921859bd2654b1cd36e49ec1725f5ff2" title="This is a simpler version of method_get_handler_info_full() that works only for JVM...">method_get_handler_info</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e72a9461c286ebc8a194e1a14091d15a"></a><!-- doxytag: member="jit_import.h::method_get_indirect_address" ref="e72a9461c286ebc8a194e1a14091d15a" args="(Method_Handle method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void* method_get_indirect_address           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The address where the code pointer for a given method is. </dd></dl>

<p>
A simple JIT that doesn't support recompilation (see e.g. <code>vm_register_jit_recompiled_method_callback</code>) can only generate code with indirect branches through the address provided by <a class="el" href="jit__import_8h.html#e72a9461c286ebc8a194e1a14091d15a" title="The address where the code pointer for a given method is.">method_get_indirect_address()</a>. 
</div>
</div><p>
<a class="anchor" name="4479e4c12d82ec466b5aa8685b861991"></a><!-- doxytag: member="jit_import.h::method_get_info_block_jit" ref="4479e4c12d82ec466b5aa8685b861991" args="(Method_Handle method, JIT_Handle j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Byte* method_get_info_block_jit           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the memory block allocated earlier by <a class="el" href="jit__import_8h.html#9dbebe9d9e18eb32cc37b67be04300cc" title="Allocate an info block for this method.">method_allocate_info_block()</a>. 
<p>
A pair <code>&lt;method, jit&gt;</code> uniquely identifies a JIT info block. 
</div>
</div><p>
<a class="anchor" name="6d32da39260daddcadcb490d1699a6f2"></a><!-- doxytag: member="jit_import.h::method_get_info_block_size_jit" ref="6d32da39260daddcadcb490d1699a6f2" args="(Method_Handle method, JIT_Handle j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned method_get_info_block_size_jit           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the size of the memory block allocated earlier by <a class="el" href="jit__import_8h.html#9dbebe9d9e18eb32cc37b67be04300cc" title="Allocate an info block for this method.">method_allocate_info_block()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="07f25e7e353ea19b2c0a7a2730414abf"></a><!-- doxytag: member="jit_import.h::method_get_JIT_id" ref="07f25e7e353ea19b2c0a7a2730414abf" args="(Compile_Handle h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT JIT_Handle method_get_JIT_id           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>h</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The JIT handle for a the current compilation. </dd></dl>

<p>
The VM keeps track of the JIT that was invoked for and can return this value at any point during the compilation. (? 20030314) Does the <code>method_</code> prefix really make sense here? Perhaps we should rename this function? 
</div>
</div><p>
<a class="anchor" name="aa7d7c0c7d3a364d4002aa0d64590d14"></a><!-- doxytag: member="jit_import.h::method_get_max_stack" ref="aa7d7c0c7d3a364d4002aa0d64590d14" args="(Method_Handle method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned method_get_max_stack           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum depth of the evaluation stack in this method. 
<p>

</div>
</div><p>
<a class="anchor" name="c42f7f05e237bacd66571481ad4369b1"></a><!-- doxytag: member="jit_import.h::method_get_method_jit" ref="c42f7f05e237bacd66571481ad4369b1" args="(Method_Iterator mi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Method_Handle method_get_method_jit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jit__import_8h.html#dc8eb362645670871f2628cafab93dfc">Method_Iterator</a>&nbsp;</td>
          <td class="paramname"> <em>mi</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="25ad03471a96553a0979300f0edf0881"></a><!-- doxytag: member="jit_import.h::method_get_native_func_addr" ref="25ad03471a96553a0979300f0edf0881" args="(Method_Handle method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void* method_get_native_func_addr           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks for a method in native libraries of a class loader. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>method</em>&nbsp;</td><td>- a searching native-method structure </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The pointer to found a native function. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The function raises <code>UnsatisfiedLinkError</code> with a method name in an exception message, if the specified method is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0782c4da19fd6eb1712ea1fafa2e1304"></a><!-- doxytag: member="jit_import.h::method_get_next_method_jit" ref="0782c4da19fd6eb1712ea1fafa2e1304" args="(Method_Iterator mi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="jit__import_8h.html#dc8eb362645670871f2628cafab93dfc">Method_Iterator</a> method_get_next_method_jit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jit__import_8h.html#dc8eb362645670871f2628cafab93dfc">Method_Iterator</a>&nbsp;</td>
          <td class="paramname"> <em>mi</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="38afea4c1f21d7097b4c1afe4ecb031f"></a><!-- doxytag: member="jit_import.h::method_get_num_handlers" ref="38afea4c1f21d7097b4c1afe4ecb031f" args="(Method_Handle method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned method_get_num_handlers           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of exception handlers defined for this method in the bytecodes. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="20db11284ce1dd20285ee53949e19f49"></a><!-- doxytag: member="jit_import.h::method_get_offset" ref="20db11284ce1dd20285ee53949e19f49" args="(Method_Handle method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned method_get_offset           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The offset in bytes from the start of the vtable to the entry for a given method. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="fc6149a644b042f7cce80727a7cc1ca9"></a><!-- doxytag: member="jit_import.h::method_handler_has_fault" ref="fc6149a644b042f7cce80727a7cc1ca9" args="(Method_Handle method, unsigned handler_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_handler_has_fault           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>handler_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deprecated. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>For Java methods, it always returns <code>FALSE</code> since JVM handlers do not have a fault clause. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4d7deb8b39f1de662a68b696eeb33e7a"></a><!-- doxytag: member="jit_import.h::method_handler_has_filter" ref="4d7deb8b39f1de662a68b696eeb33e7a" args="(Method_Handle method, unsigned handler_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_handler_has_filter           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>handler_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deprecated. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>For Java methods, it always returns <code>FALSE</code> since JVM handlers do not have a filters. </dd></dl>

</div>
</div><p>
<a class="anchor" name="781ab197ca9d0c220adc706d33a8e3dd"></a><!-- doxytag: member="jit_import.h::method_handler_has_finally" ref="781ab197ca9d0c220adc706d33a8e3dd" args="(Method_Handle method, unsigned handler_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_handler_has_finally           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>handler_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deprecated. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>For Java methods, it always returns <code>FALSE</code> since JVM handlers do not have a finally clause. </dd></dl>

</div>
</div><p>
<a class="anchor" name="804f5a02315492191c6b333da084b90a"></a><!-- doxytag: member="jit_import.h::method_set_num_target_handlers" ref="804f5a02315492191c6b333da084b90a" args="(Method_Handle method, JIT_Handle j, unsigned num_handlers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void method_set_num_target_handlers           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_handlers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the number of exception handlers in the code generated by the JIT <code>j</code> for a given method. 
<p>
The JIT must then call <a class="el" href="jit__import_8h.html#7893f0babd69fb35613368918cf54a6e" title="Set the information about an exception handler in the code generated by the JIT.">method_set_target_handler_info()</a> for each of the num_handlers exception handlers. 
</div>
</div><p>
<a class="anchor" name="6f3b0851ecf3c9d5b259a29f12cf7aae"></a><!-- doxytag: member="jit_import.h::method_set_relocatable" ref="6f3b0851ecf3c9d5b259a29f12cf7aae" args="(Method_Handle m, JIT_Handle j, NativeCodePtr code_address, Boolean is_relocatable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void method_set_relocatable           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NativeCodePtr&nbsp;</td>
          <td class="paramname"> <em>code_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean&nbsp;</td>
          <td class="paramname"> <em>is_relocatable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7893f0babd69fb35613368918cf54a6e"></a><!-- doxytag: member="jit_import.h::method_set_target_handler_info" ref="7893f0babd69fb35613368918cf54a6e" args="(Method_Handle method, JIT_Handle j, unsigned eh_number, void *start_ip, void *end_ip, void *handler_ip, Class_Handle catch_cl, Boolean exc_obj_is_dead)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void method_set_target_handler_info           </td>
          <td>(</td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>eh_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>start_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>end_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handler_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>catch_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean&nbsp;</td>
          <td class="paramname"> <em>exc_obj_is_dead</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the information about an exception handler in the code generated by the JIT. 
<p>

</div>
</div><p>
<a class="anchor" name="2abe0f59944e9532cb7838d6465bbc2d"></a><!-- doxytag: member="jit_import.h::resolve_interface_method" ref="2abe0f59944e9532cb7838d6465bbc2d" args="(Compile_Handle h, Class_Handle c, unsigned index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Method_Handle resolve_interface_method           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resolve a method. 
<p>
Same as <a class="el" href="jit__import_8h.html#26d4901c2bc23ce3476a273ca11c738f" title="Resolve a method.">resolve_method()</a> but the VM checks that the method is declared in an interface type. The <code>idx</code> parameter is interpreted as a constant pool index for JVM. 
</div>
</div><p>
<a class="anchor" name="26d4901c2bc23ce3476a273ca11c738f"></a><!-- doxytag: member="jit_import.h::resolve_method" ref="26d4901c2bc23ce3476a273ca11c738f" args="(Compile_Handle h, Class_Handle ch, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Method_Handle resolve_method           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resolve a method. 
<p>
The <code>idx</code> parameter is interpreted as a constant pool index for JVM. 
</div>
</div><p>
<a class="anchor" name="ce1c9fbb82c7f43f2573638b55330b56"></a><!-- doxytag: member="jit_import.h::resolve_nonstatic_field" ref="ce1c9fbb82c7f43f2573638b55330b56" args="(Compile_Handle h, Class_Handle ch, unsigned idx, unsigned putfield)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Field_Handle resolve_nonstatic_field           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>putfield</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resolve a reference to a non-static field. 
<p>
The <code>idx</code> parameter is interpreted as a constant pool index for JVM. Used for getfield and putfield in JVM. 
</div>
</div><p>
<a class="anchor" name="736dad3de9362f4dc08475151a21112c"></a><!-- doxytag: member="jit_import.h::resolve_static_field" ref="736dad3de9362f4dc08475151a21112c" args="(Compile_Handle h, Class_Handle ch, unsigned idx, unsigned putfield)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Field_Handle resolve_static_field           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>putfield</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resolve constant pool reference to a static field. 
<p>
The <code>idx</code> parameter is interpreted as a constant pool index for JVM. Used for getstatic and putstatic in JVM. 
</div>
</div><p>
<a class="anchor" name="4894905345a05cd733a8c78ccc5f0547"></a><!-- doxytag: member="jit_import.h::resolve_static_method" ref="4894905345a05cd733a8c78ccc5f0547" args="(Compile_Handle h, Class_Handle c, unsigned index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Method_Handle resolve_static_method           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resolve a method. 
<p>
Same as <a class="el" href="jit__import_8h.html#26d4901c2bc23ce3476a273ca11c738f" title="Resolve a method.">resolve_method()</a> but the VM checks that the method is static (i.e. it is not an instance method). The <code>idx</code> parameter is interpreted as a constant pool index for JVM. 
</div>
</div><p>
<a class="anchor" name="4703da3fd552d5a565e4aab3e921f4a3"></a><!-- doxytag: member="jit_import.h::resolve_virtual_method" ref="4703da3fd552d5a565e4aab3e921f4a3" args="(Compile_Handle h, Class_Handle c, unsigned index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Method_Handle resolve_virtual_method           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resolve a method. 
<p>
Same as <a class="el" href="jit__import_8h.html#26d4901c2bc23ce3476a273ca11c738f" title="Resolve a method.">resolve_method()</a> but the VM checks that the method can be used for a virtual dispatch. The <code>idx</code> parameter is interpreted as a constant pool index for JVM. 
</div>
</div><p>
<a class="anchor" name="0a56b7a7b40f7e9fc7d67cb19f29974f"></a><!-- doxytag: member="jit_import.h::vm_compile_method" ref="0a56b7a7b40f7e9fc7d67cb19f29974f" args="(JIT_Handle jit, Method_Handle method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT JIT_Result vm_compile_method           </td>
          <td>(</td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>jit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by a JIT to have VM synchronously (in the same thread) compile a method It is a requirement that JIT calls this routine only during compilation of other method, not during run-time. 
<p>

</div>
</div><p>
<a class="anchor" name="c3efb6e88f2b9e398c7136bb8b55f254"></a><!-- doxytag: member="jit_import.h::vm_managed_calling_convention" ref="c3efb6e88f2b9e398c7136bb8b55f254" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="jit__import_8h.html#6734adc5b6fb3a4ce29155c62cab4239">CallingConvention</a> vm_managed_calling_convention           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="18fe543e82826312a8eefb8e5e3c9b5f"></a><!-- doxytag: member="jit_import.h::vm_patch_code_block" ref="18fe543e82826312a8eefb8e5e3c9b5f" args="(Byte *code_block, Byte *new_code, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void vm_patch_code_block           </td>
          <td>(</td>
          <td class="paramtype">Byte *&nbsp;</td>
          <td class="paramname"> <em>code_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Byte *&nbsp;</td>
          <td class="paramname"> <em>new_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by a JIT to have the VM replace a section of executable code in a thread-safe fashion. 
<p>
This function does not synchronize the I- or D-caches. It may be a lot cheaper to batch up the patch requests, so we may need to extend this interface. 
</div>
</div><p>
<a class="anchor" name="dbc874e527427aed60d6c77b76051bad"></a><!-- doxytag: member="jit_import.h::vm_recompile_method" ref="dbc874e527427aed60d6c77b76051bad" args="(JIT_Handle jit, Method_Handle method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void vm_recompile_method           </td>
          <td>(</td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>jit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by a JIT to have the VM recompile a method using the specified JIT. 
<p>
After recompilation, the corresponding vtable entries will be updated, and the necessary callbacks to <code>JIT_recompiled_method_callback</code> will be made. It is a requirement that the method has not already been compiled by the given JIT; this means that multiple instances of a JIT may need to be active at the same time. 
</div>
</div><p>
<a class="anchor" name="9fa39e20a5f8e2166cadc2c7cfa1881e"></a><!-- doxytag: member="jit_import.h::vm_register_jit_extended_class_callback" ref="9fa39e20a5f8e2166cadc2c7cfa1881e" args="(JIT_Handle jit, Class_Handle clss, void *callback_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void vm_register_jit_extended_class_callback           </td>
          <td>(</td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>jit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>clss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>callback_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
These functions allow a JIT to be notified whenever a VM data structure changes that would require code patching or recompilation. 
<p>
Called by a JIT in order to be notified whenever the given class (or any of its subclasses?) is extended. The <code>callback_data</code> pointer will be passed back to the JIT during the callback. The callback function is <code>JIT_extended_class_callback</code>. 
</div>
</div><p>
<a class="anchor" name="2250942e26c1c5e2cc97e4abc1f5d924"></a><!-- doxytag: member="jit_import.h::vm_register_jit_overridden_method_callback" ref="2250942e26c1c5e2cc97e4abc1f5d924" args="(JIT_Handle jit, Method_Handle method, void *callback_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void vm_register_jit_overridden_method_callback           </td>
          <td>(</td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>jit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>callback_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by a JIT in order to be notified whenever the given method is overridden by a newly loaded class. 
<p>
The <code>callback_data</code> pointer will be passed back to the JIT during the callback. The callback function is <code>JIT_overridden_method_callback</code>. 
</div>
</div><p>
<a class="anchor" name="2fae6e65e8ccebd3234259646fc08fcb"></a><!-- doxytag: member="jit_import.h::vm_register_jit_recompiled_method_callback" ref="2fae6e65e8ccebd3234259646fc08fcb" args="(JIT_Handle jit, Method_Handle method, void *callback_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void vm_register_jit_recompiled_method_callback           </td>
          <td>(</td>
          <td class="paramtype">JIT_Handle&nbsp;</td>
          <td class="paramname"> <em>jit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Method_Handle&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>callback_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by a JIT in order to be notified whenever the vtable entries for the given method are changed. 
<p>
This could happen, e.g., when a method is first compiled, or when it is recompiled. The <code>callback_data</code> pointer will be passed back to the JIT during the callback. The callback method is <code>JIT_recompiled_method_callback</code>. 
</div>
</div><p>
<a class="anchor" name="6dd3608689fd9ecc61ce859d0067b13d"></a><!-- doxytag: member="jit_import.h::vm_resolve_class" ref="6dd3608689fd9ecc61ce859d0067b13d" args="(Compile_Handle h, Class_Handle ch, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Class_Handle vm_resolve_class           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resolve a class. 
<p>
The <code>idx</code> parameter is interpreted as a constant pool index for JVM. 
</div>
</div><p>
<a class="anchor" name="0fe513f848bf94d4e83000ad4449ae78"></a><!-- doxytag: member="jit_import.h::vm_resolve_class_new" ref="0fe513f848bf94d4e83000ad4449ae78" args="(Compile_Handle h, Class_Handle c, unsigned index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Class_Handle vm_resolve_class_new           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jit__export_8h.html#2923a394620efd28b7b8c4630f930d74">Compile_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resolve a class and provide error checking if the class cannot have an instance, i.e. 
<p>
it is abstract (or is an interface class). The <code>idx</code> parameter is interpreted as a constant pool index for JVM. 
</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Mar 5 17:15:40 2008 for VM-JIT by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
