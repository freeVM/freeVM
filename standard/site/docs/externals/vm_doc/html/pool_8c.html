<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Harmony Class Library Porting: modules/portlib/src/main/native/pool/shared/pool.c File Reference</title>
<link href="hydoxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1>modules/portlib/src/main/native/pool/shared/pool.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Pool primitives (creation, iteration, deletion, etc. 
<p>
) 
<p>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &quot;<a class="el" href="hypool_8h.html">hypool.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HyPool *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#3a476dea150bf5b275f1149fd941618e">pool_new</a> (U_32 structSize, U_32 minNumberElements, U_32 elementAlignment, UDATA poolFlags, void *(VMCALL *memAlloc)(void *, U_32), void(VMCALL *memFree)(void *, void *), void *userData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#1bc342e7a232db79be8ffd5c43912253">pool_kill</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocates all memory associated with a pool.  <a href="#1bc342e7a232db79be8ffd5c43912253"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#abf88a592e7890461b5bd0d2897f78fd">pool_newElement</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asks for the address of a new pool element.  <a href="#abf88a592e7890461b5bd0d2897f78fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#3e3d8e0a0228e25263be24420389073c">pool_removeElement</a> (HyPool *aPool, void *anElement)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocates an element from a pool.  <a href="#3e3d8e0a0228e25263be24420389073c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#826662db0a174a8a9e98407723167ed8">pool_do</a> (HyPool *aPool, void(*aFunction)(void *anElement, void *userData), void *userData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls a user provided function for each element in the list.  <a href="#826662db0a174a8a9e98407723167ed8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#d06bfa9f9fa0dc351a8bab758745a4bc">pool_numElements</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of elements in a given pool.  <a href="#d06bfa9f9fa0dc351a8bab758745a4bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#f2ca22356fb6793947d51bbbd5d93fc7">pool_startDo</a> (HyPool *aPool, pool_state *lastHandle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#18c3db16ce440b618dc117bea019e5b8">pool_nextDo</a> (pool_state *lastHandle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#cda868970a74c3b6977a10003f350485">pool_sortFree</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the free list of the current pool.  <a href="#cda868970a74c3b6977a10003f350485"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HyPool *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#a14c22685a150883b5073da3ac4c838e">pool_forPortLib</a> (U_32 structSize, <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shortcut for <a class="el" href="pool_8c.html#pool_new">pool_new</a>, using the default malloc/free from the portLibrary.  <a href="#a14c22685a150883b5073da3ac4c838e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#a59aa55452f6fb06070f91f3bcb0806d">pool_clear</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the contents of a pool but not delete it.  <a href="#a59aa55452f6fb06070f91f3bcb0806d"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a59aa55452f6fb06070f91f3bcb0806d"></a><!-- doxytag: member="pool.c::pool_clear" ref="a59aa55452f6fb06070f91f3bcb0806d" args="(HyPool *aPool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pool_clear           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the contents of a pool but not delete it. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Make no assumptions about the contents of the pool after invoking this method (it currently does not zero the memory)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool to clear</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<a class="anchor" name="826662db0a174a8a9e98407723167ed8"></a><!-- doxytag: member="pool.c::pool_do" ref="826662db0a174a8a9e98407723167ed8" args="(HyPool *aPool, void(*aFunction)(void *anElement, void *userData), void *userData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pool_do           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *anElement, void *userData)&nbsp;</td>
          <td class="paramname"> <em>aFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a user provided function for each element in the list. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool to "do" things to </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aFunction</em>&nbsp;</td><td>Pointer to function which will "do" things to the elements of aPool </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>Pointer to data to be passed to "do" function, along with each pool-element</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>pool_startDo, pool_nextDo </dd></dl>

</div>
</div><p>
<a class="anchor" name="a14c22685a150883b5073da3ac4c838e"></a><!-- doxytag: member="pool.c::pool_forPortLib" ref="a14c22685a150883b5073da3ac4c838e" args="(U_32 structSize, HyPortLibrary *portLibrary)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pool_forPortLib           </td>
          <td>(</td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>structSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shortcut for <a class="el" href="pool_8c.html#pool_new">pool_new</a>, using the default malloc/free from the portLibrary. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>structSize</em>&nbsp;</td><td>size of pool-element </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to a Pool</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>pool_new </dd></dl>

</div>
</div><p>
<a class="anchor" name="1bc342e7a232db79be8ffd5c43912253"></a><!-- doxytag: member="pool.c::pool_kill" ref="1bc342e7a232db79be8ffd5c43912253" args="(HyPool *aPool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pool_kill           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deallocates all memory associated with a pool. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>Pool to be deallocated</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<a class="anchor" name="3a476dea150bf5b275f1149fd941618e"></a><!-- doxytag: member="pool.c::pool_new" ref="3a476dea150bf5b275f1149fd941618e" args="(U_32 structSize, U_32 minNumberElements, U_32 elementAlignment, UDATA poolFlags, void *(VMCALL *memAlloc)(void *, U_32), void(VMCALL *memFree)(void *, void *), void *userData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pool_new           </td>
          <td>(</td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>structSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>minNumberElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>elementAlignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UDATA&nbsp;</td>
          <td class="paramname"> <em>poolFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname">(VMCALL *memAlloc)(void *, U_32), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(VMCALL *memFree)(void *, void *)&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<h2><a class="anchor" name="pool_new">
pool_new</a></h2>
Returns a handle to a variable sized pool of structures. This handle should be passed into all other pool functions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>structSize</em>&nbsp;</td><td>Size of the pool-elements </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>minNumberElements</em>&nbsp;</td><td>If zero, will default to 1 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>elementAlignment</em>&nbsp;</td><td>If zero will default to MIN_GRANULARITY </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>poolFlags</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>memAlloc</em>&nbsp;</td><td>Allocate function pointer </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>memFree</em>&nbsp;</td><td>Free function pointer </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to a new pool </dd></dl>

</div>
</div><p>
<a class="anchor" name="abf88a592e7890461b5bd0d2897f78fd"></a><!-- doxytag: member="pool.c::pool_newElement" ref="abf88a592e7890461b5bd0d2897f78fd" args="(HyPool *aPool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pool_newElement           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks for the address of a new pool element. 
<p>
If it succeeds, the address returned will have space for one element of the correct structure size. The contents of the element are undefined. If the current pool is full, a new one will be grafted onto the end of the pool chain and memory from there will be used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>NULL on error <p>
pointer to a new element otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="18c3db16ce440b618dc117bea019e5b8"></a><!-- doxytag: member="pool.c::pool_nextDo" ref="18c3db16ce440b618dc117bea019e5b8" args="(pool_state *lastHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pool_nextDo           </td>
          <td>(</td>
          <td class="paramtype">pool_state *&nbsp;</td>
          <td class="paramname"> <em>lastHandle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<h2><a class="anchor" name="pool_nextDo">
pool_nextDo</a></h2>
Continue an iteration based on state passed in by lastHandle. It is safe to stop an iteration midway through.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lastHandle</em>&nbsp;</td><td>pointer for current iteration state</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>NULL nothing more to be done <p>
pointer to next element to be processed otherwise</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hypool_8h.html#cdc4233f475ea905a8ac7c4f5dc6e373" title="Calls a user provided function for each element in the list.">pool_do</a>, pool_startDo </dd></dl>

</div>
</div><p>
<a class="anchor" name="d06bfa9f9fa0dc351a8bab758745a4bc"></a><!-- doxytag: member="pool.c::pool_numElements" ref="d06bfa9f9fa0dc351a8bab758745a4bc" args="(HyPool *aPool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pool_numElements           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of elements in a given pool. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on error <p>
the number of elements in the pool otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="3e3d8e0a0228e25263be24420389073c"></a><!-- doxytag: member="pool.c::pool_removeElement" ref="3e3d8e0a0228e25263be24420389073c" args="(HyPool *aPool, void *anElement)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pool_removeElement           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>anElement</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deallocates an element from a pool. 
<p>
It is safe to call <a class="el" href="pool_8c.html#3e3d8e0a0228e25263be24420389073c" title="Deallocates an element from a pool.">pool_removeElement()</a> while looping over the pool with <a class="el" href="pool_8c.html#pool_startDo">pool_startDo</a> / <a class="el" href="pool_8c.html#pool_nextDo">pool_nextDo</a> on the element returned by those calls. This is because the free element is always inserted at either the head of the free list or before the nextFree element in the pool_state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>anElement</em>&nbsp;</td><td>Pointer to the element to be removed</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<a class="anchor" name="cda868970a74c3b6977a10003f350485"></a><!-- doxytag: member="pool.c::pool_sortFree" ref="cda868970a74c3b6977a10003f350485" args="(HyPool *aPool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pool_sortFree           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts the free list of the current pool. 
<p>
(ie: does not follow nextPool pointers...) This is a O(n) most of the time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool to be sorted</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<a class="anchor" name="f2ca22356fb6793947d51bbbd5d93fc7"></a><!-- doxytag: member="pool.c::pool_startDo" ref="f2ca22356fb6793947d51bbbd5d93fc7" args="(HyPool *aPool, pool_state *lastHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pool_startDo           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pool_state *&nbsp;</td>
          <td class="paramname"> <em>lastHandle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<h2><a class="anchor" name="pool_startDo">
pool_startDo</a></h2>
Start of an iteration set that will return when code is to be executed. This is based strongly on pool_sortFreeAndIterateUsed. Pass in a pointer to an empty pool_state and it will be filled in.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool to "do" things to </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lastHandle</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>NULL <p>
pointer to element otherwise</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hypool_8h.html#cdc4233f475ea905a8ac7c4f5dc6e373" title="Calls a user provided function for each element in the list.">pool_do</a>, pool_nextDo </dd></dl>

</div>
</div><p>
<hr size="1">
<address style="text-align: center;">
  <small>
    <p>Genereated on Tue Dec 9 14:12:59 2008 by Doxygen.</p>
    <p>(c) Copyright 2005, 2008 The Apache Software Foundation or its licensors, as applicable. </p>
  </small>
</address>
</body>
</html>
