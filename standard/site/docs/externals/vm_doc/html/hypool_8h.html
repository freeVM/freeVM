<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Harmony Class Library Porting: modules/portlib/src/main/native/include/shared/hypool.h File Reference</title>
<link href="hydoxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1>modules/portlib/src/main/native/include/shared/hypool.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Pool Header. 
<p>

<p>
<code>#include &quot;hycomp.h&quot;</code><br>
<code>#include &quot;<a class="el" href="hyport_8h.html">hyport.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>HyPool</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>HyPoolState</b></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#cdc4233f475ea905a8ac7c4f5dc6e373">pool_do</a> (HyPool *aPool, void(*aFunction)(void *anElement, void *userData), void *userData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls a user provided function for each element in the list.  <a href="#cdc4233f475ea905a8ac7c4f5dc6e373"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#59c054de28d8a47135d49b7123bd9168">pool_removeElement</a> (HyPool *aPool, void *anElement)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocates an element from a pool.  <a href="#59c054de28d8a47135d49b7123bd9168"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#a1a3d7802177726a7e423bf01b89aa5a">pool_numElements</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of elements in a given pool.  <a href="#a1a3d7802177726a7e423bf01b89aa5a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC void *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#42794fcd0ff4bd0b23c804e413d44773">pool_newElement</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asks for the address of a new pool element.  <a href="#42794fcd0ff4bd0b23c804e413d44773"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC HyPool *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#34fc514dd9f7339fe6507798a5497246">pool_forPortLib</a> (U_32 structSize, <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shortcut for <a class="el" href="pool_8c.html#pool_new">pool_new</a>, using the default malloc/free from the portLibrary.  <a href="#34fc514dd9f7339fe6507798a5497246"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#8a4a20e4530a7743c6162ef9c4784c52">pool_kill</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocates all memory associated with a pool.  <a href="#8a4a20e4530a7743c6162ef9c4784c52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#600d884e1c775c7ab3e4045029098937">pool_sortFree</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the free list of the current pool.  <a href="#600d884e1c775c7ab3e4045029098937"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#9cc68084517e52b49d9084774f2bbef1">pool_clear</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the contents of a pool but not delete it.  <a href="#9cc68084517e52b49d9084774f2bbef1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#24912b026cff13bdfd343aeb1923caf2">pool_capacity</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total capacity of a pool.  <a href="#24912b026cff13bdfd343aeb1923caf2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HY_CFUNC UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hypool_8h.html#fd789c0217f641b68729e951e5d54861">pool_ensureCapacity</a> (HyPool *aPool, UDATA newCapacity)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensures that the pool is large enough for newCapacity elements.  <a href="#fd789c0217f641b68729e951e5d54861"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="24912b026cff13bdfd343aeb1923caf2"></a><!-- doxytag: member="hypool.h::pool_capacity" ref="24912b026cff13bdfd343aeb1923caf2" args="(HyPool *aPool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HY_CFUNC UDATA VMCALL pool_capacity           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the total capacity of a pool. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on error <p>
numElements in aPool otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="9cc68084517e52b49d9084774f2bbef1"></a><!-- doxytag: member="hypool.h::pool_clear" ref="9cc68084517e52b49d9084774f2bbef1" args="(HyPool *aPool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HY_CFUNC void VMCALL pool_clear           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the contents of a pool but not delete it. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Make no assumptions about the contents of the pool after invoking this method (it currently does not zero the memory)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool to clear</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<a class="anchor" name="cdc4233f475ea905a8ac7c4f5dc6e373"></a><!-- doxytag: member="hypool.h::pool_do" ref="cdc4233f475ea905a8ac7c4f5dc6e373" args="(HyPool *aPool, void(*aFunction)(void *anElement, void *userData), void *userData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HY_CFUNC void VMCALL pool_do           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *anElement, void *userData)&nbsp;</td>
          <td class="paramname"> <em>aFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a user provided function for each element in the list. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool to "do" things to </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aFunction</em>&nbsp;</td><td>Pointer to function which will "do" things to the elements of aPool </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>Pointer to data to be passed to "do" function, along with each pool-element</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>pool_startDo, pool_nextDo </dd></dl>

</div>
</div><p>
<a class="anchor" name="fd789c0217f641b68729e951e5d54861"></a><!-- doxytag: member="hypool.h::pool_ensureCapacity" ref="fd789c0217f641b68729e951e5d54861" args="(HyPool *aPool, UDATA newCapacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HY_CFUNC UDATA VMCALL pool_ensureCapacity           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UDATA&nbsp;</td>
          <td class="paramname"> <em>newCapacity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ensures that the pool is large enough for newCapacity elements. 
<p>
This has the side effect of setting the POOL_NEVER_FREE_PUDDLES flag. Without this, the pool could shrink back down to its original size. Note that this does not take into account the number of elements already used in the pool.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>newCapacity</em>&nbsp;</td><td>The desired new-size of the pool</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success <p>
-1 on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="34fc514dd9f7339fe6507798a5497246"></a><!-- doxytag: member="hypool.h::pool_forPortLib" ref="34fc514dd9f7339fe6507798a5497246" args="(U_32 structSize, HyPortLibrary *portLibrary)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HY_CFUNC HyPool* VMCALL pool_forPortLib           </td>
          <td>(</td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>structSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shortcut for <a class="el" href="pool_8c.html#pool_new">pool_new</a>, using the default malloc/free from the portLibrary. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>structSize</em>&nbsp;</td><td>size of pool-element </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to a Pool</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>pool_new </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a4a20e4530a7743c6162ef9c4784c52"></a><!-- doxytag: member="hypool.h::pool_kill" ref="8a4a20e4530a7743c6162ef9c4784c52" args="(HyPool *aPool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HY_CFUNC void VMCALL pool_kill           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deallocates all memory associated with a pool. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>Pool to be deallocated</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<a class="anchor" name="42794fcd0ff4bd0b23c804e413d44773"></a><!-- doxytag: member="hypool.h::pool_newElement" ref="42794fcd0ff4bd0b23c804e413d44773" args="(HyPool *aPool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HY_CFUNC void* VMCALL pool_newElement           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks for the address of a new pool element. 
<p>
If it succeeds, the address returned will have space for one element of the correct structure size. The contents of the element are undefined. If the current pool is full, a new one will be grafted onto the end of the pool chain and memory from there will be used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>NULL on error <p>
pointer to a new element otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="a1a3d7802177726a7e423bf01b89aa5a"></a><!-- doxytag: member="hypool.h::pool_numElements" ref="a1a3d7802177726a7e423bf01b89aa5a" args="(HyPool *aPool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HY_CFUNC UDATA VMCALL pool_numElements           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of elements in a given pool. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on error <p>
the number of elements in the pool otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="59c054de28d8a47135d49b7123bd9168"></a><!-- doxytag: member="hypool.h::pool_removeElement" ref="59c054de28d8a47135d49b7123bd9168" args="(HyPool *aPool, void *anElement)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HY_CFUNC void VMCALL pool_removeElement           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>anElement</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deallocates an element from a pool. 
<p>
It is safe to call <a class="el" href="pool_8c.html#3e3d8e0a0228e25263be24420389073c" title="Deallocates an element from a pool.">pool_removeElement()</a> while looping over the pool with <a class="el" href="pool_8c.html#pool_startDo">pool_startDo</a> / <a class="el" href="pool_8c.html#pool_nextDo">pool_nextDo</a> on the element returned by those calls. This is because the free element is always inserted at either the head of the free list or before the nextFree element in the pool_state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>anElement</em>&nbsp;</td><td>Pointer to the element to be removed</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<a class="anchor" name="600d884e1c775c7ab3e4045029098937"></a><!-- doxytag: member="hypool.h::pool_sortFree" ref="600d884e1c775c7ab3e4045029098937" args="(HyPool *aPool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HY_CFUNC void VMCALL pool_sortFree           </td>
          <td>(</td>
          <td class="paramtype">HyPool *&nbsp;</td>
          <td class="paramname"> <em>aPool</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts the free list of the current pool. 
<p>
(ie: does not follow nextPool pointers...) This is a O(n) most of the time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool to be sorted</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<hr size="1">
<address style="text-align: center;">
  <small>
    <p>Genereated on Tue Dec 9 14:12:59 2008 by Doxygen.</p>
    <p>(c) Copyright 2005, 2008 The Apache Software Foundation or its licensors, as applicable. </p>
  </small>
</address>
</body>
</html>
