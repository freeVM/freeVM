<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Harmony Class Library Porting: modules/portlib/src/main/native/thread/shared/hythread.c File Reference</title>
<link href="hydoxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1>modules/portlib/src/main/native/thread/shared/hythread.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Threading and synchronization support. 
<p>

<p>
<code>#include &quot;threaddef.h&quot;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#2d8de4536ca01747a3ca3183bfe0d0ea">hythread_shutdown</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shut down the Hy threading library associated with the current thread.  <a href="#2d8de4536ca01747a3ca3183bfe0d0ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#4c35b06eccb30a21507533284c3e0cbe">hythread_init</a> (hythread_library_t lib)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a Hy threading library.  <a href="#4c35b06eccb30a21507533284c3e0cbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">hythread_t VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#56af01f204a5000e87402c01f2b5f4c5">hythread_self</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the hythread_t for the current thread.  <a href="#56af01f204a5000e87402c01f2b5f4c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#0ba000154f47eec76edb925def58cdde">hythread_create</a> (hythread_t *handle, UDATA stacksize, UDATA priority, UDATA suspend, hythread_entrypoint_t entrypoint, void *entryarg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new OS thread.  <a href="#0ba000154f47eec76edb925def58cdde"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#c292a646de9a5fb9c6aff68eb17b7c6e">hythread_attach</a> (hythread_t *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach an OS thread to the threading library.  <a href="#c292a646de9a5fb9c6aff68eb17b7c6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#c30c411e1696f413b95eac6dd98ca219">hythread_suspend</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suspend the current thread.  <a href="#c30c411e1696f413b95eac6dd98ca219"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#3dfcc6056d07ad8ccacfc985c5c2e4d2">hythread_resume</a> (hythread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resume a thread.  <a href="#3dfcc6056d07ad8ccacfc985c5c2e4d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#ec8bcfb886dbf1685136b7407d875821">hythread_yield</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Yield the processor.  <a href="#ec8bcfb886dbf1685136b7407d875821"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#596995b7861e1b156fa655915006de8d">hythread_monitor_destroy</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a monitor.  <a href="#596995b7861e1b156fa655915006de8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#484fdc3ec191fe213f04f1915c772d88">hythread_monitor_enter</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enter a monitor.  <a href="#484fdc3ec191fe213f04f1915c772d88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#c42e45db7d91d27a4be04cf500a46f92">hythread_monitor_exit</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exit a monitor.  <a href="#c42e45db7d91d27a4be04cf500a46f92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#2dd926030b711b38fd6025c9c9286522">hythread_monitor_wait</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait on a monitor until notified.  <a href="#2dd926030b711b38fd6025c9c9286522"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#d7e902aa981a16b9806d98187ed2f999">hythread_monitor_notify</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify a single thread waiting on a monitor.  <a href="#d7e902aa981a16b9806d98187ed2f999"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a01e8a1fd5161b024adf0de1837fcc80">hythread_monitor_notify_all</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify all threads waiting on a monitor.  <a href="#a01e8a1fd5161b024adf0de1837fcc80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#3878100915ea0ea7c6bb8de4bfea7b92">hythread_tls_alloc</a> (hythread_tls_key_t *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a thread local storage (TLS) key.  <a href="#3878100915ea0ea7c6bb8de4bfea7b92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#aa301e673550392ae72ef6bd57f6f3fe">hythread_tls_free</a> (hythread_tls_key_t key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a TLS key.  <a href="#aa301e673550392ae72ef6bd57f6f3fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#e96c0ea2617bfd013a8ec01857cfb0fb">hythread_tls_set</a> (hythread_t thread, hythread_tls_key_t key, void *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a thread's TLS value.  <a href="#e96c0ea2617bfd013a8ec01857cfb0fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#bb1b00af8b799a4b17d0c7b8952b8cb6">hythread_set_priority</a> (hythread_t thread, UDATA priority)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a thread's execution priority.  <a href="#bb1b00af8b799a4b17d0c7b8952b8cb6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#38407a01f70231c2ae0565f79896ae8c">hythread_interrupt</a> (hythread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interrupt a thread.  <a href="#38407a01f70231c2ae0565f79896ae8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#3a4c4a6c84426a5ec0e35728b8a431c6">hythread_interrupted</a> (hythread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of a thread's interrupted flag.  <a href="#3a4c4a6c84426a5ec0e35728b8a431c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#69076be10cbd60a840cc11e97ece430f">hythread_clear_interrupted</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the interrupted flag of the current thread and return its previous value.  <a href="#69076be10cbd60a840cc11e97ece430f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#eb4cad43850472b449b7c1ce43ea6fcb">hythread_sleep_interruptable</a> (I_64 millis, IDATA nanos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suspend the current thread from executing for at least the specified time.  <a href="#eb4cad43850472b449b7c1ce43ea6fcb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#69c3b263bda8bab91c7b6c3918326770">hythread_sleep</a> (I_64 millis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suspend the current thread from executing for at least the specified time.  <a href="#69c3b263bda8bab91c7b6c3918326770"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#589ade2ad6247d9d8522a75df0923092">hythread_cancel</a> (hythread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Terminate a running thread.  <a href="#589ade2ad6247d9d8522a75df0923092"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#28fb6496c44226826c2317ff7f2e308c">hythread_detach</a> (hythread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detaches the current thread from the threading library.  <a href="#28fb6496c44226826c2317ff7f2e308c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL NORETURN&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#f90cc47a260ea9d5fde1601759551d42">hythread_exit</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exit the current thread.  <a href="#f90cc47a260ea9d5fde1601759551d42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#70e13068bd5e37e42be1ddd3dfd81a95">hythread_priority_interrupt</a> (hythread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Priority interrupt a thread.  <a href="#70e13068bd5e37e42be1ddd3dfd81a95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#0cc4b3c6752d2ccfc866c0999545f798">hythread_priority_interrupted</a> (hythread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of a thread's priority interrupted flag.  <a href="#0cc4b3c6752d2ccfc866c0999545f798"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#fb4ca09e3882692171a8867f3ccd4c49">hythread_clear_priority_interrupted</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the priority interrupted flag of the current thread and return its previous value.  <a href="#fb4ca09e3882692171a8867f3ccd4c49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#1fe8ef67e8b20820ed8cf16a94859a35">hythread_monitor_try_enter</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to enter a monitor without blocking.  <a href="#1fe8ef67e8b20820ed8cf16a94859a35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#c11fb3c978c1eb06f427f8edbc517347">hythread_monitor_wait_timed</a> (hythread_monitor_t monitor, I_64 millis, IDATA nanos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait on a monitor until notified or timed out.  <a href="#c11fb3c978c1eb06f427f8edbc517347"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#6898276c58acb556871efef699a3036b">hythread_global</a> (char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch or create a 'named global'.  <a href="#6898276c58acb556871efef699a3036b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#4aed927630619da51c242fa78855e7be">hythread_monitor_wait_interruptable</a> (hythread_monitor_t monitor, I_64 millis, IDATA nanos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait on a monitor until notified, interrupted (priority or normal), or timed out.  <a href="#4aed927630619da51c242fa78855e7be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#85e51be6b0ef850a30689dca5515eab8">hythread_monitor_num_waiting</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns how many threads are currently waiting on a monitor.  <a href="#85e51be6b0ef850a30689dca5515eab8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#d1d5e367609ef0b760117efce79b9c89">hythread_monitor_exit_using_threadId</a> (hythread_monitor_t monitor, hythread_t threadId)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exit a monitor.  <a href="#d1d5e367609ef0b760117efce79b9c89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#f9e22d80cdac4b57bb9a15a940597588">hythread_monitor_enter_using_threadId</a> (hythread_monitor_t monitor, hythread_t threadId)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enter a monitor.  <a href="#f9e22d80cdac4b57bb9a15a940597588"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#f1db19f4b1dc6e7ec48068829850ed78">hythread_monitor_try_enter_using_threadId</a> (hythread_monitor_t monitor, hythread_t threadId)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to enter a monitor without blocking.  <a href="#f1db19f4b1dc6e7ec48068829850ed78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#07dcd3d79d6d29c4464368cc9532ee97">hythread_lib_get_flags</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get threading library global flags.  <a href="#07dcd3d79d6d29c4464368cc9532ee97"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#b5b671c367ec114077056e925b11ed82">hythread_lib_set_flags</a> (UDATA flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set threading library global flags.  <a href="#b5b671c367ec114077056e925b11ed82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#8ff1de8339ad619cf167b06186eafbd1">hythread_lib_clear_flags</a> (UDATA flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear specified threading library global flags.  <a href="#8ff1de8339ad619cf167b06186eafbd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a4bb9132af94e2446f4125bfd6446f21">hythread_monitor_init_with_name</a> (hythread_monitor_t *handle, UDATA flags, char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire and initialize a new monitor from the threading library.  <a href="#a4bb9132af94e2446f4125bfd6446f21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#72a79a7e722f8cc023fe522cde7881d2">hythread_lib_lock</a> (hythread_t self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire the threading library's global lock.  <a href="#72a79a7e722f8cc023fe522cde7881d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#d4bea2a143b410c8c11bdf971c4cbde5">hythread_lib_unlock</a> (hythread_t self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the threading library's global lock.  <a href="#d4bea2a143b410c8c11bdf971c4cbde5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#da1c3e3c78e868b84925205467b3655a">hythread_park</a> (I_64 millis, IDATA nanos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">'Park' the current thread.  <a href="#da1c3e3c78e868b84925205467b3655a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#1a99b6715a51c0d13f5b0ad4ee00c954">hythread_unpark</a> (hythread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">'Unpark' the specified thread.  <a href="#1a99b6715a51c0d13f5b0ad4ee00c954"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#3fae4b2b7a5920a5b07e3fad94542824">hythread_tls_alloc_with_finalizer</a> (hythread_tls_key_t *handle, hythread_tls_finalizer_t finalizer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a thread local storage (TLS) key.  <a href="#3fae4b2b7a5920a5b07e3fad94542824"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#b4416c9c2ff8be35c11a16fea0e7726a">hythread_current_stack_free</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the remaining useable bytes of the current thread's OS stack.  <a href="#b4416c9c2ff8be35c11a16fea0e7726a"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="c292a646de9a5fb9c6aff68eb17b7c6e"></a><!-- doxytag: member="hythread.c::hythread_attach" ref="c292a646de9a5fb9c6aff68eb17b7c6e" args="(hythread_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_attach           </td>
          <td>(</td>
          <td class="paramtype">hythread_t *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attach an OS thread to the threading library. 
<p>
Create a new hythread_t to represent the existing OS thread. Attaching a thread is required when a thread was created outside of the Hy threading library wants to use any of the Hy threading library functionality.<p>
If the OS thread is already attached, handle is set to point to the existing hythread_t.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>pointer to a hythread_t to be set (will be ignored if null) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success or negative value on failure</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#28fb6496c44226826c2317ff7f2e308c" title="Detaches the current thread from the threading library.">hythread_detach</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="589ade2ad6247d9d8522a75df0923092"></a><!-- doxytag: member="hythread.c::hythread_cancel" ref="589ade2ad6247d9d8522a75df0923092" args="(hythread_t thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VMCALL hythread_cancel           </td>
          <td>(</td>
          <td class="paramtype">hythread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Terminate a running thread. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This should only be used as a last resort. The system may be in an unpredictable state once a thread is cancelled. In addition, the thread may not even stop running if it refuses to cancel.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>a thread to be terminated </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<a class="anchor" name="69076be10cbd60a840cc11e97ece430f"></a><!-- doxytag: member="hythread.c::hythread_clear_interrupted" ref="69076be10cbd60a840cc11e97ece430f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDATA VMCALL hythread_clear_interrupted           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the interrupted flag of the current thread and return its previous value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>previous value of interrupted flag: non-zero if the thread had been interrupted. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fb4ca09e3882692171a8867f3ccd4c49"></a><!-- doxytag: member="hythread.c::hythread_clear_priority_interrupted" ref="fb4ca09e3882692171a8867f3ccd4c49" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDATA VMCALL hythread_clear_priority_interrupted           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the priority interrupted flag of the current thread and return its previous value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>previous value of priority interrupted flag: nonzero if the thread had been priority interrupted. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0ba000154f47eec76edb925def58cdde"></a><!-- doxytag: member="hythread.c::hythread_create" ref="0ba000154f47eec76edb925def58cdde" args="(hythread_t *handle, UDATA stacksize, UDATA priority, UDATA suspend, hythread_entrypoint_t entrypoint, void *entryarg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_create           </td>
          <td>(</td>
          <td class="paramtype">hythread_t *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UDATA&nbsp;</td>
          <td class="paramname"> <em>stacksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UDATA&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UDATA&nbsp;</td>
          <td class="paramname"> <em>suspend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hythread_entrypoint_t&nbsp;</td>
          <td class="paramname"> <em>entrypoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>entryarg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new OS thread. 
<p>
The created thread is attached to the threading library.<br>
 <br>
 Unlike POSIX, this doesn't require an attributes structure. Instead, any interesting attributes (e.g. stacksize) are passed in with the arguments.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>a pointer to a hythread_t which will point to the thread (if successfully created) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stacksize</em>&nbsp;</td><td>the size of the new thread's stack (bytes)<br>
 0 indicates use default size </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>priorities range from HYTHREAD_PRIORITY_MIN to HYTHREAD_PRIORITY_MAX (inclusive) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>suspend</em>&nbsp;</td><td>set to non-zero to create the thread in a suspended state. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>entrypoint</em>&nbsp;</td><td>pointer to the function which the thread will run </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>entryarg</em>&nbsp;</td><td>a value to pass to the entrypoint function</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success or negative value on failure</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#f90cc47a260ea9d5fde1601759551d42" title="Exit the current thread.">hythread_exit</a>, <a class="el" href="hythread_8c.html#3dfcc6056d07ad8ccacfc985c5c2e4d2" title="Resume a thread.">hythread_resume</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b4416c9c2ff8be35c11a16fea0e7726a"></a><!-- doxytag: member="hythread.c::hythread_current_stack_free" ref="b4416c9c2ff8be35c11a16fea0e7726a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDATA VMCALL hythread_current_stack_free           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the remaining useable bytes of the current thread's OS stack. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>OS stack free size in bytes, 0 if it cannot be determined. </dd></dl>

</div>
</div><p>
<a class="anchor" name="28fb6496c44226826c2317ff7f2e308c"></a><!-- doxytag: member="hythread.c::hythread_detach" ref="28fb6496c44226826c2317ff7f2e308c" args="(hythread_t thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VMCALL hythread_detach           </td>
          <td>(</td>
          <td class="paramtype">hythread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detaches the current thread from the threading library. 
<p>
Detach must only be called by an attached thread. The actual parameter must be the the current thread's hythread_t, or NULL (in which case this function retrieves and uses the current thread's hythread_t). This function cannot be used to detach an arbitrary thread.<p>
When detached, internal resources associated with the thread are freed and the hythread_t structure becomes invalid.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>the hythread_t of the current thread to be detached, or NULL meaning the current thread struct is looked-up and detached. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#c292a646de9a5fb9c6aff68eb17b7c6e" title="Attach an OS thread to the threading library.">hythread_attach</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f90cc47a260ea9d5fde1601759551d42"></a><!-- doxytag: member="hythread.c::hythread_exit" ref="f90cc47a260ea9d5fde1601759551d42" args="(hythread_monitor_t monitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VMCALL NORETURN hythread_exit           </td>
          <td>(</td>
          <td class="paramtype">hythread_monitor_t&nbsp;</td>
          <td class="paramname"> <em>monitor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Exit the current thread. 
<p>
If the thread has been detached, it is destroyed.<p>
If monitor is not NULL, the monitor will be exited before the thread terminates. This is useful if the thread wishes to signal its termination to a watcher, since it exits the monitor and terminates the thread without ever returning control to the thread's routine, which might be running in a DLL which is about to be closed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>monitor to be exited before exiting (ignored if NULL) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<a class="anchor" name="6898276c58acb556871efef699a3036b"></a><!-- doxytag: member="hythread.c::hythread_global" ref="6898276c58acb556871efef699a3036b" args="(char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDATA* VMCALL hythread_global           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetch or create a 'named global'. 
<p>
Return a pointer to the data associated with a named global with the specified name.<br>
 A new named global is created if a named global with the specified name can't be found.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>name of named global to read/create </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to a UDATA associated with name<br>
 0 on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4c35b06eccb30a21507533284c3e0cbe"></a><!-- doxytag: member="hythread.c::hythread_init" ref="4c35b06eccb30a21507533284c3e0cbe" args="(hythread_library_t lib)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VMCALL hythread_init           </td>
          <td>(</td>
          <td class="paramtype">hythread_library_t&nbsp;</td>
          <td class="paramname"> <em>lib</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a Hy threading library. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This must only be called once.</dd></dl>
If any OS threads were created before calling this function, they must be attached using hythread_attach before accessing any Hy thread library functions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lib</em>&nbsp;</td><td>pointer to the Hy thread library to be initialized (non-NULL) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The Hy thread library's initStatus will be set to 0 on success or a negative value on failure.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#c292a646de9a5fb9c6aff68eb17b7c6e" title="Attach an OS thread to the threading library.">hythread_attach</a>, <a class="el" href="hythread_8c.html#2d8de4536ca01747a3ca3183bfe0d0ea" title="Shut down the Hy threading library associated with the current thread.">hythread_shutdown</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="38407a01f70231c2ae0565f79896ae8c"></a><!-- doxytag: member="hythread.c::hythread_interrupt" ref="38407a01f70231c2ae0565f79896ae8c" args="(hythread_t thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VMCALL hythread_interrupt           </td>
          <td>(</td>
          <td class="paramtype">hythread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupt a thread. 
<p>
If the thread is currently blocked (i.e. waiting on a monitor_wait or sleeping) resume the thread and cause it to return from the blocking function with HYTHREAD_INTERRUPTED.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>a thead to be interrupted </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<a class="anchor" name="3a4c4a6c84426a5ec0e35728b8a431c6"></a><!-- doxytag: member="hythread.c::hythread_interrupted" ref="3a4c4a6c84426a5ec0e35728b8a431c6" args="(hythread_t thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDATA VMCALL hythread_interrupted           </td>
          <td>(</td>
          <td class="paramtype">hythread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the value of a thread's interrupted flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>thread to be queried </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if not interrupted, non-zero if interrupted </dd></dl>

</div>
</div><p>
<a class="anchor" name="8ff1de8339ad619cf167b06186eafbd1"></a><!-- doxytag: member="hythread.c::hythread_lib_clear_flags" ref="8ff1de8339ad619cf167b06186eafbd1" args="(UDATA flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDATA VMCALL hythread_lib_clear_flags           </td>
          <td>(</td>
          <td class="paramtype">UDATA&nbsp;</td>
          <td class="paramname"> <em>flags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear specified threading library global flags. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#b5b671c367ec114077056e925b11ed82" title="Set threading library global flags.">hythread_lib_set_flags</a>, <a class="el" href="hythread_8c.html#07dcd3d79d6d29c4464368cc9532ee97" title="Get threading library global flags.">hythread_lib_get_flags</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>flags to be cleared (bit vector: 1 means clear the flag, 0 means ignore) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>old flags values </dd></dl>

</div>
</div><p>
<a class="anchor" name="07dcd3d79d6d29c4464368cc9532ee97"></a><!-- doxytag: member="hythread.c::hythread_lib_get_flags" ref="07dcd3d79d6d29c4464368cc9532ee97" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDATA VMCALL hythread_lib_get_flags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get threading library global flags. 
<p>
Returns the flags for the threading library associated with the current thread.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>: assumes caller has global lock</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#8ff1de8339ad619cf167b06186eafbd1" title="Clear specified threading library global flags.">hythread_lib_clear_flags</a>, <a class="el" href="hythread_8c.html#b5b671c367ec114077056e925b11ed82" title="Set threading library global flags.">hythread_lib_set_flags</a>, <a class="el" href="hythread_8c.html#72a79a7e722f8cc023fe522cde7881d2" title="Acquire the threading library&#39;s global lock.">hythread_lib_lock</a> </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>current flags value </dd></dl>

</div>
</div><p>
<a class="anchor" name="72a79a7e722f8cc023fe522cde7881d2"></a><!-- doxytag: member="hythread.c::hythread_lib_lock" ref="72a79a7e722f8cc023fe522cde7881d2" args="(hythread_t self)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VMCALL hythread_lib_lock           </td>
          <td>(</td>
          <td class="paramtype">hythread_t&nbsp;</td>
          <td class="paramname"> <em>self</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Acquire the threading library's global lock. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This must not be called recursively by a thread that already owns the global lock. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>self</em>&nbsp;</td><td>hythread_t for the current thread </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#d4bea2a143b410c8c11bdf971c4cbde5" title="Release the threading library&#39;s global lock.">hythread_lib_unlock</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b5b671c367ec114077056e925b11ed82"></a><!-- doxytag: member="hythread.c::hythread_lib_set_flags" ref="b5b671c367ec114077056e925b11ed82" args="(UDATA flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDATA VMCALL hythread_lib_set_flags           </td>
          <td>(</td>
          <td class="paramtype">UDATA&nbsp;</td>
          <td class="paramname"> <em>flags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set threading library global flags. 
<p>
Sets the flags for the threading library associated with the current thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>flags to be set (bit vector: 1 means set the flag, 0 means ignore) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>old flags values </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#8ff1de8339ad619cf167b06186eafbd1" title="Clear specified threading library global flags.">hythread_lib_clear_flags</a>, <a class="el" href="hythread_8c.html#07dcd3d79d6d29c4464368cc9532ee97" title="Get threading library global flags.">hythread_lib_get_flags</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d4bea2a143b410c8c11bdf971c4cbde5"></a><!-- doxytag: member="hythread.c::hythread_lib_unlock" ref="d4bea2a143b410c8c11bdf971c4cbde5" args="(hythread_t self)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VMCALL hythread_lib_unlock           </td>
          <td>(</td>
          <td class="paramtype">hythread_t&nbsp;</td>
          <td class="paramname"> <em>self</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release the threading library's global lock. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This must be called only by the thread that currently has the global lock locked. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>self</em>&nbsp;</td><td>hythread_t for the current thread </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#72a79a7e722f8cc023fe522cde7881d2" title="Acquire the threading library&#39;s global lock.">hythread_lib_lock</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="596995b7861e1b156fa655915006de8d"></a><!-- doxytag: member="hythread.c::hythread_monitor_destroy" ref="596995b7861e1b156fa655915006de8d" args="(hythread_monitor_t monitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_monitor_destroy           </td>
          <td>(</td>
          <td class="paramtype">hythread_monitor_t&nbsp;</td>
          <td class="paramname"> <em>monitor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy a monitor. 
<p>
Destroying a monitor frees the internal resources associated with it.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A monitor must NOT be destroyed if threads are waiting on it, or if it is currently owned.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be destroyed </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success or non-0 on failure (the monitor is in use)</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a4bb9132af94e2446f4125bfd6446f21" title="Acquire and initialize a new monitor from the threading library.">hythread_monitor_init_with_name</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="484fdc3ec191fe213f04f1915c772d88"></a><!-- doxytag: member="hythread.c::hythread_monitor_enter" ref="484fdc3ec191fe213f04f1915c772d88" args="(hythread_monitor_t monitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_monitor_enter           </td>
          <td>(</td>
          <td class="paramtype">hythread_monitor_t&nbsp;</td>
          <td class="paramname"> <em>monitor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enter a monitor. 
<p>
A thread may re-enter a monitor it owns multiple times, but must exit the monitor the same number of times before any other thread wanting to enter the monitor is permitted to continue.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be entered </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success<br>
 HYTHREAD_PRIORITY_INTERRUPTED if the thread was priority interrupted while blocked</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#f9e22d80cdac4b57bb9a15a940597588" title="Enter a monitor.">hythread_monitor_enter_using_threadId</a>, <a class="el" href="hythread_8c.html#c42e45db7d91d27a4be04cf500a46f92" title="Exit a monitor.">hythread_monitor_exit</a>, <a class="el" href="hythread_8c.html#d1d5e367609ef0b760117efce79b9c89" title="Exit a monitor.">hythread_monitor_exit_using_threadId</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f9e22d80cdac4b57bb9a15a940597588"></a><!-- doxytag: member="hythread.c::hythread_monitor_enter_using_threadId" ref="f9e22d80cdac4b57bb9a15a940597588" args="(hythread_monitor_t monitor, hythread_t threadId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_monitor_enter_using_threadId           </td>
          <td>(</td>
          <td class="paramtype">hythread_monitor_t&nbsp;</td>
          <td class="paramname"> <em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hythread_t&nbsp;</td>
          <td class="paramname"> <em>threadId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enter a monitor. 
<p>
This is a slightly faster version of hythread_monitor_enter because the hythread_t for the current thread doesn't have to be looked up<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be entered </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadId</em>&nbsp;</td><td>hythread_t for the current thread </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success<br>
 HYTHREAD_PRIORITY_INTERRUPTED if the thread was priority interrupted while blocked</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#484fdc3ec191fe213f04f1915c772d88" title="Enter a monitor.">hythread_monitor_enter</a>, <a class="el" href="hythread_8c.html#c42e45db7d91d27a4be04cf500a46f92" title="Exit a monitor.">hythread_monitor_exit</a>, <a class="el" href="hythread_8c.html#d1d5e367609ef0b760117efce79b9c89" title="Exit a monitor.">hythread_monitor_exit_using_threadId</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c42e45db7d91d27a4be04cf500a46f92"></a><!-- doxytag: member="hythread.c::hythread_monitor_exit" ref="c42e45db7d91d27a4be04cf500a46f92" args="(hythread_monitor_t monitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_monitor_exit           </td>
          <td>(</td>
          <td class="paramtype">hythread_monitor_t&nbsp;</td>
          <td class="paramname"> <em>monitor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Exit a monitor. 
<p>
Exit a monitor, and if the owning count is zero, release it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be exited </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, <br>
HYTHREAD_ILLEGAL_MONITOR_STATE if the current thread does not own the monitor</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#d1d5e367609ef0b760117efce79b9c89" title="Exit a monitor.">hythread_monitor_exit_using_threadId</a>, <a class="el" href="hythread_8c.html#484fdc3ec191fe213f04f1915c772d88" title="Enter a monitor.">hythread_monitor_enter</a>, <a class="el" href="hythread_8c.html#f9e22d80cdac4b57bb9a15a940597588" title="Enter a monitor.">hythread_monitor_enter_using_threadId</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d1d5e367609ef0b760117efce79b9c89"></a><!-- doxytag: member="hythread.c::hythread_monitor_exit_using_threadId" ref="d1d5e367609ef0b760117efce79b9c89" args="(hythread_monitor_t monitor, hythread_t threadId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_monitor_exit_using_threadId           </td>
          <td>(</td>
          <td class="paramtype">hythread_monitor_t&nbsp;</td>
          <td class="paramname"> <em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hythread_t&nbsp;</td>
          <td class="paramname"> <em>threadId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Exit a monitor. 
<p>
This is a slightly faster version of hythread_monitor_exit because the hythread_t for the current thread doesn't have to be looked up<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be exited </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadId</em>&nbsp;</td><td>hythread_t for the current thread </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success<br>
 HYTHREAD_ILLEGAL_MONITOR_STATE if the current thread does not own the monitor</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#c42e45db7d91d27a4be04cf500a46f92" title="Exit a monitor.">hythread_monitor_exit</a>, <a class="el" href="hythread_8c.html#484fdc3ec191fe213f04f1915c772d88" title="Enter a monitor.">hythread_monitor_enter</a>, <a class="el" href="hythread_8c.html#f9e22d80cdac4b57bb9a15a940597588" title="Enter a monitor.">hythread_monitor_enter_using_threadId</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a4bb9132af94e2446f4125bfd6446f21"></a><!-- doxytag: member="hythread.c::hythread_monitor_init_with_name" ref="a4bb9132af94e2446f4125bfd6446f21" args="(hythread_monitor_t *handle, UDATA flags, char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_monitor_init_with_name           </td>
          <td>(</td>
          <td class="paramtype">hythread_monitor_t *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UDATA&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Acquire and initialize a new monitor from the threading library. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>pointer to a hythread_monitor_t to be set to point to the new monitor </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>initial flag values for the monitor </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>pointer to a C string with a description of how the monitor will be used (may be NULL)<br>
 If non-NULL, the C string must be valid for the entire life of the monitor</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success or negative value on failure</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#596995b7861e1b156fa655915006de8d" title="Destroy a monitor.">hythread_monitor_destroy</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d7e902aa981a16b9806d98187ed2f999"></a><!-- doxytag: member="hythread.c::hythread_monitor_notify" ref="d7e902aa981a16b9806d98187ed2f999" args="(hythread_monitor_t monitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_monitor_notify           </td>
          <td>(</td>
          <td class="paramtype">hythread_monitor_t&nbsp;</td>
          <td class="paramname"> <em>monitor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Notify a single thread waiting on a monitor. 
<p>
A thread is considered to be waiting on the monitor if it is currently blocked while executing hythread_monitor_wait on the monitor.<p>
If no threads are waiting, no action is taken.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be signaled </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 once the monitor has been signaled<br>
HYTHREAD_ILLEGAL_MONITOR_STATE if the current thread does not own the monitor</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a01e8a1fd5161b024adf0de1837fcc80" title="Notify all threads waiting on a monitor.">hythread_monitor_notify_all</a>, <a class="el" href="hythread_8c.html#484fdc3ec191fe213f04f1915c772d88" title="Enter a monitor.">hythread_monitor_enter</a>, <a class="el" href="hythread_8c.html#2dd926030b711b38fd6025c9c9286522" title="Wait on a monitor until notified.">hythread_monitor_wait</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a01e8a1fd5161b024adf0de1837fcc80"></a><!-- doxytag: member="hythread.c::hythread_monitor_notify_all" ref="a01e8a1fd5161b024adf0de1837fcc80" args="(hythread_monitor_t monitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_monitor_notify_all           </td>
          <td>(</td>
          <td class="paramtype">hythread_monitor_t&nbsp;</td>
          <td class="paramname"> <em>monitor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Notify all threads waiting on a monitor. 
<p>
A thread is considered to be waiting on the monitor if it is currently blocked while executing hythread_monitor_wait on the monitor.<p>
If no threads are waiting, no action is taken.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be signaled </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 once the monitor has been signaled<br>
HYTHREAD_ILLEGAL_MONITOR_STATE if the current thread does not own the monitor</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#d7e902aa981a16b9806d98187ed2f999" title="Notify a single thread waiting on a monitor.">hythread_monitor_notify</a>, <a class="el" href="hythread_8c.html#484fdc3ec191fe213f04f1915c772d88" title="Enter a monitor.">hythread_monitor_enter</a>, <a class="el" href="hythread_8c.html#2dd926030b711b38fd6025c9c9286522" title="Wait on a monitor until notified.">hythread_monitor_wait</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="85e51be6b0ef850a30689dca5515eab8"></a><!-- doxytag: member="hythread.c::hythread_monitor_num_waiting" ref="85e51be6b0ef850a30689dca5515eab8" args="(hythread_monitor_t monitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDATA VMCALL hythread_monitor_num_waiting           </td>
          <td>(</td>
          <td class="paramtype">hythread_monitor_t&nbsp;</td>
          <td class="paramname"> <em>monitor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns how many threads are currently waiting on a monitor. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This can only be called by the owner of this monitor.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of threads waiting on the monitor (&gt;=0) </dd></dl>

</div>
</div><p>
<a class="anchor" name="1fe8ef67e8b20820ed8cf16a94859a35"></a><!-- doxytag: member="hythread.c::hythread_monitor_try_enter" ref="1fe8ef67e8b20820ed8cf16a94859a35" args="(hythread_monitor_t monitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_monitor_try_enter           </td>
          <td>(</td>
          <td class="paramtype">hythread_monitor_t&nbsp;</td>
          <td class="paramname"> <em>monitor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to enter a monitor without blocking. 
<p>
If the thread must block before it enters the monitor this function returns immediately with a negative value to indicate failure.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success or negative value on failure</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#f1db19f4b1dc6e7ec48068829850ed78" title="Attempt to enter a monitor without blocking.">hythread_monitor_try_enter_using_threadId</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f1db19f4b1dc6e7ec48068829850ed78"></a><!-- doxytag: member="hythread.c::hythread_monitor_try_enter_using_threadId" ref="f1db19f4b1dc6e7ec48068829850ed78" args="(hythread_monitor_t monitor, hythread_t threadId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_monitor_try_enter_using_threadId           </td>
          <td>(</td>
          <td class="paramtype">hythread_monitor_t&nbsp;</td>
          <td class="paramname"> <em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hythread_t&nbsp;</td>
          <td class="paramname"> <em>threadId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to enter a monitor without blocking. 
<p>
If the thread must block before it enters the monitor this function returns immediately with a negative value to indicate failure.<br>
<p>
This is a slightly faster version of hythread_monitor_try_enter because the current thread's hythread_t doesn't have to be looked up.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadId</em>&nbsp;</td><td>the current thread </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success or negative value on failure</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#1fe8ef67e8b20820ed8cf16a94859a35" title="Attempt to enter a monitor without blocking.">hythread_monitor_try_enter</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2dd926030b711b38fd6025c9c9286522"></a><!-- doxytag: member="hythread.c::hythread_monitor_wait" ref="2dd926030b711b38fd6025c9c9286522" args="(hythread_monitor_t monitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_monitor_wait           </td>
          <td>(</td>
          <td class="paramtype">hythread_monitor_t&nbsp;</td>
          <td class="paramname"> <em>monitor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait on a monitor until notified. 
<p>
Release the monitor, wait for a signal (notification), then re-acquire the monitor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be waited on </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if the monitor has been waited on, notified, and reobtained<br>
 HYTHREAD_INVALID_ARGUMENT if millis or nanos is out of range (millis or nanos &lt; 0, or nanos &gt;= 1E6)<br>
 HYTHREAD_ILLEGAL_MONITOR_STATE if the current thread does not own the monitor</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#4aed927630619da51c242fa78855e7be" title="Wait on a monitor until notified, interrupted (priority or normal), or timed out...">hythread_monitor_wait_interruptable</a>, <a class="el" href="hythread_8c.html#c11fb3c978c1eb06f427f8edbc517347" title="Wait on a monitor until notified or timed out.">hythread_monitor_wait_timed</a>, <a class="el" href="hythread_8c.html#484fdc3ec191fe213f04f1915c772d88" title="Enter a monitor.">hythread_monitor_enter</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4aed927630619da51c242fa78855e7be"></a><!-- doxytag: member="hythread.c::hythread_monitor_wait_interruptable" ref="4aed927630619da51c242fa78855e7be" args="(hythread_monitor_t monitor, I_64 millis, IDATA nanos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_monitor_wait_interruptable           </td>
          <td>(</td>
          <td class="paramtype">hythread_monitor_t&nbsp;</td>
          <td class="paramname"> <em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_64&nbsp;</td>
          <td class="paramname"> <em>millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDATA&nbsp;</td>
          <td class="paramname"> <em>nanos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait on a monitor until notified, interrupted (priority or normal), or timed out. 
<p>
A timeout of 0 (0ms, 0ns) indicates wait indefinitely.<p>
If 'interruptable' is non-zero, the wait may be interrupted by one of the interrupt functions. (i.e. hythread_interrupt, hythread_priority_interrupt);<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be waited on </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>millis</em>&nbsp;</td><td>&gt;=0 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nanos</em>&nbsp;</td><td>&gt;=0 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>interruptable</em>&nbsp;</td><td>non-zero if the wait is to be interruptable</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 the monitor has been waited on, notified, and reobtained<br>
 HYTHREAD_INVALID_ARGUMENT if millis or nanos is out of range (millis or nanos &lt; 0, or nanos &gt;= 1E6)<br>
 HYTHREAD_ILLEGAL_MONITOR_STATE if the current thread does not own the monitor<br>
 HYTHREAD_INTERRUPTED if the thread was interrupted while waiting<br>
 HYTHREAD_PRIORITY_INTERRUPTED if the thread was priority interrupted while waiting, or while re-obtaining the monitor<br>
 HYTHREAD_TIMED_OUT if the timeout expired<br>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#2dd926030b711b38fd6025c9c9286522" title="Wait on a monitor until notified.">hythread_monitor_wait</a>, <a class="el" href="hythread_8c.html#c11fb3c978c1eb06f427f8edbc517347" title="Wait on a monitor until notified or timed out.">hythread_monitor_wait_timed</a>, <a class="el" href="hythread_8c.html#484fdc3ec191fe213f04f1915c772d88" title="Enter a monitor.">hythread_monitor_enter</a> <p>
<a class="el" href="hythread_8c.html#38407a01f70231c2ae0565f79896ae8c" title="Interrupt a thread.">hythread_interrupt</a>, <a class="el" href="hythread_8c.html#70e13068bd5e37e42be1ddd3dfd81a95" title="Priority interrupt a thread.">hythread_priority_interrupt</a> * </dd></dl>

</div>
</div><p>
<a class="anchor" name="c11fb3c978c1eb06f427f8edbc517347"></a><!-- doxytag: member="hythread.c::hythread_monitor_wait_timed" ref="c11fb3c978c1eb06f427f8edbc517347" args="(hythread_monitor_t monitor, I_64 millis, IDATA nanos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_monitor_wait_timed           </td>
          <td>(</td>
          <td class="paramtype">hythread_monitor_t&nbsp;</td>
          <td class="paramname"> <em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_64&nbsp;</td>
          <td class="paramname"> <em>millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDATA&nbsp;</td>
          <td class="paramname"> <em>nanos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait on a monitor until notified or timed out. 
<p>
A timeout of 0 (0ms, 0ns) indicates wait indefinitely.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be waited on </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>millis</em>&nbsp;</td><td>&gt;=0 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nanos</em>&nbsp;</td><td>&gt;=0</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 the monitor has been waited on, notified, and reobtained<br>
 HYTHREAD_INVALID_ARGUMENT millis or nanos is out of range (millis or nanos &lt; 0, or nanos &gt;= 1E6)<br>
 HYTHREAD_ILLEGAL_MONITOR_STATE the current thread does not own the monitor<br>
 HYTHREAD_TIMED_OUT the timeout expired</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#2dd926030b711b38fd6025c9c9286522" title="Wait on a monitor until notified.">hythread_monitor_wait</a>, <a class="el" href="hythread_8c.html#4aed927630619da51c242fa78855e7be" title="Wait on a monitor until notified, interrupted (priority or normal), or timed out...">hythread_monitor_wait_interruptable</a>, <a class="el" href="hythread_8c.html#484fdc3ec191fe213f04f1915c772d88" title="Enter a monitor.">hythread_monitor_enter</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="da1c3e3c78e868b84925205467b3655a"></a><!-- doxytag: member="hythread.c::hythread_park" ref="da1c3e3c78e868b84925205467b3655a" args="(I_64 millis, IDATA nanos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_park           </td>
          <td>(</td>
          <td class="paramtype">I_64&nbsp;</td>
          <td class="paramname"> <em>millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDATA&nbsp;</td>
          <td class="paramname"> <em>nanos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
'Park' the current thread. 
<p>
Stop the current thread from executing until it is unparked, interrupted, or the specified timeout elapses.<p>
Unlike wait or sleep, the interrupted flag is NOT cleared by this API.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>millis</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nanos</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if the thread is unparked HYTHREAD_INTERRUPTED if the thread was interrupted while parked<br>
 HYTHREAD_PRIORITY_INTERRUPTED if the thread was priority interrupted while parked<br>
 HYTHREAD_TIMED_OUT if the timeout expired<br>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#1a99b6715a51c0d13f5b0ad4ee00c954" title="&#39;Unpark&#39; the specified thread.">hythread_unpark</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="70e13068bd5e37e42be1ddd3dfd81a95"></a><!-- doxytag: member="hythread.c::hythread_priority_interrupt" ref="70e13068bd5e37e42be1ddd3dfd81a95" args="(hythread_t thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VMCALL hythread_priority_interrupt           </td>
          <td>(</td>
          <td class="paramtype">hythread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Priority interrupt a thread. 
<p>
If the thread is currently blocked (i.e. waiting on a monitor_wait or sleeping) resume the thread and return from the blocking function with HYTHREAD_PRIORITY_INTERRUPTED<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>a thead to be priority interrupted </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<a class="anchor" name="0cc4b3c6752d2ccfc866c0999545f798"></a><!-- doxytag: member="hythread.c::hythread_priority_interrupted" ref="0cc4b3c6752d2ccfc866c0999545f798" args="(hythread_t thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDATA VMCALL hythread_priority_interrupted           </td>
          <td>(</td>
          <td class="paramtype">hythread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the value of a thread's priority interrupted flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>thread to be queried </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if not priority interrupted, non-zero if priority interrupted flag set </dd></dl>

</div>
</div><p>
<a class="anchor" name="3dfcc6056d07ad8ccacfc985c5c2e4d2"></a><!-- doxytag: member="hythread.c::hythread_resume" ref="3dfcc6056d07ad8ccacfc985c5c2e4d2" args="(hythread_t thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VMCALL hythread_resume           </td>
          <td>(</td>
          <td class="paramtype">hythread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resume a thread. 
<p>
Take a threads out of the suspended state.<p>
If the thread is not suspended, no action is taken.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>a thread to be resumed </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#0ba000154f47eec76edb925def58cdde" title="Create a new OS thread.">hythread_create</a>, <a class="el" href="hythread_8c.html#c30c411e1696f413b95eac6dd98ca219" title="Suspend the current thread.">hythread_suspend</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="56af01f204a5000e87402c01f2b5f4c5"></a><!-- doxytag: member="hythread.c::hythread_self" ref="56af01f204a5000e87402c01f2b5f4c5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hythread_t VMCALL hythread_self           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the hythread_t for the current thread. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Must be called only by an attached thread</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>hythread_t for the current thread</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#c292a646de9a5fb9c6aff68eb17b7c6e" title="Attach an OS thread to the threading library.">hythread_attach</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bb1b00af8b799a4b17d0c7b8952b8cb6"></a><!-- doxytag: member="hythread.c::hythread_set_priority" ref="bb1b00af8b799a4b17d0c7b8952b8cb6" args="(hythread_t thread, UDATA priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_set_priority           </td>
          <td>(</td>
          <td class="paramtype">hythread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UDATA&nbsp;</td>
          <td class="paramname"> <em>priority</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a thread's execution priority. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>a thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>Use the following symbolic constants for priorities:<br>
 HYTHREAD_PRIORITY_MAX<br>
 HYTHREAD_PRIORITY_USER_MAX<br>
 HYTHREAD_PRIORITY_NORMAL<br>
 HYTHREAD_PRIORITY_USER_MIN<br>
 HYTHREAD_PRIORITY_MIN<br>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success or negative value on failure (priority wasn't changed) </dd></dl>

</div>
</div><p>
<a class="anchor" name="2d8de4536ca01747a3ca3183bfe0d0ea"></a><!-- doxytag: member="hythread.c::hythread_shutdown" ref="2d8de4536ca01747a3ca3183bfe0d0ea" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VMCALL hythread_shutdown           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shut down the Hy threading library associated with the current thread. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#4c35b06eccb30a21507533284c3e0cbe" title="Initialize a Hy threading library.">hythread_init</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="69c3b263bda8bab91c7b6c3918326770"></a><!-- doxytag: member="hythread.c::hythread_sleep" ref="69c3b263bda8bab91c7b6c3918326770" args="(I_64 millis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_sleep           </td>
          <td>(</td>
          <td class="paramtype">I_64&nbsp;</td>
          <td class="paramname"> <em>millis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Suspend the current thread from executing for at least the specified time. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>millis</em>&nbsp;</td><td>minimum number of milliseconds to sleep </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success<br>
 HYTHREAD_INVALID_ARGUMENT if millis &lt; 0</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#eb4cad43850472b449b7c1ce43ea6fcb" title="Suspend the current thread from executing for at least the specified time.">hythread_sleep_interruptable</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="eb4cad43850472b449b7c1ce43ea6fcb"></a><!-- doxytag: member="hythread.c::hythread_sleep_interruptable" ref="eb4cad43850472b449b7c1ce43ea6fcb" args="(I_64 millis, IDATA nanos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_sleep_interruptable           </td>
          <td>(</td>
          <td class="paramtype">I_64&nbsp;</td>
          <td class="paramname"> <em>millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDATA&nbsp;</td>
          <td class="paramname"> <em>nanos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Suspend the current thread from executing for at least the specified time. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>millis</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nanos</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success<br>
 HYTHREAD_INVALID_ARGUMENT if the arguments are invalid<br>
 HYTHREAD_INTERRUPTED if the sleep was interrupted</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#69c3b263bda8bab91c7b6c3918326770" title="Suspend the current thread from executing for at least the specified time.">hythread_sleep</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c30c411e1696f413b95eac6dd98ca219"></a><!-- doxytag: member="hythread.c::hythread_suspend" ref="c30c411e1696f413b95eac6dd98ca219" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VMCALL hythread_suspend           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Suspend the current thread. 
<p>
Stop the current thread from executing until it is resumed.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#3dfcc6056d07ad8ccacfc985c5c2e4d2" title="Resume a thread.">hythread_resume</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3878100915ea0ea7c6bb8de4bfea7b92"></a><!-- doxytag: member="hythread.c::hythread_tls_alloc" ref="3878100915ea0ea7c6bb8de4bfea7b92" args="(hythread_tls_key_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_tls_alloc           </td>
          <td>(</td>
          <td class="paramtype">hythread_tls_key_t *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a thread local storage (TLS) key. 
<p>
Create and return a new, unique key for thread local storage.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The hande returned will be &gt;=0, so it is safe to test the handle against 0 to see if it's been allocated yet.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>pointer to a key to be initialized with a key value </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success or negative value if a key could not be allocated (i.e. all TLS has been allocated)</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#aa301e673550392ae72ef6bd57f6f3fe" title="Release a TLS key.">hythread_tls_free</a>, <a class="el" href="hythread_8c.html#e96c0ea2617bfd013a8ec01857cfb0fb" title="Set a thread&#39;s TLS value.">hythread_tls_set</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3fae4b2b7a5920a5b07e3fad94542824"></a><!-- doxytag: member="hythread.c::hythread_tls_alloc_with_finalizer" ref="3fae4b2b7a5920a5b07e3fad94542824" args="(hythread_tls_key_t *handle, hythread_tls_finalizer_t finalizer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_tls_alloc_with_finalizer           </td>
          <td>(</td>
          <td class="paramtype">hythread_tls_key_t *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hythread_tls_finalizer_t&nbsp;</td>
          <td class="paramname"> <em>finalizer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a thread local storage (TLS) key. 
<p>
Create and return a new, unique key for thread local storage.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The hande returned will be &gt;=0, so it is safe to test the handle against 0 to see if it's been allocated yet.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>pointer to a key to be initialized with a key value </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>a</em>&nbsp;</td><td>finalizer function which will be invoked when a thread is detached or terminates if the thread's TLS entry for this key is non-NULL </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success or negative value if a key could not be allocated (i.e. all TLS has been allocated)</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#aa301e673550392ae72ef6bd57f6f3fe" title="Release a TLS key.">hythread_tls_free</a>, <a class="el" href="hythread_8c.html#e96c0ea2617bfd013a8ec01857cfb0fb" title="Set a thread&#39;s TLS value.">hythread_tls_set</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="aa301e673550392ae72ef6bd57f6f3fe"></a><!-- doxytag: member="hythread.c::hythread_tls_free" ref="aa301e673550392ae72ef6bd57f6f3fe" args="(hythread_tls_key_t key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_tls_free           </td>
          <td>(</td>
          <td class="paramtype">hythread_tls_key_t&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release a TLS key. 
<p>
Release a TLS key previously allocated by hythread_tls_alloc.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>TLS key to be freed </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success or negative value on failure</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#3878100915ea0ea7c6bb8de4bfea7b92" title="Allocate a thread local storage (TLS) key.">hythread_tls_alloc</a>, <a class="el" href="hythread_8c.html#e96c0ea2617bfd013a8ec01857cfb0fb" title="Set a thread&#39;s TLS value.">hythread_tls_set</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e96c0ea2617bfd013a8ec01857cfb0fb"></a><!-- doxytag: member="hythread.c::hythread_tls_set" ref="e96c0ea2617bfd013a8ec01857cfb0fb" args="(hythread_t thread, hythread_tls_key_t key, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDATA VMCALL hythread_tls_set           </td>
          <td>(</td>
          <td class="paramtype">hythread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hythread_tls_key_t&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a thread's TLS value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>a thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>key to have TLS value set (any value returned by hythread_alloc) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>value to be stored in TLS </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success or negative value on failure</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#3878100915ea0ea7c6bb8de4bfea7b92" title="Allocate a thread local storage (TLS) key.">hythread_tls_alloc</a>, <a class="el" href="hythread_8c.html#aa301e673550392ae72ef6bd57f6f3fe" title="Release a TLS key.">hythread_tls_free</a>, <a class="el" href="hythreadinspect_8c.html#6d86d12d7f82a0040230eeaa84c133bb" title="Get a thread&#39;s thread local storage (TLS) value.">hythread_tls_get</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1a99b6715a51c0d13f5b0ad4ee00c954"></a><!-- doxytag: member="hythread.c::hythread_unpark" ref="1a99b6715a51c0d13f5b0ad4ee00c954" args="(hythread_t thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VMCALL hythread_unpark           </td>
          <td>(</td>
          <td class="paramtype">hythread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
'Unpark' the specified thread. 
<p>
If the thread is parked, it will return from park. If the thread is not parked, its 'UNPARKED' flag will be set, and it will return immediately the next time it is parked.<p>
Note that unparks are not counted. Unparking a thread once is the same as unparking it n times.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#da1c3e3c78e868b84925205467b3655a" title="&#39;Park&#39; the current thread.">hythread_park</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ec8bcfb886dbf1685136b7407d875821"></a><!-- doxytag: member="hythread.c::hythread_yield" ref="ec8bcfb886dbf1685136b7407d875821" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VMCALL hythread_yield           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Yield the processor. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<hr size="1">
<address style="text-align: center;">
  <small>
    <p>Genereated on Tue Dec 9 14:13:00 2008 by Doxygen.</p>
    <p>(c) Copyright 2005, 2008 The Apache Software Foundation or its licensors, as applicable. </p>
  </small>
</address>
</body>
</html>
