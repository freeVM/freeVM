<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Harmony Class Library Porting: modules/portlib/src/main/native/port/windows/hysock.c File Reference</title>
<link href="hydoxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1>modules/portlib/src/main/native/port/windows/hysock.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Sockets. 
<p>

<p>
<code>#include &quot;hysock.h&quot;</code><br>
<code>#include &quot;portpriv.h&quot;</code><br>
<code>#include &quot;<a class="el" href="hyportptb_8h.html">hyportptb.h</a>&quot;</code><br>
<code>#include &lt;Iphlpapi.h&gt;</code><br>
<code>#include &lt;limits.h&gt;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#ae13cf34894846118c7a0609e81b38ee">hysock_accept</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t serverSock, hysockaddr_t addrHandle, hysocket_t *sockHandle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The accept function extracts the first connection on the queue of pending connections on socket sock.  <a href="#ae13cf34894846118c7a0609e81b38ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#b6afb5eea148a86fdf2bae2b2d1e302b">hysock_bind</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t sock, hysockaddr_t addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The bind function is used on an unconnected socket before subsequent calls to the connect or listen functions.  <a href="#b6afb5eea148a86fdf2bae2b2d1e302b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#ca818a06ddea3479122cb0b06e5040c0">hysock_close</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t *sock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The close function closes a socket.  <a href="#ca818a06ddea3479122cb0b06e5040c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#b077b18e14f5feee3630f66de9611568">hysock_connect</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t sock, hysockaddr_t addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Establish a connection to a peer.  <a href="#b077b18e14f5feee3630f66de9611568"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#271e3241ead87c721fa2ac8026d8ddd2">hysock_error_message</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an error message describing the last OS error that occurred.  <a href="#271e3241ead87c721fa2ac8026d8ddd2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#281128bbd19151422ac9a7b6ed944fa4">hysock_fdset_init</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t socketP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a file descriptor (FD) set of one element.  <a href="#281128bbd19151422ac9a7b6ed944fa4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#2548eaa487929dda50d383c672213b60">hysock_fdset_size</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the maximum size of the fdset currently declared for the platform.  <a href="#2548eaa487929dda50d383c672213b60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#544872a0448445d1854e94fef025f13c">hysock_freeaddrinfo</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, <a class="el" href="structhyaddrinfo__struct.html">hyaddrinfo_t</a> handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees the memory created by the call to hysock_getaddrinfo().  <a href="#544872a0448445d1854e94fef025f13c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, char *name, <a class="el" href="structhyaddrinfo__struct.html">hyaddrinfo_t</a> hints, <a class="el" href="structhyaddrinfo__struct.html">hyaddrinfo_t</a> result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answers a list of addresses as an opaque pointer in "result".  <a href="#1fab59a4046e236edcf44e229d49bd9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#28c4b1e46e6b67b26daa2741f827264d">hysock_getaddrinfo_address</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, <a class="el" href="structhyaddrinfo__struct.html">hyaddrinfo_t</a> handle, U_8 *address, int index, U_32 *scope_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answers a U_8 array representing the address at "index" in the structure returned from <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>, indexed starting at 0.  <a href="#28c4b1e46e6b67b26daa2741f827264d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#01359cd4085f42211e8d7ddf568a90fa">hysock_getaddrinfo_create_hints</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, <a class="el" href="structhyaddrinfo__struct.html">hyaddrinfo_t</a> *result, I_16 family, I_32 socktype, I_32 protocol, I_32 flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answers a hints structure as an opaque pointer in "result".  <a href="#01359cd4085f42211e8d7ddf568a90fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#68c83f4d575af83653b57d06f28c2fac">hysock_getaddrinfo_family</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, <a class="el" href="structhyaddrinfo__struct.html">hyaddrinfo_t</a> handle, I_32 *family, int index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answers the family type of the address at "index" in the structure returned from <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>, indexed starting at 0.  <a href="#68c83f4d575af83653b57d06f28c2fac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#d62ad7c02c2dbd967c0c75756291cf43">hysock_getaddrinfo_length</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, <a class="el" href="structhyaddrinfo__struct.html">hyaddrinfo_t</a> handle, I_32 *length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answers the number of results returned from <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>.  <a href="#d62ad7c02c2dbd967c0c75756291cf43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#8a5ad014c0f4a682201b7a0dbc7d24ad">hysock_getaddrinfo_name</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, <a class="el" href="structhyaddrinfo__struct.html">hyaddrinfo_t</a> handle, char *name, int index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answers the cannon name of the address at "index" in the structure returned from <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>, indexed starting at 0.  <a href="#8a5ad014c0f4a682201b7a0dbc7d24ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#ab4c59a475575b34d16d84924c5dd7d3">hysock_gethostbyaddr</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, char *addr, I_32 length, I_32 type, hyhostent_t handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer information on the host referred to by the address.  <a href="#ab4c59a475575b34d16d84924c5dd7d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#d26c72f38bb36305896cfc7fc40f3ff2">hysock_gethostbyname</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, char *name, hyhostent_t handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer information on the host, specified by name.  <a href="#d26c72f38bb36305896cfc7fc40f3ff2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#52a6a1e72a64a78cce2a847c0e4d686d">hysock_gethostname</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, char *buffer, I_32 length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the name of the local host machine.  <a href="#52a6a1e72a64a78cce2a847c0e4d686d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#7475a81399e6844f403f1e487a1f4904">hysock_getnameinfo</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysockaddr_t in_addr, I_32 sockaddr_size, char *name, I_32 name_length, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answers the host name of the "in_addr" in a preallocated buffer.  <a href="#7475a81399e6844f403f1e487a1f4904"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#cfac5b0f2cde6bf42686a7cb876ca0b1">hysock_getopt_bool</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, BOOLEAN *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the value of the nominated boolean socket option.  <a href="#cfac5b0f2cde6bf42686a7cb876ca0b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#c559064d0edce181e9c9e9aaa298f834">hysock_getopt_byte</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, U_8 *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the value of the nominated byte socket option.  <a href="#c559064d0edce181e9c9e9aaa298f834"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#3d0f9615328e1f237881ad222e6d0011">hysock_getopt_int</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, I_32 *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the value of the nominated integer socket option.  <a href="#3d0f9615328e1f237881ad222e6d0011"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#905ee058073665eadfd54bb30478bdeb">hysock_getopt_linger</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, hylinger_t optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the value of the socket linger option.  <a href="#905ee058073665eadfd54bb30478bdeb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#04e33f5b905422886aadcab2d88d9ff2">hysock_getopt_sockaddr</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, hysockaddr_t optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the value of the socket option, an address struct.  <a href="#04e33f5b905422886aadcab2d88d9ff2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#3fc5e035fde3118881ed6ced523fdd82">hysock_getpeername</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t handle, hysockaddr_t addrHandle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the remote name for the socket.  <a href="#3fc5e035fde3118881ed6ced523fdd82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#4b6ff6913870ffab8d65cc31601473a0">hysock_getsockname</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t handle, hysockaddr_t addrHandle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the local name for the socket.  <a href="#4b6ff6913870ffab8d65cc31601473a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#063d2969a7a366897e83da5109626a53">hysock_hostent_addrlist</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hyhostent_t handle, U_32 index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the nominated element of the address list within the argument hostent struct.  <a href="#063d2969a7a366897e83da5109626a53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#66fe7abe94ba34705e78d9247ae3efa5">hysock_hostent_aliaslist</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hyhostent_t handle, char ***aliasList)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer a reference to the list of alternative names for the host within the argument hostent struct.  <a href="#66fe7abe94ba34705e78d9247ae3efa5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#ea43182c98226d1a8f8a14b4f85b1056">hysock_hostent_hostname</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hyhostent_t handle, char **hostName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the host name (string) within the argument hostent struct.  <a href="#ea43182c98226d1a8f8a14b4f85b1056"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#21a80d039021a32c83b743fe4c000925">hysock_htonl</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, I_32 val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the 32 bit host ordered argument, in network byte order.  <a href="#21a80d039021a32c83b743fe4c000925"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U_16 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#e90cb83bf8c9e8d89089e54930f3a32a">hysock_htons</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, U_16 val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the 16 bit host ordered argument, in network byte order.  <a href="#e90cb83bf8c9e8d89089e54930f3a32a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#a5a4b18bfeaef226f240402058c12a57">hysock_inetaddr</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, char *addrStr, U_32 *addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the dotted IP string as an Internet address.  <a href="#a5a4b18bfeaef226f240402058c12a57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#aee92b509cabaa741e432e7c04ef5dd6">hysock_inetntoa</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, char **addrStr, U_32 nipAddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the Internet address as a dotted IP string.  <a href="#aee92b509cabaa741e432e7c04ef5dd6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#b9fcd0c28e7d5416696e73abd7036b4b">hysock_ipmreq_init</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hyipmreq_t handle, U_32 nipmcast, U_32 nipinterface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes a new multicast membership structure.  <a href="#b9fcd0c28e7d5416696e73abd7036b4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#c45e677914d4c32c03b06d1614270941">hysock_ipv6_mreq_init</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hyipv6_mreq_t handle, U_8 *ipmcast_addr, U_32 ipv6mr_interface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills in a preallocated hyipv6_mreq_struct.  <a href="#c45e677914d4c32c03b06d1614270941"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#2b8842b0fecc9345edd7ae78b68bd80b">hysock_linger_enabled</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hylinger_t handle, BOOLEAN *enabled)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer true if the linger is enabled in the argument linger struct.  <a href="#2b8842b0fecc9345edd7ae78b68bd80b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#b23a5d72227ea8b6b70717892b48d894">hysock_linger_init</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hylinger_t handle, I_32 enabled, U_16 timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes a new linger structure, enabled or disabled, with the timeout as specified.  <a href="#b23a5d72227ea8b6b70717892b48d894"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#e654004478602ef80daab7f2007ce0a5">hysock_linger_linger</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hylinger_t handle, U_16 *linger)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the linger timeout value in the argument linger struct.  <a href="#e654004478602ef80daab7f2007ce0a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#c41f0f9146374eaeee49162fe6d2c969">hysock_listen</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t sock, I_32 backlog)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the socket to listen for incoming connection requests.  <a href="#c41f0f9146374eaeee49162fe6d2c969"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#19382da111b422bc7e6e48070a640d46">hysock_ntohl</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, I_32 val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the 32 bit network ordered argument, in host byte order.  <a href="#19382da111b422bc7e6e48070a640d46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U_16 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#cfb7a3e2540f0054491c6da1631dbeac">hysock_ntohs</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, U_16 val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the 16-bit network ordered argument, in host byte order.  <a href="#cfb7a3e2540f0054491c6da1631dbeac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#fd379791b30d2d696ae062a110c678b1">hysock_read</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t sock, U_8 *buf, I_32 nbyte, I_32 flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The read function receives data from a connected socket.  <a href="#fd379791b30d2d696ae062a110c678b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#49253e3ab0dfd567d15faceb87d18851">hysock_readfrom</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t sock, U_8 *buf, I_32 nbyte, I_32 flags, hysockaddr_t addrHandle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The read function receives data from a possibly connected socket.  <a href="#49253e3ab0dfd567d15faceb87d18851"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#0c4692a035e02b931c802a2d0634df8f">hysock_select</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, I_32 nfds, hyfdset_t readfds, hyfdset_t writefds, hyfdset_t exceptfds, hytimeval_t timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The select function allows the state of sockets for read &amp; write operations and exceptional conditions to be tested.  <a href="#0c4692a035e02b931c802a2d0634df8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#6c9fc0850a29b453d6b46cbb26a072bb">hysock_select_read</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t hysocketP, I_32 secTime, I_32 uSecTime, BOOLEAN accept)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper method, to ensure a read operation can be performed without blocking.  <a href="#6c9fc0850a29b453d6b46cbb26a072bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#9e9d12ba6bd504ff502d38d77b204453">hysock_set_nonblocking</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t socketP, BOOLEAN nonblocking)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the nonblocking state of the socket.  <a href="#9e9d12ba6bd504ff502d38d77b204453"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#c25e085d41a5052f3e88129fdc8d5226">hysock_setflag</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, I_32 flag, I_32 *arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensure the flag designated is set in the argument.  <a href="#c25e085d41a5052f3e88129fdc8d5226"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#8e5d7661767cf61343fda3a6053d80c7">hysock_setopt_bool</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, BOOLEAN *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the value of the nominated boolean socket option.  <a href="#8e5d7661767cf61343fda3a6053d80c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#d88c2999652e0facc3d7a3a665479a22">hysock_setopt_byte</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, U_8 *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the value of the nominated byte socket option.  <a href="#d88c2999652e0facc3d7a3a665479a22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#538e8623b0fb3524acc83d7c48f504f2">hysock_setopt_int</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, I_32 *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the value of the nominated integer socket option.  <a href="#538e8623b0fb3524acc83d7c48f504f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#024f784bb0e43ecb6924808516d31cf2">hysock_setopt_ipmreq</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, hyipmreq_t optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the multicast request on this socket.  <a href="#024f784bb0e43ecb6924808516d31cf2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#394df1269da1dad9765bab1ac003e196">hysock_setopt_ipv6_mreq</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, hyipv6_mreq_t optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the multicast request on this socket for IPv6 sockets.  <a href="#394df1269da1dad9765bab1ac003e196"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#c42601d071303441c34debdc4981b7ec">hysock_setopt_linger</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, hylinger_t optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the linger value on the socket.  <a href="#c42601d071303441c34debdc4981b7ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#e3b74b1133f0703175d7cd005306c3bd">hysock_setopt_sockaddr</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, hysockaddr_t optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sockaddr for the socket.  <a href="#e3b74b1133f0703175d7cd005306c3bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#31acd9bb9f07e31c2e5e7716f5c23608">hysock_shutdown</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Terminates use of the socket library.  <a href="#31acd9bb9f07e31c2e5e7716f5c23608"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#fa366e01ee07266f38038d6e26cc1aa8">hysock_shutdown_input</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t sock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The shutdown_input function disables the input stream on a socket.  <a href="#fa366e01ee07266f38038d6e26cc1aa8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#6c7af585ec65bfb2c3b08d92ae4b1bc2">hysock_shutdown_output</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t sock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The shutdown_output function disables the output stream on a socket.  <a href="#6c7af585ec65bfb2c3b08d92ae4b1bc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#130ecd89ccfeb402466065bbbf9c4f6d">hysock_sockaddr</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysockaddr_t handle, char *addrStr, U_16 port)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new hysockaddr, refering to the specified port and address.  <a href="#130ecd89ccfeb402466065bbbf9c4f6d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#33f0d799e4ff79c0b0aaaa0e920af7e2">hysock_sockaddr_address</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysockaddr_t handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the address, in network order, of the hysockaddr argument.  <a href="#33f0d799e4ff79c0b0aaaa0e920af7e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#e591fde7d4a84a1fee3d7e14c4a31edb">hysock_sockaddr_address6</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysockaddr_t handle, U_8 *address, U_32 *length, U_32 *scope_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answers the IP address of a structure and its length, in a preallocated buffer.  <a href="#e591fde7d4a84a1fee3d7e14c4a31edb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#f8fcfecdd832c99f951a3ff8eee09fb0">hysock_sockaddr_family</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, I_16 *family, hysockaddr_t handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answers the family name of a hysockaddr_struct.  <a href="#f8fcfecdd832c99f951a3ff8eee09fb0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#8835b4fd8141990fc1d2af2eab4c63e5">hysock_sockaddr_init</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysockaddr_t handle, I_16 family, U_32 nipAddr, U_16 nPort)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new hysockaddr, refering to the specified port and address.  <a href="#8835b4fd8141990fc1d2af2eab4c63e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#1c311bcb59483f6247c97a6a82fef9af">hysock_sockaddr_init6</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysockaddr_t handle, U_8 *addr, I_32 addrlength, I_16 family, U_16 nPort, U_32 flowinfo, U_32 scope_id, hysocket_t sock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answers an initialized hysockaddr_struct structure.  <a href="#1c311bcb59483f6247c97a6a82fef9af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U_16 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#0d811111835a9c99d5af6a2e09430f64">hysock_sockaddr_port</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysockaddr_t handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Answer the port, in network order, of the hysockaddr argument.  <a href="#0d811111835a9c99d5af6a2e09430f64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#564cbca4fcf0fdcfabb47d4fe0746a61">hysock_socket</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t *handle, I_32 family, I_32 socktype, I_32 protocol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new socket descriptor and any related resources.  <a href="#564cbca4fcf0fdcfabb47d4fe0746a61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#668aafc1a42d8d5f7c7885b1d55e8176">hysock_socketIsValid</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether or not the socket is valid.  <a href="#668aafc1a42d8d5f7c7885b1d55e8176"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#f85cbe3aab713a46bae6d45919390d4a">hysock_startup</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initiate the use of sockets by a process.  <a href="#f85cbe3aab713a46bae6d45919390d4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#716d94b9f5af022e9e36a8c11bcaf8eb">hysock_timeval_init</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, U_32 secTime, U_32 uSecTime, hytimeval_t timeP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a time structure, representing the timeout period defined in seconds &amp; microSeconds.  <a href="#716d94b9f5af022e9e36a8c11bcaf8eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#b2461da5b68eef2c7e12f0b041c66b4e">hysock_write</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t sock, U_8 *buf, I_32 nbyte, I_32 flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The write function writes data to a connected socket.  <a href="#b2461da5b68eef2c7e12f0b041c66b4e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#13bf3e15e0daa798996eb8e3e32aa7c9">hysock_writeto</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t sock, U_8 *buf, I_32 nbyte, I_32 flags, hysockaddr_t addrHandle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The writeto function writes data to a datagram socket.  <a href="#13bf3e15e0daa798996eb8e3e32aa7c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#8800cf8c33d178f1b6ade709f5c293e7">hysock_get_network_interfaces</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, struct hyNetworkInterfaceArray_struct *array, BOOLEAN preferIPv4Stack)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries and returns the information for the network interfaces that are currently active within the system.  <a href="#8800cf8c33d178f1b6ade709f5c293e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#357c89d770770a0213fd8948376e9163">hysock_free_network_interface_struct</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, struct hyNetworkInterfaceArray_struct *array)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees the memory allocated for the hyNetworkInterface_struct array passed in.  <a href="#357c89d770770a0213fd8948376e9163"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">I_32 VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hysock_8c.html#9aa9c9195bd2c912ed9d2940839cefc2">hysock_connect_with_timeout</a> (struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary, hysocket_t sock, hysockaddr_t addr, U_32 timeout, U_32 step, U_8 **context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Establish a connection to a peer with a timeout.  <a href="#9aa9c9195bd2c912ed9d2940839cefc2"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ae13cf34894846118c7a0609e81b38ee"></a><!-- doxytag: member="hysock.c::hysock_accept" ref="ae13cf34894846118c7a0609e81b38ee" args="(struct HyPortLibrary *portLibrary, hysocket_t serverSock, hysockaddr_t addrHandle, hysocket_t *sockHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_accept           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>serverSock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>addrHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t *&nbsp;</td>
          <td class="paramname"> <em>sockHandle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The accept function extracts the first connection on the queue of pending connections on socket sock. 
<p>
It then creates a new socket and returns a handle to the new socket. The newly created socket is the socket that will handle the actual the connection and has the same properties as socket sock.<p>
The accept function can block the caller until a connection is present if no pending connections are present on the queue.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>serverSock</em>&nbsp;</td><td>A hysocket_t from which data will be read. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addrHandle</em>&nbsp;</td><td>An optional pointer to a buffer that receives the address of the connecting entity, as known to the communications layer. The exact format of the addr parameter is determined by the address family established when the socket was created. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sockHandle</em>&nbsp;</td><td>A pointer to a hysocket_t which will point to the newly created socket once accept returns successfully</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success </li>
<li>HYPORT_ERROR_SOCKET_BADSOCKET, on generic error </li>
<li>HYPORT_ERROR_SOCKET_NOTINITIALIZED, if socket library uninitialized </li>
<li>HYPORT_ERROR_SOCKET_INTERRUPTED, the call was cancelled </li>
<li>HYPORT_ERROR_SOCKET_ADDRNOTAVAIL, the addr parameter is not valid </li>
<li>HYPORT_ERROR_SOCKET_SYSTEMBUSY, if system busy handling other requests </li>
<li>HYPORT_ERROR_SOCKET_SYSTEMFULL, is too many sockets are active </li>
<li>HYPORT_ERROR_SOCKET_WOULDBLOCK, the socket is marked as nonblocking and no connections are present to be accepted., </li>
</ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="b6afb5eea148a86fdf2bae2b2d1e302b"></a><!-- doxytag: member="hysock.c::hysock_bind" ref="b6afb5eea148a86fdf2bae2b2d1e302b" args="(struct HyPortLibrary *portLibrary, hysocket_t sock, hysockaddr_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_bind           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The bind function is used on an unconnected socket before subsequent calls to the connect or listen functions. 
<p>
When a socket is created with a call to the socket function, it exists in a name space (address family), but it has no name assigned to it. Use bind to establish the local association of the socket by assigning a local name to an unnamed socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>hysocket_t which will be be associated with the specified name. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>Address to bind to socket.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0, on success </li>
<li>HYPORT_ERROR_SOCKET_BADSOCKET, on generic error </li>
<li>HYPORT_ERROR_SOCKET_NOTINITIALIZED, if socket library uninitialized </li>
<li>HYPORT_ERROR_SOCKET_ADDRINUSE A process on the machine is already bound to the same fully-qualified address and the socket has not been marked to allow address re-use with SO_REUSEADDR. </li>
<li>HYPORT_ERROR_SOCKET_ADDRNOTAVAIL The specified address is not a valid address for this machine </li>
<li>HYPORT_ERROR_SOCKET_SYSTEMBUSY, if system busy handling other requests </li>
<li>HYPORT_ERROR_SOCKET_SYSTEMFULL, is too many sockets are active </li>
<li>HYPORT_ERROR_SOCKET_BADADDR, the addr parameter is not a valid part of the user address space, </li>
</ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="ca818a06ddea3479122cb0b06e5040c0"></a><!-- doxytag: member="hysock.c::hysock_close" ref="ca818a06ddea3479122cb0b06e5040c0" args="(struct HyPortLibrary *portLibrary, hysocket_t *sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_close           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t *&nbsp;</td>
          <td class="paramname"> <em>sock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The close function closes a socket. 
<p>
Use it to release the socket descriptor socket so further references to socket will fail.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>hysocket_t which will be closed.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0, on success </li>
<li>HYPORT_ERROR_SOCKET_BADSOCKET, on generic error </li>
<li>HYPORT_ERROR_SOCKET_SYSTEMBUSY, if system busy handling other requests </li>
<li>HYPORT_ERROR_SOCKET_WOULDBLOCK, the socket is marked as nonblocking and SO_LINGER is set to a nonzero time-out value. </li>
</ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="b077b18e14f5feee3630f66de9611568"></a><!-- doxytag: member="hysock.c::hysock_connect" ref="b077b18e14f5feee3630f66de9611568" args="(struct HyPortLibrary *portLibrary, hysocket_t sock, hysockaddr_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_connect           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Establish a connection to a peer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>pointer to the unconnected local socket. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>pointer to the sockaddr, specifying remote host/port.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9aa9c9195bd2c912ed9d2940839cefc2"></a><!-- doxytag: member="hysock.c::hysock_connect_with_timeout" ref="9aa9c9195bd2c912ed9d2940839cefc2" args="(struct HyPortLibrary *portLibrary, hysocket_t sock, hysockaddr_t addr, U_32 timeout, U_32 step, U_8 **context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_connect_with_timeout           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_8 **&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Establish a connection to a peer with a timeout. 
<p>
This function is called repeatedly in order to carry out the connect and to allow other tasks to proceed on certain platforms. The caller must first call with step = HY_SOCK_STEP_START, if the result is HY_ERROR_SOCKET_NOTCONNECTED it will then call it with step = CHECK until either another error or 0 is returned to indicate the connect is complete. Each time the function should sleep for no more than timeout milliseconds. If the connect succeeds or an error occurs, the caller must always end the process by calling the function with step = HY_SOCK_STEP_DONE<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>pointer to the unconnected local socket. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>pointer to the sockaddr, specifying remote host/port. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>timeout in milliseconds. If timeout is negative, perform a block operation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>step</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>pointer to context pointer. Filled in on first call and then to be passed into each subsequent call</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="271e3241ead87c721fa2ac8026d8ddd2"></a><!-- doxytag: member="hysock.c::hysock_error_message" ref="271e3241ead87c721fa2ac8026d8ddd2" args="(struct HyPortLibrary *portLibrary)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* VMCALL hysock_error_message           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return an error message describing the last OS error that occurred. 
<p>
The last error returned is not thread safe, it may not be related to the operation that failed for this thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>error message describing the last OS error, may return NULL. </dd></dl>

</div>
</div><p>
<a class="anchor" name="281128bbd19151422ac9a7b6ed944fa4"></a><!-- doxytag: member="hysock.c::hysock_fdset_init" ref="281128bbd19151422ac9a7b6ed944fa4" args="(struct HyPortLibrary *portLibrary, hysocket_t socketP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_fdset_init           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>socketP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a file descriptor (FD) set of one element. 
<p>
The call may not be generally useful, as it currently only supports a single FD and is assumed to be used in conjunction with the hysock_select function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketP</em>&nbsp;</td><td>pointer to the socket to be added to the FD set.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2548eaa487929dda50d383c672213b60"></a><!-- doxytag: member="hysock.c::hysock_fdset_size" ref="2548eaa487929dda50d383c672213b60" args="(struct HyPortLibrary *portLibrary, hysocket_t handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_fdset_size           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the maximum size of the fdset currently declared for the platform. 
<p>
This value is a parameter of the <a class="el" href="hysock_8c.html#0c4692a035e02b931c802a2d0634df8f">hysock_select</a> call.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the maximum size of the fdset, otherwise the (negative) error code.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>On Unix, the value was the maximum file descriptor plus one, although on many flavors, the value is ignored in the select function. It is essential on Neutrino 2.0. On Windows, the value is ignored by the select function. On OS/2, the value is the number of file descriptors to be checked. </dd></dl>

</div>
</div><p>
<a class="anchor" name="357c89d770770a0213fd8948376e9163"></a><!-- doxytag: member="hysock.c::hysock_free_network_interface_struct" ref="357c89d770770a0213fd8948376e9163" args="(struct HyPortLibrary *portLibrary, struct hyNetworkInterfaceArray_struct *array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_free_network_interface_struct           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct hyNetworkInterfaceArray_struct *&nbsp;</td>
          <td class="paramname"> <em>array</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees the memory allocated for the hyNetworkInterface_struct array passed in. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>array</em>&nbsp;</td><td>Pointer to array of network interface structures to be freed</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success </dd></dl>

</div>
</div><p>
<a class="anchor" name="544872a0448445d1854e94fef025f13c"></a><!-- doxytag: member="hysock.c::hysock_freeaddrinfo" ref="544872a0448445d1854e94fef025f13c" args="(struct HyPortLibrary *portLibrary, hyaddrinfo_t handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_freeaddrinfo           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhyaddrinfo__struct.html">hyaddrinfo_t</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees the memory created by the call to hysock_getaddrinfo(). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Hints on what results are returned and how the response if formed .</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Added for IPv6 support. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8800cf8c33d178f1b6ade709f5c293e7"></a><!-- doxytag: member="hysock.c::hysock_get_network_interfaces" ref="8800cf8c33d178f1b6ade709f5c293e7" args="(struct HyPortLibrary *portLibrary, struct hyNetworkInterfaceArray_struct *array, BOOLEAN preferIPv4Stack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_get_network_interfaces           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct hyNetworkInterfaceArray_struct *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN&nbsp;</td>
          <td class="paramname"> <em>preferIPv4Stack</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queries and returns the information for the network interfaces that are currently active within the system. 
<p>
Applications are responsible for freeing the memory returned via the handle.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>array</em>&nbsp;</td><td>Pointer to structure with array of network interface entries </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>preferIPv4Stack</em>&nbsp;</td><td>boolean which indicates if we should prefer the IPv4 stack or not</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of elements in handle on success, negatvie portable error code on failure. -WSANO_RECOVERY if system calls required to get the info fail, -WSAENOBUFS if memory allocation fails </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A return value of 0 indicates no interfaces exist </dd></dl>

</div>
</div><p>
<a class="anchor" name="1fab59a4046e236edcf44e229d49bd9e"></a><!-- doxytag: member="hysock.c::hysock_getaddrinfo" ref="1fab59a4046e236edcf44e229d49bd9e" args="(struct HyPortLibrary *portLibrary, char *name, hyaddrinfo_t hints, hyaddrinfo_t result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_getaddrinfo           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhyaddrinfo__struct.html">hyaddrinfo_t</a>&nbsp;</td>
          <td class="paramname"> <em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhyaddrinfo__struct.html">hyaddrinfo_t</a>&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answers a list of addresses as an opaque pointer in "result". 
<p>
Use the following functions to extract the details: <ul>
<li><a class="el" href="hysock_8c.html#d62ad7c02c2dbd967c0c75756291cf43">hysock_getaddrinfo_length</a> </li>
<li><a class="el" href="hysock_8c.html#8a5ad014c0f4a682201b7a0dbc7d24ad">hysock_getaddrinfo_name</a> </li>
<li><a class="el" href="hysock_8c.html#28c4b1e46e6b67b26daa2741f827264d">hysock_getaddrinfo_address</a> </li>
<li><a class="el" href="hysock_8c.html#68c83f4d575af83653b57d06f28c2fac">hysock_getaddrinfo_family</a></li>
</ul>
If the machine type supports IPv6 you can specify how you want the results returned with the following function: <ul>
<li>hysock_create_getaddrinfo_hints. Passing the structure into a machine with only IPv4 support will have no effect.</li>
</ul>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the host in either host name format or in IPv4 or IPv6 accepted notations. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hints</em>&nbsp;</td><td>Hints on what results are returned and how the response if formed (can be NULL for default action). </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>result</em>&nbsp;</td><td>An opaque pointer to a list of results (<a class="el" href="structhyaddrinfo__struct.html" title="structure for IPv6 addrinfo will either point to a hostent or an addr info depending...">hyaddrinfo_struct</a> must be preallocated).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>you must free the "result" structure with <a class="el" href="hysock_8c.html#544872a0448445d1854e94fef025f13c">hysock_freeaddrinfo</a> to free up memory. This must be done before you make a subsequent call in the same thread to this function. <p>
Added for IPv6 support. </dd></dl>

</div>
</div><p>
<a class="anchor" name="28c4b1e46e6b67b26daa2741f827264d"></a><!-- doxytag: member="hysock.c::hysock_getaddrinfo_address" ref="28c4b1e46e6b67b26daa2741f827264d" args="(struct HyPortLibrary *portLibrary, hyaddrinfo_t handle, U_8 *address, int index, U_32 *scope_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_getaddrinfo_address           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhyaddrinfo__struct.html">hyaddrinfo_t</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_8 *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32 *&nbsp;</td>
          <td class="paramname"> <em>scope_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answers a U_8 array representing the address at "index" in the structure returned from <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>, indexed starting at 0. 
<p>
The address is in network byte order.<p>
The address will either be 4 or 16 bytes depending on whether it is an OS_AF_INET address or an OS_AF_INET6 address. You can check this will a call to <a class="el" href="hysock_8c.html#68c83f4d575af83653b57d06f28c2fac">hysock_getaddrinfo_family</a>. Therefore you should either check the family type before preallocating the "address" or define it as 16 bytes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>The result structure returned by <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>The address at "index" in a preallocated buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The address index into the structure returned by <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>scope_id</em>&nbsp;</td><td>The scope id associated with the address if applicable</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0, if no errors occurred, otherwise the (negative) error code </li>
<li>HYPORT_ERROR_SOCKET_VALUE_NULL when we have have the old IPv4 gethostbyname call and the address indexed is out of range. This is because the address list and the host alias list are not the same length. Just skip this entry.</li>
</ul>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Added for IPv6 support. </dd></dl>

</div>
</div><p>
<a class="anchor" name="01359cd4085f42211e8d7ddf568a90fa"></a><!-- doxytag: member="hysock.c::hysock_getaddrinfo_create_hints" ref="01359cd4085f42211e8d7ddf568a90fa" args="(struct HyPortLibrary *portLibrary, hyaddrinfo_t *result, I_16 family, I_32 socktype, I_32 protocol, I_32 flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_getaddrinfo_create_hints           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhyaddrinfo__struct.html">hyaddrinfo_t</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_16&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>socktype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answers a hints structure as an opaque pointer in "result". 
<p>
This hints structure is used to modify the results returned by a call to <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>. There is one of these structures per thread, so subsequent calls to this function will overwrite the same structure in memory. The structure is cached in ptBuffers and is cleared when a call to hyport_free_ptBuffer is made.<p>
This function is only works on IPv6 supported OS's. If it is called on an OS that does not support IPv6 then it essentially returns a NULL pointer, meaning it will have no effect on the call to <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>.<p>
See man pages, or MSDN doc on getaddrinfo for information on how the hints structure works.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>result</em>&nbsp;</td><td>The filled in (per thread) hints structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>A address family type </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socktype</em>&nbsp;</td><td>A socket type </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>protocol</em>&nbsp;</td><td>A protocol family </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags for modifying the result</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0, if no errors occurred, otherwise the (negative) error code </li>
<li>HYPORT_ERROR_SOCKET_SYSTEMFULL -- when we can't allocate memory for the ptBuffers, or the hints structure</li>
</ul>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>current supported family types are: <ul>
<li>HYADDR_FAMILY_UNSPEC </li>
<li>HYADDR_FAMILY_AFINET4 </li>
<li>HYADDR_FAMILY_AFINET6</li>
</ul>
<p>
Added for IPv6 support. </dd></dl>

</div>
</div><p>
<a class="anchor" name="68c83f4d575af83653b57d06f28c2fac"></a><!-- doxytag: member="hysock.c::hysock_getaddrinfo_family" ref="68c83f4d575af83653b57d06f28c2fac" args="(struct HyPortLibrary *portLibrary, hyaddrinfo_t handle, I_32 *family, int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_getaddrinfo_family           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhyaddrinfo__struct.html">hyaddrinfo_t</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32 *&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answers the family type of the address at "index" in the structure returned from <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>, indexed starting at 0. 
<p>
Currently the family types we support are HYSOCK_AFINET and HYSOCK_AFINET6.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>The result structure returned by <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>The family at "index". </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The address index into the structure returned by <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Added for IPv6 support. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d62ad7c02c2dbd967c0c75756291cf43"></a><!-- doxytag: member="hysock.c::hysock_getaddrinfo_length" ref="d62ad7c02c2dbd967c0c75756291cf43" args="(struct HyPortLibrary *portLibrary, hyaddrinfo_t handle, I_32 *length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_getaddrinfo_length           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhyaddrinfo__struct.html">hyaddrinfo_t</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32 *&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answers the number of results returned from <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>The result structure returned by <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The number of results.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Added for IPv6 support. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a5ad014c0f4a682201b7a0dbc7d24ad"></a><!-- doxytag: member="hysock.c::hysock_getaddrinfo_name" ref="8a5ad014c0f4a682201b7a0dbc7d24ad" args="(struct HyPortLibrary *portLibrary, hyaddrinfo_t handle, char *name, int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_getaddrinfo_name           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhyaddrinfo__struct.html">hyaddrinfo_t</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answers the cannon name of the address at "index" in the structure returned from <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>, indexed starting at 0. 
<p>
The preallocated buffer for "name" should be the size of the maximum host name: OSNIMAXHOST.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>The result structure returned by <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the address at "index" in a preallocated buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The address index into the structure returned by <a class="el" href="hysock_8c.html#1fab59a4046e236edcf44e229d49bd9e">hysock_getaddrinfo</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0, if no errors occurred, otherwise the (negative) error code. </li>
<li>HYPORT_ERROR_SOCKET_VALUE_NULL when we have have the old IPv4 gethostbyname call and the name indexed is out of range. This is because the address list and the host alias list are not the same length. Just skip this entry.</li>
</ul>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Added for IPv6 support. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ab4c59a475575b34d16d84924c5dd7d3"></a><!-- doxytag: member="hysock.c::hysock_gethostbyaddr" ref="ab4c59a475575b34d16d84924c5dd7d3" args="(struct HyPortLibrary *portLibrary, char *addr, I_32 length, I_32 type, hyhostent_t handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_gethostbyaddr           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hyhostent_t&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer information on the host referred to by the address. 
<p>
The information includes name, aliases and addresses for the nominated host (the latter being relevant on multi-homed hosts). This call has only been tested for addresses of type AF_INET.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>Pointer to the binary-format (not null-terminated) address, in network byte order. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>Length of the addr. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The type of the addr. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer to the hyhostent_struct, to be linked to the per thread platform hostent struct.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d26c72f38bb36305896cfc7fc40f3ff2"></a><!-- doxytag: member="hysock.c::hysock_gethostbyname" ref="d26c72f38bb36305896cfc7fc40f3ff2" args="(struct HyPortLibrary *portLibrary, char *name, hyhostent_t handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_gethostbyname           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hyhostent_t&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer information on the host, specified by name. 
<p>
The information includes host name, aliases and addresses.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>The host name string. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer to the hyhostent_struct (to be linked to the per thread platform hostent struct).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="52a6a1e72a64a78cce2a847c0e4d686d"></a><!-- doxytag: member="hysock.c::hysock_gethostname" ref="52a6a1e72a64a78cce2a847c0e4d686d" args="(struct HyPortLibrary *portLibrary, char *buffer, I_32 length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_gethostname           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the name of the local host machine. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>The string buffer to receive the name </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the buffer</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code </dd></dl>

</div>
</div><p>
<a class="anchor" name="7475a81399e6844f403f1e487a1f4904"></a><!-- doxytag: member="hysock.c::hysock_getnameinfo" ref="7475a81399e6844f403f1e487a1f4904" args="(struct HyPortLibrary *portLibrary, hysockaddr_t in_addr, I_32 sockaddr_size, char *name, I_32 name_length, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_getnameinfo           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>in_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>sockaddr_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answers the host name of the "in_addr" in a preallocated buffer. 
<p>
The preallocated buffer for "name" should be the size of the maximum host name: OSNIMAXHOST. Currently only AF_INET and AF_INET6 are supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>in_addr</em>&nbsp;</td><td>The address we want to do a name lookup on </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sockaddr_size</em>&nbsp;</td><td>The size of "in_addr" </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>The hostname of the passed address in a preallocated buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name_length</em>&nbsp;</td><td>The length of the buffer pointed to by name </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags on how to form the repsonse (see man pages or doc for getnameinfo)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Added for IPv6 support. <p>
"flags" do not affect results on OS's that do not support the IPv6 calls. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cfac5b0f2cde6bf42686a7cb876ca0b1"></a><!-- doxytag: member="hysock.c::hysock_getopt_bool" ref="cfac5b0f2cde6bf42686a7cb876ca0b1" args="(struct HyPortLibrary *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, BOOLEAN *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_getopt_bool           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>socketP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the value of the nominated boolean socket option. 
<p>
Refer to the private platformSocketLevel &amp; platformSocketOption functions for details of the options supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketP</em>&nbsp;</td><td>Pointer to the socket to query for the option value. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlevel</em>&nbsp;</td><td>The level within the IP stack at which the option is defined. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td>The name of the option to retrieve. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the boolean to update with the option value.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c559064d0edce181e9c9e9aaa298f834"></a><!-- doxytag: member="hysock.c::hysock_getopt_byte" ref="c559064d0edce181e9c9e9aaa298f834" args="(struct HyPortLibrary *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, U_8 *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_getopt_byte           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>socketP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_8 *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the value of the nominated byte socket option. 
<p>
Refer to the private platformSocketLevel &amp; platformSocketOption functions for details of the options supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketP</em>&nbsp;</td><td>Pointer to the socket to query for the option value. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlevel</em>&nbsp;</td><td>The level within the IP stack at which the option is defined. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td>The name of the option to retrieve. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the byte to update with the option value.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3d0f9615328e1f237881ad222e6d0011"></a><!-- doxytag: member="hysock.c::hysock_getopt_int" ref="3d0f9615328e1f237881ad222e6d0011" args="(struct HyPortLibrary *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, I_32 *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_getopt_int           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>socketP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32 *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the value of the nominated integer socket option. 
<p>
Refer to the private platformSocketLevel &amp; platformSocketOption functions for details of the options supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketP</em>&nbsp;</td><td>Pointer to the socket to query for the option value. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlevel</em>&nbsp;</td><td>The level within the IP stack at which the option is defined. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td>The name of the option to retrieve. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the integer to update with the option value.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="905ee058073665eadfd54bb30478bdeb"></a><!-- doxytag: member="hysock.c::hysock_getopt_linger" ref="905ee058073665eadfd54bb30478bdeb" args="(struct HyPortLibrary *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, hylinger_t optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_getopt_linger           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>socketP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hylinger_t&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the value of the socket linger option. 
<p>
See the <a class="el" href="hysock_8c.html#b23a5d72227ea8b6b70717892b48d894">hysock_linger_init</a> for details of the linger behavior.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketP</em>&nbsp;</td><td>Pointer to the socket to query for the option value </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlevel</em>&nbsp;</td><td>The level within the IP stack at which the option is defined </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td>The name of the option to retrieve </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the linger struct to update with the option value</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code </dd></dl>

</div>
</div><p>
<a class="anchor" name="04e33f5b905422886aadcab2d88d9ff2"></a><!-- doxytag: member="hysock.c::hysock_getopt_sockaddr" ref="04e33f5b905422886aadcab2d88d9ff2" args="(struct HyPortLibrary *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, hysockaddr_t optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_getopt_sockaddr           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>socketP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the value of the socket option, an address struct. 
<p>
Currently only used to retrieve the interface of multicast sockets, but the more general call style has been used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketP</em>&nbsp;</td><td>Pointer to the socket to query for the option value. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlevel</em>&nbsp;</td><td>The level within the IP stack at which the option is defined. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td>The name of the option to retrieve. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the sockaddr struct to update with the option value.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3fc5e035fde3118881ed6ced523fdd82"></a><!-- doxytag: member="hysock.c::hysock_getpeername" ref="3fc5e035fde3118881ed6ced523fdd82" args="(struct HyPortLibrary *portLibrary, hysocket_t handle, hysockaddr_t addrHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_getpeername           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>addrHandle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the remote name for the socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer to the socket to get the address of. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>addrHandle</em>&nbsp;</td><td>Pointer to the sockaddr struct to update with the address.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4b6ff6913870ffab8d65cc31601473a0"></a><!-- doxytag: member="hysock.c::hysock_getsockname" ref="4b6ff6913870ffab8d65cc31601473a0" args="(struct HyPortLibrary *portLibrary, hysocket_t handle, hysockaddr_t addrHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_getsockname           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>addrHandle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the local name for the socket. 
<p>
Note, the stack getsockname function actually answers a sockaddr structure, not a string name as the function name might imply.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer to the socket to get the address of. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>addrHandle</em>&nbsp;</td><td>Pointer to the sockaddr struct to update with the address.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="063d2969a7a366897e83da5109626a53"></a><!-- doxytag: member="hysock.c::hysock_hostent_addrlist" ref="063d2969a7a366897e83da5109626a53" args="(struct HyPortLibrary *portLibrary, hyhostent_t handle, U_32 index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_hostent_addrlist           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hyhostent_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the nominated element of the address list within the argument hostent struct. 
<p>
The address is in network order.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer to the hostent struct, in which to access the addr_list. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The index of the element within the addr_list to retrieve.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the address, in network order. </dd></dl>

</div>
</div><p>
<a class="anchor" name="66fe7abe94ba34705e78d9247ae3efa5"></a><!-- doxytag: member="hysock.c::hysock_hostent_aliaslist" ref="66fe7abe94ba34705e78d9247ae3efa5" args="(struct HyPortLibrary *portLibrary, hyhostent_t handle, char ***aliasList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_hostent_aliaslist           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hyhostent_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&nbsp;</td>
          <td class="paramname"> <em>aliasList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer a reference to the list of alternative names for the host within the argument hostent struct. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer to the hostent struct, in which to access the addr_list </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>aliasList</em>&nbsp;</td><td>Pointer to the list of alternative names, to be updated</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code </dd></dl>

</div>
</div><p>
<a class="anchor" name="ea43182c98226d1a8f8a14b4f85b1056"></a><!-- doxytag: member="hysock.c::hysock_hostent_hostname" ref="ea43182c98226d1a8f8a14b4f85b1056" args="(struct HyPortLibrary *portLibrary, hyhostent_t handle, char **hostName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_hostent_hostname           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hyhostent_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>hostName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the host name (string) within the argument hostent struct. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer to the hostent struct, in which to access the hostName. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hostName</em>&nbsp;</td><td>Host name string.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, the function does not validate the name access. </dd></dl>

</div>
</div><p>
<a class="anchor" name="21a80d039021a32c83b743fe4c000925"></a><!-- doxytag: member="hysock.c::hysock_htonl" ref="21a80d039021a32c83b743fe4c000925" args="(struct HyPortLibrary *portLibrary, I_32 val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_htonl           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the 32 bit host ordered argument, in network byte order. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>The 32 bit host ordered number.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the 32 bit network ordered number. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e90cb83bf8c9e8d89089e54930f3a32a"></a><!-- doxytag: member="hysock.c::hysock_htons" ref="e90cb83bf8c9e8d89089e54930f3a32a" args="(struct HyPortLibrary *portLibrary, U_16 val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U_16 VMCALL hysock_htons           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_16&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the 16 bit host ordered argument, in network byte order. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>The 16 bit host ordered number.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the 16 bit network ordered number. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a5a4b18bfeaef226f240402058c12a57"></a><!-- doxytag: member="hysock.c::hysock_inetaddr" ref="a5a4b18bfeaef226f240402058c12a57" args="(struct HyPortLibrary *portLibrary, char *addrStr, U_32 *addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_inetaddr           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>addrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32 *&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the dotted IP string as an Internet address. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>addrStr</em>&nbsp;</td><td>The dotted IP string. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>Pointer to the Internet address.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="aee92b509cabaa741e432e7c04ef5dd6"></a><!-- doxytag: member="hysock.c::hysock_inetntoa" ref="aee92b509cabaa741e432e7c04ef5dd6" args="(struct HyPortLibrary *portLibrary, char **addrStr, U_32 nipAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_inetntoa           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>addrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>nipAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the Internet address as a dotted IP string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>addrStr</em>&nbsp;</td><td>The dotted IP string. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nipAddr</em>&nbsp;</td><td>The Internet address.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b9fcd0c28e7d5416696e73abd7036b4b"></a><!-- doxytag: member="hysock.c::hysock_ipmreq_init" ref="b9fcd0c28e7d5416696e73abd7036b4b" args="(struct HyPortLibrary *portLibrary, hyipmreq_t handle, U_32 nipmcast, U_32 nipinterface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_ipmreq_init           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hyipmreq_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>nipmcast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>nipinterface</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes a new multicast membership structure. 
<p>
The membership structure is used to join &amp; leave multicast groups <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="hysock_8c.html#024f784bb0e43ecb6924808516d31cf2" title="Set the multicast request on this socket.">hysock_setopt_ipmreq</a>. The group may be joined using 0 (HYSOCK_INADDR_ANY) as the local interface, in which case the default local address will be used.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer to the multicast membership struct. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nipmcast</em>&nbsp;</td><td>The address, in network order, of the multicast group to join. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nipinterface</em>&nbsp;</td><td>The address, in network order, of the local machine interface to join on.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c45e677914d4c32c03b06d1614270941"></a><!-- doxytag: member="hysock.c::hysock_ipv6_mreq_init" ref="c45e677914d4c32c03b06d1614270941" args="(struct HyPortLibrary *portLibrary, hyipv6_mreq_t handle, U_8 *ipmcast_addr, U_32 ipv6mr_interface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_ipv6_mreq_init           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hyipv6_mreq_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_8 *&nbsp;</td>
          <td class="paramname"> <em>ipmcast_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>ipv6mr_interface</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills in a preallocated hyipv6_mreq_struct. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>A pointer to the hyipv6_mreq_struct to populate. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ipmcast_addr</em>&nbsp;</td><td>The ip mulitcast address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ipv6mr_interface</em>&nbsp;</td><td>The ip mulitcast inteface.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Added for IPv6 support. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2b8842b0fecc9345edd7ae78b68bd80b"></a><!-- doxytag: member="hysock.c::hysock_linger_enabled" ref="2b8842b0fecc9345edd7ae78b68bd80b" args="(struct HyPortLibrary *portLibrary, hylinger_t handle, BOOLEAN *enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_linger_enabled           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hylinger_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN *&nbsp;</td>
          <td class="paramname"> <em>enabled</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer true if the linger is enabled in the argument linger struct. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer to the linger struct to be accessed. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>enabled</em>&nbsp;</td><td>Pointer to the boolean to be updated with the linger status.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, the function does not validate the access. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b23a5d72227ea8b6b70717892b48d894"></a><!-- doxytag: member="hysock.c::hysock_linger_init" ref="b23a5d72227ea8b6b70717892b48d894" args="(struct HyPortLibrary *portLibrary, hylinger_t handle, I_32 enabled, U_16 timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_linger_init           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hylinger_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_16&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes a new linger structure, enabled or disabled, with the timeout as specified. 
<p>
Linger defines the behavior when unsent messages exist for a socket that has been sent close. If linger is disabled, the default, close returns immediately and the stack attempts to deliver unsent messages. If linger is enabled: <ul>
<li>if the timeout is 0, the close will block indefinitely until the messages are sent </li>
<li>if the timeout is set, the close will return after the messages are sent or the timeout period expired</li>
</ul>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer to the linger struct to be accessed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enabled</em>&nbsp;</td><td>Aero to disable, a non-zero value to enable linger. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>0 to linger indefinitely or a positive timeout value (in seconds).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e654004478602ef80daab7f2007ce0a5"></a><!-- doxytag: member="hysock.c::hysock_linger_linger" ref="e654004478602ef80daab7f2007ce0a5" args="(struct HyPortLibrary *portLibrary, hylinger_t handle, U_16 *linger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_linger_linger           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hylinger_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_16 *&nbsp;</td>
          <td class="paramname"> <em>linger</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the linger timeout value in the argument linger struct. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer to the linger struct to be accessed. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>linger</em>&nbsp;</td><td>Pointer to the integer, to be updated with the linger value (in seconds).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, the function does not validate the access. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c41f0f9146374eaeee49162fe6d2c969"></a><!-- doxytag: member="hysock.c::hysock_listen" ref="c41f0f9146374eaeee49162fe6d2c969" args="(struct HyPortLibrary *portLibrary, hysocket_t sock, I_32 backlog)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_listen           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>backlog</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the socket to listen for incoming connection requests. 
<p>
This call is made prior to accepting requests, via the <a class="el" href="hysock_8c.html#ae13cf34894846118c7a0609e81b38ee">hysock_accept</a> function. The backlog specifies the maximum length of the queue of pending connections, after which further requests are rejected.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>Pointer to the socket to modify. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>backlog</em>&nbsp;</td><td>The maximum number of queued requests.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="19382da111b422bc7e6e48070a640d46"></a><!-- doxytag: member="hysock.c::hysock_ntohl" ref="19382da111b422bc7e6e48070a640d46" args="(struct HyPortLibrary *portLibrary, I_32 val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_ntohl           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the 32 bit network ordered argument, in host byte order. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>The 32 bit network ordered number.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the 32 bit host ordered number. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cfb7a3e2540f0054491c6da1631dbeac"></a><!-- doxytag: member="hysock.c::hysock_ntohs" ref="cfb7a3e2540f0054491c6da1631dbeac" args="(struct HyPortLibrary *portLibrary, U_16 val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U_16 VMCALL hysock_ntohs           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_16&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the 16-bit network ordered argument, in host byte order. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>The 16-bit network ordered number.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the 16-bit host ordered number. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fd379791b30d2d696ae062a110c678b1"></a><!-- doxytag: member="hysock.c::hysock_read" ref="fd379791b30d2d696ae062a110c678b1" args="(struct HyPortLibrary *portLibrary, hysocket_t sock, U_8 *buf, I_32 nbyte, I_32 flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_read           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_8 *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>nbyte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The read function receives data from a connected socket. 
<p>
Calling read will return as much information as is currently available up to the size of the buffer supplied. If no incoming data is available at the socket, the read call blocks and waits for data to arrive.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>Pointer to the socket to read on </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>Pointer to the buffer where input bytes are written </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbyte</em>&nbsp;</td><td>The length of buf </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>The flags, to influence this read (in addition to the socket options)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>If no error occurs, return the number of bytes received. </li>
<li>If the connection has been gracefully closed, return 0. </li>
<li>Otherwise return the (negative) error code. </li>
</ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="49253e3ab0dfd567d15faceb87d18851"></a><!-- doxytag: member="hysock.c::hysock_readfrom" ref="49253e3ab0dfd567d15faceb87d18851" args="(struct HyPortLibrary *portLibrary, hysocket_t sock, U_8 *buf, I_32 nbyte, I_32 flags, hysockaddr_t addrHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_readfrom           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_8 *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>nbyte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>addrHandle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The read function receives data from a possibly connected socket. 
<p>
Calling read will return as much information as is currently available up to the size of the buffer supplied. If the information is too large for the buffer, the excess will be discarded. If no incoming data is available at the socket, the read call blocks and waits for data to arrive. It the address argument is not null, the address will be updated with address of the message sender.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>Pointer to the socket to read on. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>Pointer to the buffer where input bytes are written. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbyte</em>&nbsp;</td><td>The length of buf. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Tthe flags, to influence this read. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>addrHandle</em>&nbsp;</td><td>if provided, the address to be updated with the sender information.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>If no error occurs, return the number of bytes received. </li>
<li>If the connection has been gracefully closed, return 0. </li>
<li>Otherwise return the (negative) error code. </li>
</ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="0c4692a035e02b931c802a2d0634df8f"></a><!-- doxytag: member="hysock.c::hysock_select" ref="0c4692a035e02b931c802a2d0634df8f" args="(struct HyPortLibrary *portLibrary, I_32 nfds, hyfdset_t readfds, hyfdset_t writefds, hyfdset_t exceptfds, hytimeval_t timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_select           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>nfds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hyfdset_t&nbsp;</td>
          <td class="paramname"> <em>readfds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hyfdset_t&nbsp;</td>
          <td class="paramname"> <em>writefds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hyfdset_t&nbsp;</td>
          <td class="paramname"> <em>exceptfds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hytimeval_t&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The select function allows the state of sockets for read &amp; write operations and exceptional conditions to be tested. 
<p>
The function is used prior to a hysock_read/readfrom, to control the period the operation may block for. Depending upon the timeout specified: <ul>
<li>0, return immediately with the status of the descriptors </li>
<li>timeout, return when one of the descriptors is ready or after the timeout period has expired </li>
<li>null, block indefinitely for a ready descriptor</li>
</ul>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nfds</em>&nbsp;</td><td>Maximum number of file descriptors to be tested. Ignored by Windows Socket API. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>readfds</em>&nbsp;</td><td>Tthe set of descriptors to be checked if ready for read operations. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>writefds</em>&nbsp;</td><td>The set of descriptors to be checked if ready for write operations. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>exceptfds</em>&nbsp;</td><td>The set of descriptors to be checked for exceptional conditions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Pointer to the timeout (a hytimeval struct).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if no error occurs, otherwise return the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6c9fc0850a29b453d6b46cbb26a072bb"></a><!-- doxytag: member="hysock.c::hysock_select_read" ref="6c9fc0850a29b453d6b46cbb26a072bb" args="(struct HyPortLibrary *portLibrary, hysocket_t hysocketP, I_32 secTime, I_32 uSecTime, BOOLEAN accept)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_select_read           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>hysocketP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>secTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>uSecTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN&nbsp;</td>
          <td class="paramname"> <em>accept</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A helper method, to ensure a read operation can be performed without blocking. 
<p>
The portable version of a read operation is a blocking call (will wait indefinitely for data). This function should be called prior to a read operation, to provide a read timeout. If the result is 1, the caller is guaranteed to be able to complete a read on the socket without blocking. The actual contents of the fdset are not available for inspection (as provided in the more general 'select' function). The timeout is specified in seconds and microseconds. If the timeout is 0, skip this function (and thus the caller of a subsequent read operation may block).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hysocketP</em>&nbsp;</td><td>Pointer to the hysocket to query for available read data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>secTime</em>&nbsp;</td><td>The integer component of the timeout periond, in seconds. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uSecTime</em>&nbsp;</td><td>The fractional component of the timeout period, in microSeconds. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>accept</em>&nbsp;</td><td>Set to true when called for an accept(), false when called for a read()</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>1, if there is data available to read at the socket </li>
<li>HYPORT_ERROR_SOCKET_TIMEOUT if the call timed out </li>
<li>otherwise return the (negative) error code. </li>
</ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="9e9d12ba6bd504ff502d38d77b204453"></a><!-- doxytag: member="hysock.c::hysock_set_nonblocking" ref="9e9d12ba6bd504ff502d38d77b204453" args="(struct HyPortLibrary *portLibrary, hysocket_t socketP, BOOLEAN nonblocking)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_set_nonblocking           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>socketP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN&nbsp;</td>
          <td class="paramname"> <em>nonblocking</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the nonblocking state of the socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketP</em>&nbsp;</td><td>Pointer to the socket to read on </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nonblocking</em>&nbsp;</td><td>Set true for nonblocking, false for blocking</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if no error occurs, otherwise return the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c25e085d41a5052f3e88129fdc8d5226"></a><!-- doxytag: member="hysock.c::hysock_setflag" ref="c25e085d41a5052f3e88129fdc8d5226" args="(struct HyPortLibrary *portLibrary, I_32 flag, I_32 *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_setflag           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32 *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ensure the flag designated is set in the argument. 
<p>
This is used to construct arguments for the hysock_read/readfrom/write/writeto calls with optional flags, such as HYSOCK_MSG_PEEK.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flag</em>&nbsp;</td><td>The operation flag to set in the argument. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to the argument to set the flag bit in.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if no error occurs, otherwise return the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8e5d7661767cf61343fda3a6053d80c7"></a><!-- doxytag: member="hysock.c::hysock_setopt_bool" ref="8e5d7661767cf61343fda3a6053d80c7" args="(struct HyPortLibrary *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, BOOLEAN *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_setopt_bool           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>socketP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the value of the nominated boolean socket option. 
<p>
Refer to the private platformSocketLevel &amp; platformSocketOption functions for details of the options supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketP</em>&nbsp;</td><td>Pointer to the socket to set the option in. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlevel</em>&nbsp;</td><td>The level within the IP stack at which the option is defined. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td>The name of the option to set. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the boolean to update the socket option with.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d88c2999652e0facc3d7a3a665479a22"></a><!-- doxytag: member="hysock.c::hysock_setopt_byte" ref="d88c2999652e0facc3d7a3a665479a22" args="(struct HyPortLibrary *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, U_8 *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_setopt_byte           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>socketP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_8 *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the value of the nominated byte socket option. 
<p>
Refer to the private platformSocketLevel &amp; platformSocketOption functions for details of the options supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketP</em>&nbsp;</td><td>Pointer to the socket to set the option in. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlevel</em>&nbsp;</td><td>The level within the IP stack at which the option is defined. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td>The name of the option to set. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the byte to update the socket option with.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="538e8623b0fb3524acc83d7c48f504f2"></a><!-- doxytag: member="hysock.c::hysock_setopt_int" ref="538e8623b0fb3524acc83d7c48f504f2" args="(struct HyPortLibrary *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, I_32 *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_setopt_int           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>socketP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32 *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the value of the nominated integer socket option. 
<p>
Refer to the private platformSocketLevel &amp; platformSocketOption functions for details of the options supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketP</em>&nbsp;</td><td>Pointer to the socket to set the option in. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlevel</em>&nbsp;</td><td>The level within the IP stack at which the option is defined. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td>The name of the option to set. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the integer to update the socket option with.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="024f784bb0e43ecb6924808516d31cf2"></a><!-- doxytag: member="hysock.c::hysock_setopt_ipmreq" ref="024f784bb0e43ecb6924808516d31cf2" args="(struct HyPortLibrary *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, hyipmreq_t optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_setopt_ipmreq           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>socketP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hyipmreq_t&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the multicast request on this socket. 
<p>
Currently this is used to join or leave the nominated multicast group on the local interface. It may be more generally useful, so a generic 'setop' function has been defined.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketP</em>&nbsp;</td><td>Pointer to the socket to set the option in. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlevel</em>&nbsp;</td><td>The level within the IP stack at which the option is defined. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td>The name of the option to set. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the ipmreq struct to update the socket option with.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="394df1269da1dad9765bab1ac003e196"></a><!-- doxytag: member="hysock.c::hysock_setopt_ipv6_mreq" ref="394df1269da1dad9765bab1ac003e196" args="(struct HyPortLibrary *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, hyipv6_mreq_t optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_setopt_ipv6_mreq           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>socketP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hyipv6_mreq_t&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the multicast request on this socket for IPv6 sockets. 
<p>
Currently this is used to join or leave the nominated multicast group on the local interface. It may be more generally useful, so a generic 'setop' function has been defined.t.<p>
Supported families are OS_AF_INET and OS_AF_INET6<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketP</em>&nbsp;</td><td>Pointer to the socket to set the option in. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlevel</em>&nbsp;</td><td>The level within the IP stack at which the option is defined. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td>The name of the option to set. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the ipmreq struct to update the socket option with.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Added for IPv6 support. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c42601d071303441c34debdc4981b7ec"></a><!-- doxytag: member="hysock.c::hysock_setopt_linger" ref="c42601d071303441c34debdc4981b7ec" args="(struct HyPortLibrary *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, hylinger_t optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_setopt_linger           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>socketP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hylinger_t&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the linger value on the socket. 
<p>
See the <a class="el" href="hysock_8c.html#b23a5d72227ea8b6b70717892b48d894">hysock_linger_init</a> for details of the linger behavior.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketP</em>&nbsp;</td><td>Pointer to the socket to set the option in. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlevel</em>&nbsp;</td><td>The level within the IP stack at which the option is defined. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td>The name of the option to set. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the linger struct to update the socket option with.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e3b74b1133f0703175d7cd005306c3bd"></a><!-- doxytag: member="hysock.c::hysock_setopt_sockaddr" ref="e3b74b1133f0703175d7cd005306c3bd" args="(struct HyPortLibrary *portLibrary, hysocket_t socketP, I_32 optlevel, I_32 optname, hysockaddr_t optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_setopt_sockaddr           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>socketP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sockaddr for the socket. 
<p>
Currently used to set the interface of multicast sockets, but the more general call style is used, in case it is more generally useful.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketP</em>&nbsp;</td><td>Pointer to the socket to set the option in. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlevel</em>&nbsp;</td><td>The level within the IP stack at which the option is defined. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td>The name of the option to set. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the hysockaddr struct to update the socket option with.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="31acd9bb9f07e31c2e5e7716f5c23608"></a><!-- doxytag: member="hysock.c::hysock_shutdown" ref="31acd9bb9f07e31c2e5e7716f5c23608" args="(struct HyPortLibrary *portLibrary)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_shutdown           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Terminates use of the socket library. 
<p>
No sockets should be in use or the results of this operation are unpredictable. Frees any resources held by the socket library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code </dd></dl>

</div>
</div><p>
<a class="anchor" name="fa366e01ee07266f38038d6e26cc1aa8"></a><!-- doxytag: member="hysock.c::hysock_shutdown_input" ref="fa366e01ee07266f38038d6e26cc1aa8" args="(struct HyPortLibrary *portLibrary, hysocket_t sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_shutdown_input           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>sock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The shutdown_input function disables the input stream on a socket. 
<p>
Any subsequent reads from the socket will fail.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket to close input stream on.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0, on success </li>
<li>HYPORT_ERROR_SOCKET_OPFAILED, on generic error </li>
<li>HYPORT_ERROR_SOCKET_NOTINITIALIZED, if the library is not initialized </li>
</ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="6c7af585ec65bfb2c3b08d92ae4b1bc2"></a><!-- doxytag: member="hysock.c::hysock_shutdown_output" ref="6c7af585ec65bfb2c3b08d92ae4b1bc2" args="(struct HyPortLibrary *portLibrary, hysocket_t sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_shutdown_output           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>sock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The shutdown_output function disables the output stream on a socket. 
<p>
Any subsequent writes to the socket will fail.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket to close output stream on.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0, on success </li>
<li>HYPORT_ERROR_SOCKET_OPFAILED, on generic error </li>
<li>HYPORT_ERROR_SOCKET_NOTINITIALIZED, if the library is not initialized </li>
</ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="130ecd89ccfeb402466065bbbf9c4f6d"></a><!-- doxytag: member="hysock.c::hysock_sockaddr" ref="130ecd89ccfeb402466065bbbf9c4f6d" args="(struct HyPortLibrary *portLibrary, hysockaddr_t handle, char *addrStr, U_16 port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_sockaddr           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>addrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_16&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new hysockaddr, refering to the specified port and address. 
<p>
The only address family currently supported is AF_INET.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer to the hysockaddr struct, to be allocated. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addrStr</em>&nbsp;</td><td>The target host, as either a name or dotted ip string. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>port</em>&nbsp;</td><td>The target port, in host order.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="33f0d799e4ff79c0b0aaaa0e920af7e2"></a><!-- doxytag: member="hysock.c::hysock_sockaddr_address" ref="33f0d799e4ff79c0b0aaaa0e920af7e2" args="(struct HyPortLibrary *portLibrary, hysockaddr_t handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_sockaddr_address           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the address, in network order, of the hysockaddr argument. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer to the hysockaddr struct to access.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the address (there is no validation on the access). </dd></dl>

</div>
</div><p>
<a class="anchor" name="e591fde7d4a84a1fee3d7e14c4a31edb"></a><!-- doxytag: member="hysock.c::hysock_sockaddr_address6" ref="e591fde7d4a84a1fee3d7e14c4a31edb" args="(struct HyPortLibrary *portLibrary, hysockaddr_t handle, U_8 *address, U_32 *length, U_32 *scope_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_sockaddr_address6           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_8 *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32 *&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32 *&nbsp;</td>
          <td class="paramname"> <em>scope_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answers the IP address of a structure and its length, in a preallocated buffer. 
<p>
Preallocated buffer "address" should be 16 bytes. "length" tells you how many bytes were used 4 or 16.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>A populated hysockaddr_t. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>The IPv4 or IPv6 address in network byte order. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes of the address (4 or 16). </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>scope_id</em>&nbsp;</td><td>the scope id for the address if appropriate</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Added for IPv6 support. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f8fcfecdd832c99f951a3ff8eee09fb0"></a><!-- doxytag: member="hysock.c::hysock_sockaddr_family" ref="f8fcfecdd832c99f951a3ff8eee09fb0" args="(struct HyPortLibrary *portLibrary, I_16 *family, hysockaddr_t handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_sockaddr_family           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_16 *&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answers the family name of a hysockaddr_struct. 
<p>
Supported families are OS_AF_INET and OS_AF_INET6<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>The family name of the address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>A populated hysockaddr_t.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Added for IPv6 support. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8835b4fd8141990fc1d2af2eab4c63e5"></a><!-- doxytag: member="hysock.c::hysock_sockaddr_init" ref="8835b4fd8141990fc1d2af2eab4c63e5" args="(struct HyPortLibrary *portLibrary, hysockaddr_t handle, I_16 family, U_32 nipAddr, U_16 nPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_sockaddr_init           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_16&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>nipAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_16&nbsp;</td>
          <td class="paramname"> <em>nPort</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new hysockaddr, refering to the specified port and address. 
<p>
The only address family currently supported is AF_INET.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer pointer to the hysockaddr struct, to be allocated. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>The address family. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nipAddr</em>&nbsp;</td><td>The target host address, in network order. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nPort</em>&nbsp;</td><td>The target port, in host order.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1c311bcb59483f6247c97a6a82fef9af"></a><!-- doxytag: member="hysock.c::hysock_sockaddr_init6" ref="1c311bcb59483f6247c97a6a82fef9af" args="(struct HyPortLibrary *portLibrary, hysockaddr_t handle, U_8 *addr, I_32 addrlength, I_16 family, U_16 nPort, U_32 flowinfo, U_32 scope_id, hysocket_t sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_sockaddr_init6           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_8 *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>addrlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_16&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_16&nbsp;</td>
          <td class="paramname"> <em>nPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>flowinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>scope_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>sock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answers an initialized hysockaddr_struct structure. 
<p>
Pass in a hysockaddr_struct with some initial parameters to initialize it appropriately. Currently the only address families supported are OS_AF_INET6 and OS_AF_INET, which will be determined by addrlength. (4 bytes for IPv4 addresses and 16 bytes for IPv6 addresses).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer pointer to the hysockaddr struct, to be allocated. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>The IPv4 or IPv6 address in network byte order. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addrlength</em>&nbsp;</td><td>The number of bytes of the address (4 or 16). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>The address family. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nPort</em>&nbsp;</td><td>The target port, in network order. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flowinfo</em>&nbsp;</td><td>The flowinfo value for IPv6 addresses in HOST order. Set to 0 for IPv4 addresses or if no flowinfo needs to be set for IPv6 address </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scope_id</em>&nbsp;</td><td>The scope id for an IPv6 address in HOST order. Set to 0 for IPv4 addresses and for non-scoped IPv6 addresses </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>The socket that this address will be used with.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Added for IPv6 support. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0d811111835a9c99d5af6a2e09430f64"></a><!-- doxytag: member="hysock.c::hysock_sockaddr_port" ref="0d811111835a9c99d5af6a2e09430f64" args="(struct HyPortLibrary *portLibrary, hysockaddr_t handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U_16 VMCALL hysock_sockaddr_port           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Answer the port, in network order, of the hysockaddr argument. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer to the hysockaddr struct to access.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the port (there is no validation on the access). </dd></dl>

</div>
</div><p>
<a class="anchor" name="564cbca4fcf0fdcfabb47d4fe0746a61"></a><!-- doxytag: member="hysock.c::hysock_socket" ref="564cbca4fcf0fdcfabb47d4fe0746a61" args="(struct HyPortLibrary *portLibrary, hysocket_t *handle, I_32 family, I_32 socktype, I_32 protocol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_socket           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>socktype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>protocol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new socket descriptor and any related resources. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer pointer to the hysocket struct, to be allocated </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>The address family (currently, only HYSOCK_AFINET is supported) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socktype</em>&nbsp;</td><td>Secifies what type of socket is created <ul>
<li>HYSOCK_STREAM, for a stream socket </li>
<li>HYSOCK_DGRAM, for a datagram socket </li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>protocol</em>&nbsp;</td><td>Type/family specific creation parameter (currently, only HYSOCK_DEFPROTOCOL supported).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="668aafc1a42d8d5f7c7885b1d55e8176"></a><!-- doxytag: member="hysock.c::hysock_socketIsValid" ref="668aafc1a42d8d5f7c7885b1d55e8176" args="(struct HyPortLibrary *portLibrary, hysocket_t handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_socketIsValid           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether or not the socket is valid. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Pointer to the hysocket struct, to be allocated.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if invalid, non-zero for valid. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f85cbe3aab713a46bae6d45919390d4a"></a><!-- doxytag: member="hysock.c::hysock_startup" ref="f85cbe3aab713a46bae6d45919390d4a" args="(struct HyPortLibrary *portLibrary)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_startup           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initiate the use of sockets by a process. 
<p>
This function must be called before any other socket calls.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, negative error code on failure. Error code values returned are <ul>
<li>HYPORT_ERROR_STARTUP_SOCK </li>
<li>HYPORT_ERROR_SOCKET_OPFAILED </li>
<li>HYPORT_ERROR_SOCKET_NOTINITIALIZED </li>
</ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="716d94b9f5af022e9e36a8c11bcaf8eb"></a><!-- doxytag: member="hysock.c::hysock_timeval_init" ref="716d94b9f5af022e9e36a8c11bcaf8eb" args="(struct HyPortLibrary *portLibrary, U_32 secTime, U_32 uSecTime, hytimeval_t timeP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_timeval_init           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>secTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_32&nbsp;</td>
          <td class="paramname"> <em>uSecTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hytimeval_t&nbsp;</td>
          <td class="paramname"> <em>timeP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a time structure, representing the timeout period defined in seconds &amp; microSeconds. 
<p>
Timeval's are used as timeout arguments in the <a class="el" href="hysock_8c.html#0c4692a035e02b931c802a2d0634df8f">hysock_select</a> function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>secTime</em>&nbsp;</td><td>The integer component of the timeout value (in seconds). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uSecTime</em>&nbsp;</td><td>The fractional component of the timeout value (in microseconds). </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>timeP</em>&nbsp;</td><td>Pointer pointer to the hytimeval_struct to be allocated.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0, if no errors occurred, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b2461da5b68eef2c7e12f0b041c66b4e"></a><!-- doxytag: member="hysock.c::hysock_write" ref="b2461da5b68eef2c7e12f0b041c66b4e" args="(struct HyPortLibrary *portLibrary, hysocket_t sock, U_8 *buf, I_32 nbyte, I_32 flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_write           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_8 *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>nbyte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The write function writes data to a connected socket. 
<p>
The successful completion of a write does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>Pointer to the socket to send on </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>The bytes to be sent </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbyte</em>&nbsp;</td><td>The number of bytes to send </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>The flags to modify the send behavior</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>If no error occur, return the total number of bytes sent, which can be less than the 'nbyte' for nonblocking sockets, otherwise the (negative) error code </dd></dl>

</div>
</div><p>
<a class="anchor" name="13bf3e15e0daa798996eb8e3e32aa7c9"></a><!-- doxytag: member="hysock.c::hysock_writeto" ref="13bf3e15e0daa798996eb8e3e32aa7c9" args="(struct HyPortLibrary *portLibrary, hysocket_t sock, U_8 *buf, I_32 nbyte, I_32 flags, hysockaddr_t addrHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I_32 VMCALL hysock_writeto           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="paramname"> <em>portLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysocket_t&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U_8 *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>nbyte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I_32&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hysockaddr_t&nbsp;</td>
          <td class="paramname"> <em>addrHandle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The writeto function writes data to a datagram socket. 
<p>
The successful completion of a writeto does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, writeto will block.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td>The port library. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>Pointer to the socket to send on </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>The bytes to be sent </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbyte</em>&nbsp;</td><td>The number of bytes to send </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>The flags to modify the send behavior </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addrHandle</em>&nbsp;</td><td>The network address to send the datagram to</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>If no error occur, return the total number of bytes sent, otherwise the (negative) error code. </dd></dl>

</div>
</div><p>
<hr size="1">
<address style="text-align: center;">
  <small>
    <p>Genereated on Tue Dec 9 14:12:59 2008 by Doxygen.</p>
    <p>(c) Copyright 2005, 2008 The Apache Software Foundation or its licensors, as applicable. </p>
  </small>
</address>
</body>
</html>
