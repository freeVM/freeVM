<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Generational Garbage Collector: gc.h File Reference</title>
<link href="hydoxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>gc.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="struct_g_c.html">GC</a> interface exposed to VM. 
<p>
These are the functions that a <a class="el" href="struct_g_c.html">GC</a> built as a DLL must export. Some functions may be optional and are marked as such.<p>
This is a global include file which provides to the VM an interface to the <a class="el" href="struct_g_c.html">GC</a>. This interface is the only supported interface that the VM should call to talk to the <a class="el" href="struct_g_c.html">GC</a>. All routines in this C interface will begin with <code>gc_</code>.<p>
The <a class="el" href="struct_g_c.html">GC</a> expects that there is a <code>vm_gc.h</code> file holding the only interface that the <a class="el" href="struct_g_c.html">GC</a> will use to talk to the VM.<p>
In order to eliminate dependency on certain types such as (VTable *) we have eliminated them from this interface and replace them with (void *). While this might appear to be unfortunate it allows us to eliminate any knowledge of the class and VTable structures that are not of interest to the <a class="el" href="struct_g_c.html">GC</a>. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Routines to support the functionality required by the Java language specification</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#2829c549c88f82d3d2eb0423e86d414c">GC_OBJECT_ALIGNMENT</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Granularity of object alignment.  <a href="#2829c549c88f82d3d2eb0423e86d414c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#39127f4fd57eef7e8898a1ddefa07098">gc_force_gc</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">API for the VM to force a <a class="el" href="struct_g_c.html">GC</a>, typically in response to a call to <code>java.lang.Runtime.gc</code>.  <a href="#39127f4fd57eef7e8898a1ddefa07098"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#7bcb1b938d1ab523ca0638db25526bd5">gc_total_memory</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">API for the VM to determine the current <a class="el" href="struct_g_c.html">GC</a> heap size, typically in response to a call to <code>java.lang.Runtime.totalMemory</code>.  <a href="#7bcb1b938d1ab523ca0638db25526bd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#f6fdd3e193b8314444e6707f17043015">gc_max_memory</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">API for the VM to determine the maximum <a class="el" href="struct_g_c.html">GC</a> heap size, typically in response to a call to <code>java.lang.Runtime.maxMemory</code>.  <a href="#f6fdd3e193b8314444e6707f17043015"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#012dae57769b691038a0ce341675101d">gc_free_memory</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">API for the VM to get an approximate view of the free space, typically in response to a call to <code>java.lang.Runtime.freeMemory</code>.  <a href="#012dae57769b691038a0ce341675101d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#99d618103fc0cfc461905c5a01b36a7f">gc_is_object_pinned</a> (Managed_Object_Handle obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the object is pinned. </dd></dl>
 <a href="#99d618103fc0cfc461905c5a01b36a7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#76617bcedc9e24a83e47731bae2f1c30">gc_class_prepared</a> (Class_Handle ch, VTable_Handle vth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The VM calls this function after a new class has been prepared.  <a href="#76617bcedc9e24a83e47731bae2f1c30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#cdd1ae174432577e9446b89c23d9acca">gc_get_collection_count</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#fbbe2d49b86baa0778c09eefc420f926">gc_get_collection_time</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Routines to support threads</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#4527ed2193d8094d3b5a108abef2ba32">Thread_Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque handle for threads.  <a href="#4527ed2193d8094d3b5a108abef2ba32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#2a40bfac9c162aa2a5c3e20f159fc36b">gc_thread_init</a> (void *gc_information)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine is called during thread startup to set an initial nursery for the thread.  <a href="#2a40bfac9c162aa2a5c3e20f159fc36b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#d45e22b73f5a30732556861371759f8c">gc_thread_kill</a> (void *gc_information)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is called just before the thread is reclaimed.  <a href="#d45e22b73f5a30732556861371759f8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#c0c3197301e8aa22c395e71bc002b95e">vm_iterate_threads</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="struct_g_c.html">GC</a> may call this function asynchronously any time it wants to get thread list.  <a href="#c0c3197301e8aa22c395e71bc002b95e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#102b8aa8e3719e76f39aebc111296ef4">gc_iterate_thread</a> (<a class="el" href="gc__for__class_8h.html#4527ed2193d8094d3b5a108abef2ba32">Thread_Handle</a> thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">VM calls this method repeatedly to iterate over the list of java threads, initiated earlier by calling <code><a class="el" href="gc_8h.html#c0c3197301e8aa22c395e71bc002b95e" title="GC may call this function asynchronously any time it wants to get thread list.">vm_iterate_threads()</a></code>.  <a href="#102b8aa8e3719e76f39aebc111296ef4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#8ae27ead06e40ffe09ba4ca0939c466e">vm_suspend_thread</a> (<a class="el" href="gc__for__class_8h.html#4527ed2193d8094d3b5a108abef2ba32">Thread_Handle</a> thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="struct_g_c.html">GC</a> calls this method to request VM to suspend an individual thread.  <a href="#8ae27ead06e40ffe09ba4ca0939c466e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#78522721ab44728df9d8449c14e8ba10">gc_thread_suspended</a> (<a class="el" href="gc__for__class_8h.html#4527ed2193d8094d3b5a108abef2ba32">Thread_Handle</a> thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">VM calls this <a class="el" href="struct_g_c.html">GC</a> callback when it's accomplished the requested operation of suspending a thread in gc-safe point.  <a href="#78522721ab44728df9d8449c14e8ba10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#a50c9904148f0f1786bcee6caf5c6aca">vm_enumerate_thread_root_set</a> (<a class="el" href="gc__for__class_8h.html#4527ed2193d8094d3b5a108abef2ba32">Thread_Handle</a> thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="struct_g_c.html">GC</a> calls this function to command VM to enumerate a thread, which was earlier suspenden using <code><a class="el" href="gc_8h.html#8ae27ead06e40ffe09ba4ca0939c466e" title="GC calls this method to request VM to suspend an individual thread.">vm_suspend_thread()</a></code>.  <a href="#a50c9904148f0f1786bcee6caf5c6aca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#dc32d8ca99b9c801d2fd3eebbef8b3d0">vm_enumerate_global_root_set</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="struct_g_c.html">GC</a> calls this function to command VM to enumerate global slots.  <a href="#dc32d8ca99b9c801d2fd3eebbef8b3d0"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#81fcc009f47408a44372a8392507077d">GCExport</a>&nbsp;&nbsp;&nbsp;__declspec(dllexport)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>GCExport</code> is used to declare functions exported by <a class="el" href="struct_g_c.html">GC</a>.  <a href="#81fcc009f47408a44372a8392507077d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#369ecd38b3ab077fc235f892354bb46f">BITS_PER_BYTE</a>&nbsp;&nbsp;&nbsp;8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#793871c3e34e62c041444eec143e3842">NEXT_TO_HIGH_BIT_SET_MASK</a>&nbsp;&nbsp;&nbsp;(1&lt;&lt;((sizeof(unsigned) * BITS_PER_BYTE)-2))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#711865edab513e1984fc6f5010e581db">NEXT_TO_HIGH_BIT_CLEAR_MASK</a>&nbsp;&nbsp;&nbsp;~NEXT_TO_HIGH_BIT_SET_MASK</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#0e53a703c7a36ea4dedd2f6cfe6159ce">gc_time_since_last_gc</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">API for the VM to get the time since the last <a class="el" href="struct_g_c.html">GC</a> happened.  <a href="#0e53a703c7a36ea4dedd2f6cfe6159ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#b0860bb3e4ef0696ef42f686ed2f2ac9">gc_heap_base_address</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The base address of the heap. </dd></dl>
 <a href="#b0860bb3e4ef0696ef42f686ed2f2ac9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#744cc230ff757e6f218ba2e622a7f2c3">gc_heap_ceiling_address</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The top address of the heap. </dd></dl>
 <a href="#744cc230ff757e6f218ba2e622a7f2c3"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Routines to support the initialization and termination of GC</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#2219b56191a9f64d39946d12e4fcba1a">gc_init</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is called by VM to start <a class="el" href="struct_g_c.html">GC</a> initialization sequence.  <a href="#2219b56191a9f64d39946d12e4fcba1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#c19b42050dff047f1d0f0f7a149d755c">gc_test_safepoint</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">May be called at various points the VM decides are GC-safe.  <a href="#c19b42050dff047f1d0f0f7a149d755c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#1315d477e0a6ef29636c415025fd22da">gc_supports_frontier_allocation</a> (unsigned *offset_of_current, unsigned *offset_of_limit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the <a class="el" href="struct_g_c.html">GC</a> supports a "bump-the-pointer" style allocation, where the GC's thread-local information contains a "current" pointer and a "limit" pointer, then it should return <code>TRUE</code>, and it should set <code>*offset_of_current</code> to be the offset into the <a class="el" href="struct_g_c.html">GC</a> thread block of the "current" pointer, and similar for <code>*offset_of_limit</code> and the "limit" pointer.  <a href="#1315d477e0a6ef29636c415025fd22da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#7c79e8effeb09d4850a4f9713836b564">gc_vm_initialized</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This API is used by the VM to notify the <a class="el" href="struct_g_c.html">GC</a> that the VM has completed bootstrapping and initialization, and is henceforth ready to field requests for enumerating live references.  <a href="#7c79e8effeb09d4850a4f9713836b564"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#5ff092626dee2bae894be76fac81f830">gc_wrapup</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is called once the VM has no use for the heap or the garbage collector data structures.  <a href="#5ff092626dee2bae894be76fac81f830"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#bbf60a495af4409510234b350e45bd63">gc_add_root_set_entry</a> (Managed_Object_Handle *ref, Boolean is_pinned)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is called by the VM to enumerate the root reference.  <a href="#bbf60a495af4409510234b350e45bd63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#d70a51a28e456dbe215451b2336a40da">gc_add_compressed_root_set_entry</a> (uint32 *ref, Boolean is_pinned)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resembles <code><a class="el" href="gc_8h.html#bbf60a495af4409510234b350e45bd63" title="Is called by the VM to enumerate the root reference.">gc_add_root_set_entry()</a></code> but is passed the address of a slot containing a compressed reference.  <a href="#d70a51a28e456dbe215451b2336a40da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#5f0dc3bc779ca12d08de0180aeb1b0b2">gc_add_weak_root_set_entry</a> (Managed_Object_Handle *slot, Boolean is_pinned, Boolean is_short_weak)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is called by the VM to enumerate weak root reference.  <a href="#5f0dc3bc779ca12d08de0180aeb1b0b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#8dc020cd9f69ca688cbc2fc8c214b1c4">gc_add_root_set_entry_managed_pointer</a> (void **slot, Boolean is_pinned)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerate a managed pointer.  <a href="#8dc020cd9f69ca688cbc2fc8c214b1c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#5d668f3e91361c77c2e5fb5f2d8b0931">gc_add_root_set_entry_interior_pointer</a> (void **slot, int offset, Boolean is_pinned)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call from the VM to the gc to enumerate an interior pointer.  <a href="#5d668f3e91361c77c2e5fb5f2d8b0931"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Managed_Object_Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#4b4fe81dbdc77121fad2708f83ad3caf">gc_alloc_fast</a> (unsigned size, Allocation_Handle type, void *thread_pointer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine is the primary routine used to allocate objects.  <a href="#4b4fe81dbdc77121fad2708f83ad3caf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Managed_Object_Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#35a75c768f276016f4fc5ac0279c5765">gc_alloc</a> (unsigned size, Allocation_Handle type, void *thread_pointer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine is used to allocate an object.  <a href="#35a75c768f276016f4fc5ac0279c5765"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Managed_Object_Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#b70b661fc322c740f6d80ec692ef5210">gc_pinned_malloc_noclass</a> (unsigned size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For bootstrapping situations, when we still don't have a class for the object.  <a href="#b70b661fc322c740f6d80ec692ef5210"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Managed_Object_Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#d6f110a15dd4ed4cf7b81d0100c1cefa">gc_alloc_pinned</a> (unsigned size, Allocation_Handle type, void *thread_pointer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate pinned forever object.  <a href="#d6f110a15dd4ed4cf7b81d0100c1cefa"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Routines to support write barriers</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#cd925b0759a881359bc139b9403a22de">gc_requires_barriers</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the <a class="el" href="struct_g_c.html">GC</a> requires write barriers before every store to a field of a reference type. </dd></dl>
 <a href="#cd925b0759a881359bc139b9403a22de"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Routines to support various write barriers</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#926b00265b084669bae8725c69f9243d">gc_supports_compressed_references</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if references within objects and vector elements are to be treated as offsets rather than raw pointers. </dd></dl>
 <a href="#926b00265b084669bae8725c69f9243d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#587b758904e50f4cddb3cac9b055fcc9">gc_write_barrier</a> (Managed_Object_Handle p_base_of_obj_with_slot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">These interfaces are marked for replacement for the IPF by the following <code>gc_heap_write_mumble</code> interface.  <a href="#587b758904e50f4cddb3cac9b055fcc9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#af790401ccb8e6885578892182c958e5">gc_heap_wrote_object</a> (Managed_Object_Handle p_base_of_object_just_written)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">There are two flavors for historical reasons.  <a href="#af790401ccb8e6885578892182c958e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#7d1c590191db4b3ed837a152e721665c">gc_heap_write_global_slot</a> (Managed_Object_Handle *p_slot, Managed_Object_Handle value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">By calling this function VM notifies <a class="el" href="struct_g_c.html">GC</a> that a heap reference was written to global slot.  <a href="#7d1c590191db4b3ed837a152e721665c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#49d8de1920a3f990e8daa819a6c259eb">gc_heap_write_global_slot_compressed</a> (uint32 *p_slot, Managed_Object_Handle value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">VM should call this function on heap reference writes to global slots.  <a href="#49d8de1920a3f990e8daa819a6c259eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#e8422d2c3b6d4ed781a7c0141bb2d183">gc_heap_write_ref</a> (Managed_Object_Handle p_base_of_object_with_slot, unsigned offset, Managed_Object_Handle value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">VM should call this function on heap reference writes to heap objects.  <a href="#e8422d2c3b6d4ed781a7c0141bb2d183"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#7ec5b262059f83483fd994ae98c8fdf0">gc_heap_slot_write_ref</a> (Managed_Object_Handle p_base_of_object_with_slot, Managed_Object_Handle *p_slot, Managed_Object_Handle value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">VM should call this function on heap reference writes to heap objects.   <a href="#7ec5b262059f83483fd994ae98c8fdf0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#8f13b25d23f673c350f4ec2dd572763a">gc_heap_slot_write_ref_compressed</a> (Managed_Object_Handle p_base_of_object_with_slot, uint32 *p_slot, Managed_Object_Handle value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">VM should call this function on heap reference writes to heap objects.   <a href="#8f13b25d23f673c350f4ec2dd572763a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#2ef343f531ca2cacb28c328b15cf2b35">gc_pin_object</a> (Managed_Object_Handle *p_object)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pin object.  <a href="#2ef343f531ca2cacb28c328b15cf2b35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#283cd2a6e4aec7a0318ef2a3de3df1a5">gc_unpin_object</a> (Managed_Object_Handle *p_object)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpin object.  <a href="#283cd2a6e4aec7a0318ef2a3de3df1a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#cd4f3b3443c91702a8eb799fbd1da0c5">gc_get_hashcode</a> (Managed_Object_Handle object)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get identity hashcode.  <a href="#cd4f3b3443c91702a8eb799fbd1da0c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Managed_Object_Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#c46a0690d24ad5220a48bad40c0a0b45">gc_get_next_live_object</a> (void *iterator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate all live objects in heap.  <a href="#c46a0690d24ad5220a48bad40c0a0b45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#39769b015d1fdf9f4c5fd3794fff2ffb">gc_iterate_heap</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates all objects in the heap.  <a href="#39769b015d1fdf9f4c5fd3794fff2ffb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#45feebf234662e53fb1e603a4150e98d">gc_finalize_on_exit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves all finalizable objects to vm finalization queue.  <a href="#45feebf234662e53fb1e603a4150e98d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#705f0fd77ba651caf40fc6e760b67cbf">gc_set_mutator_block_flag</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the mutator need block flag in case of heavy finalizable object load.  <a href="#705f0fd77ba651caf40fc6e760b67cbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#c340c4b34816da375f5908caeaf43999">gc_clear_mutator_block_flag</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the mutator need block flag when heavy finalizable object load lightens.  <a href="#c340c4b34816da375f5908caeaf43999"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#131d20043682252d19b81ed0b820b918">gc_supports_class_unloading</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if references within objects and vector elements are to be treated as offsets rather than raw pointers. </dd></dl>
 <a href="#131d20043682252d19b81ed0b820b918"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Routines to support soft, weak, and phantom reference objects</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void JNICALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#109e746eef78fb57ad759e83f3f33c10">Java_java_lang_ref_Reference_enqueue_reference</a> (JNIEnv *the_env, jobject p_obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reference - the reference object to register.  <a href="#109e746eef78fb57ad759e83f3f33c10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">jobject JNICALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#73a3194f747ba5146fb79dad163e765d">Java_java_lang_ref_Reference_get</a> (JNIEnv *the_env, jobject p_obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reference - the reference object to register.  <a href="#73a3194f747ba5146fb79dad163e765d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void JNICALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#c70a9e906754c45cf5869995ecb48b0f">Java_java_lang_ref_Reference_register_phantom_ref</a> (JNIEnv *the_env, jobject p_obj, jobject referent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reference - the reference object to register.  <a href="#c70a9e906754c45cf5869995ecb48b0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void JNICALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#b4ca8f0ecdeb5fca563fc8decfd81903">Java_java_lang_ref_Reference_register_soft_ref</a> (JNIEnv *the_env, jobject p_obj, jobject referent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reference - the reference object to register.  <a href="#b4ca8f0ecdeb5fca563fc8decfd81903"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void JNICALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gc_8h.html#e85e9c734ee30f551bf6b78958d1c25f">Java_java_lang_ref_Reference_register_weak_ref</a> (JNIEnv *the_env, jobject p_obj, jobject referent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reference - the reference object to register.  <a href="#e85e9c734ee30f551bf6b78958d1c25f"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="81fcc009f47408a44372a8392507077d"></a><!-- doxytag: member="gc.h::GCExport" ref="81fcc009f47408a44372a8392507077d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GCExport&nbsp;&nbsp;&nbsp;__declspec(dllexport)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>GCExport</code> is used to declare functions exported by <a class="el" href="struct_g_c.html">GC</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="369ecd38b3ab077fc235f892354bb46f"></a><!-- doxytag: member="gc.h::BITS_PER_BYTE" ref="369ecd38b3ab077fc235f892354bb46f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITS_PER_BYTE&nbsp;&nbsp;&nbsp;8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="793871c3e34e62c041444eec143e3842"></a><!-- doxytag: member="gc.h::NEXT_TO_HIGH_BIT_SET_MASK" ref="793871c3e34e62c041444eec143e3842" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NEXT_TO_HIGH_BIT_SET_MASK&nbsp;&nbsp;&nbsp;(1&lt;&lt;((sizeof(unsigned) * BITS_PER_BYTE)-2))          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="711865edab513e1984fc6f5010e581db"></a><!-- doxytag: member="gc.h::NEXT_TO_HIGH_BIT_CLEAR_MASK" ref="711865edab513e1984fc6f5010e581db" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NEXT_TO_HIGH_BIT_CLEAR_MASK&nbsp;&nbsp;&nbsp;~NEXT_TO_HIGH_BIT_SET_MASK          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2829c549c88f82d3d2eb0423e86d414c"></a><!-- doxytag: member="gc.h::GC_OBJECT_ALIGNMENT" ref="2829c549c88f82d3d2eb0423e86d414c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GC_OBJECT_ALIGNMENT&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Granularity of object alignment. 
<p>
Objects are aligned on 4 or 8 bytes. If they are aligned on 8 bytes then Arrays will be required to start on the indicated alignement. This means that for 8 byte alignment on the IA32 the header will look like this:<p>
uint32 gc_header_lock_hash VTable *vt uint32 array_length uint32 padding the array elements. 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="4527ed2193d8094d3b5a108abef2ba32"></a><!-- doxytag: member="gc.h::Thread_Handle" ref="4527ed2193d8094d3b5a108abef2ba32" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="gc__for__class_8h.html#4527ed2193d8094d3b5a108abef2ba32">Thread_Handle</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opaque handle for threads. 
<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="2219b56191a9f64d39946d12e4fcba1a"></a><!-- doxytag: member="gc.h::gc_init" ref="2219b56191a9f64d39946d12e4fcba1a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gc_init           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is called by VM to start <a class="el" href="struct_g_c.html">GC</a> initialization sequence. 
<p>
This function is expected to initialize the <a class="el" href="struct_g_c.html">GC</a> internal data structures. The VM should call this *before* any other calls to this interface The <a class="el" href="struct_g_c.html">GC</a> assumes that the VM is ready to support a <a class="el" href="struct_g_c.html">GC</a> if it calls this function. 
</div>
</div><p>
<a class="anchor" name="c19b42050dff047f1d0f0f7a149d755c"></a><!-- doxytag: member="gc.h::gc_test_safepoint" ref="c19b42050dff047f1d0f0f7a149d755c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_test_safepoint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
May be called at various points the VM decides are GC-safe. 
<p>
The <a class="el" href="struct_g_c.html">GC</a> may ignore this, or it may force a root set enumeration, or it may execute a full <a class="el" href="struct_g_c.html">GC</a>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Optional debug interface. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1315d477e0a6ef29636c415025fd22da"></a><!-- doxytag: member="gc.h::gc_supports_frontier_allocation" ref="1315d477e0a6ef29636c415025fd22da" args="(unsigned *offset_of_current, unsigned *offset_of_limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean gc_supports_frontier_allocation           </td>
          <td>(</td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>offset_of_current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>offset_of_limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the <a class="el" href="struct_g_c.html">GC</a> supports a "bump-the-pointer" style allocation, where the GC's thread-local information contains a "current" pointer and a "limit" pointer, then it should return <code>TRUE</code>, and it should set <code>*offset_of_current</code> to be the offset into the <a class="el" href="struct_g_c.html">GC</a> thread block of the "current" pointer, and similar for <code>*offset_of_limit</code> and the "limit" pointer. 
<p>
If not, then it should return <code>FALSE</code>. 
</div>
</div><p>
<a class="anchor" name="7c79e8effeb09d4850a4f9713836b564"></a><!-- doxytag: member="gc.h::gc_vm_initialized" ref="7c79e8effeb09d4850a4f9713836b564" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_vm_initialized           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This API is used by the VM to notify the <a class="el" href="struct_g_c.html">GC</a> that the VM has completed bootstrapping and initialization, and is henceforth ready to field requests for enumerating live references. 
<p>
Prior to this function being called the <a class="el" href="struct_g_c.html">GC</a> might see some strange sights such as <code>NULL</code> or incomplete vtables. The <a class="el" href="struct_g_c.html">GC</a> will need to consider these as normal and work with the VM to ensure that bootstrapping works. This means that the <a class="el" href="struct_g_c.html">GC</a> will make few demands on the VM prior to this routine being called.<p>
However, once called the <a class="el" href="struct_g_c.html">GC</a> will feel free to do stop-the-world collections and will assume that the entire <code>gc_import.h</code> interface is available and fully functioning.<p>
If this routine is called twice the result is undefined. 
</div>
</div><p>
<a class="anchor" name="5ff092626dee2bae894be76fac81f830"></a><!-- doxytag: member="gc.h::gc_wrapup" ref="5ff092626dee2bae894be76fac81f830" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_wrapup           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is called once the VM has no use for the heap or the garbage collector data structures. 
<p>
The assumption is that the VM is exiting but needs to give the <a class="el" href="struct_g_c.html">GC</a> time to run destructors and free up memory it has gotten from the OS. After this routine has been called the VM can not relie on any data structures created by the <a class="el" href="struct_g_c.html">GC</a>.<p>
Errors: If <code>gc_enumerate_finalizable_objects</code> has been called and <code>gc_wrapup</code> gc discovers an object that has not had it finalizer run then it will attempt to report an error. 
</div>
</div><p>
<a class="anchor" name="bbf60a495af4409510234b350e45bd63"></a><!-- doxytag: member="gc.h::gc_add_root_set_entry" ref="bbf60a495af4409510234b350e45bd63" args="(Managed_Object_Handle *ref, Boolean is_pinned)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_add_root_set_entry           </td>
          <td>(</td>
          <td class="paramtype">Managed_Object_Handle *&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean&nbsp;</td>
          <td class="paramname"> <em>is_pinned</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is called by the VM to enumerate the root reference. 
<p>

</div>
</div><p>
<a class="anchor" name="d70a51a28e456dbe215451b2336a40da"></a><!-- doxytag: member="gc.h::gc_add_compressed_root_set_entry" ref="d70a51a28e456dbe215451b2336a40da" args="(uint32 *ref, Boolean is_pinned)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_add_compressed_root_set_entry           </td>
          <td>(</td>
          <td class="paramtype">uint32 *&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean&nbsp;</td>
          <td class="paramname"> <em>is_pinned</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resembles <code><a class="el" href="gc_8h.html#bbf60a495af4409510234b350e45bd63" title="Is called by the VM to enumerate the root reference.">gc_add_root_set_entry()</a></code> but is passed the address of a slot containing a compressed reference. 
<p>

</div>
</div><p>
<a class="anchor" name="5f0dc3bc779ca12d08de0180aeb1b0b2"></a><!-- doxytag: member="gc.h::gc_add_weak_root_set_entry" ref="5f0dc3bc779ca12d08de0180aeb1b0b2" args="(Managed_Object_Handle *slot, Boolean is_pinned, Boolean is_short_weak)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_add_weak_root_set_entry           </td>
          <td>(</td>
          <td class="paramtype">Managed_Object_Handle *&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean&nbsp;</td>
          <td class="paramname"> <em>is_pinned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean&nbsp;</td>
          <td class="paramname"> <em>is_short_weak</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is called by the VM to enumerate weak root reference. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>- a pointer to the slot, containing the weak root </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_pinned</em>&nbsp;</td><td>- <code>TRUE</code> denotes that object pointed-to from this slot should not be moved during garbage collection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_short_weak</em>&nbsp;</td><td>- <code>TRUE</code> means that the weak root must be cleared before object becomes eligible for finalization </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8dc020cd9f69ca688cbc2fc8c214b1c4"></a><!-- doxytag: member="gc.h::gc_add_root_set_entry_managed_pointer" ref="8dc020cd9f69ca688cbc2fc8c214b1c4" args="(void **slot, Boolean is_pinned)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_add_root_set_entry_managed_pointer           </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean&nbsp;</td>
          <td class="paramname"> <em>is_pinned</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumerate a managed pointer. 
<p>
The pointer can be declared as pinned. The pointer can point to the managed heap or any other area where data can be stored: stack or static fields. It is the responsibility of the <a class="el" href="struct_g_c.html">GC</a> to ignore pointers that are not in the managed heap.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Is this function needed for Java? -salikh </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d668f3e91361c77c2e5fb5f2d8b0931"></a><!-- doxytag: member="gc.h::gc_add_root_set_entry_interior_pointer" ref="5d668f3e91361c77c2e5fb5f2d8b0931" args="(void **slot, int offset, Boolean is_pinned)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_add_root_set_entry_interior_pointer           </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean&nbsp;</td>
          <td class="paramname"> <em>is_pinned</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call from the VM to the gc to enumerate an interior pointer. 
<p>
<code>**ref</code> is a slot holding a pointer into the interior of an object. The base of the object is located at <code>*ref</code> - offset. The strategy employed is to place the slot, the object base and the offset into a <code>slot_base_offset</code> table. We then call <code>gc_add_root_set_entry</code> with the slot in the table holding the base of the object. Upon completion of the garbage collection the routine <code>fixup_interior_pointers</code> is called and the <code>slot_base_offset</code> table is traversed and the new interior pointer is calculated by adding the base of the object and the offset. This new interior pointer value is then placed into the slot.<p>
This routine can be called multiple times with the same interiour pointer without any problems. The offset is checked to make sure it is positive but the logic is not dependent on this fact.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Optional function, never called by Java virtual machine. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4b4fe81dbdc77121fad2708f83ad3caf"></a><!-- doxytag: member="gc.h::gc_alloc_fast" ref="4b4fe81dbdc77121fad2708f83ad3caf" args="(unsigned size, Allocation_Handle type, void *thread_pointer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Managed_Object_Handle gc_alloc_fast           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocation_Handle&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>thread_pointer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine is the primary routine used to allocate objects. 
<p>
It assumes nothing about the state of the VM internal data structures or the runtime stack. If gc_malloc_or_null is able to allocate the object without invoking a <a class="el" href="struct_g_c.html">GC</a> or calling the VM then it does so. It places p_vtable into the object, ensures that the object is zeroed and then returns a ManagedObject pointer to the object. If it is not able to allocate the object without invoking a <a class="el" href="struct_g_c.html">GC</a> then it returns NULL.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>- the size of the object to allocate. If the high bit set then various constraints as described above are placed on the allocation of this object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>- a pointer to the vtable of the class being allocated. This routine will place this value in the appropriate slot of the new object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thread_pointer</em>&nbsp;</td><td>- a pointer to the GC's thread-local space</td></tr>
  </table>
</dl>
This is like <code>gc_malloc_or_null</code>, except that it passes a pointer to the thread's GC-specific space as a third argument. This prevents the <a class="el" href="struct_g_c.html">GC</a> from having to immediately call <code>vm_get_thread_curr_alloc_block()</code> as its first task.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Rename of <code>gc_malloc_with_thread_pointer()</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="35a75c768f276016f4fc5ac0279c5765"></a><!-- doxytag: member="gc.h::gc_alloc" ref="35a75c768f276016f4fc5ac0279c5765" args="(unsigned size, Allocation_Handle type, void *thread_pointer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Managed_Object_Handle gc_alloc           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocation_Handle&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>thread_pointer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine is used to allocate an object. 
<p>
See the above discussion on the overloading of size. {link allocation}<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>- the size of the object to allocate. If the high bit set then various constraints as described above are placed on the allocation of this object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>- a pointer to the vtable of the class being allocated. This routine will place this value in the appropriate slot of the new object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thread_pointer</em>&nbsp;</td><td>- a pointer to the GC's thread-local space</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Rename of <code>gc_malloc_or_null_with_thread_pointer()</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b70b661fc322c740f6d80ec692ef5210"></a><!-- doxytag: member="gc.h::gc_pinned_malloc_noclass" ref="b70b661fc322c740f6d80ec692ef5210" args="(unsigned size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Managed_Object_Handle gc_pinned_malloc_noclass           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For bootstrapping situations, when we still don't have a class for the object. 
<p>
This routine is only available prior to a call to the call <code>gc_vm_initialized<code>. If it is called after the call to <code>gc_vm_initialized</code> then the results are undefined. The <a class="el" href="struct_g_c.html">GC</a> places <code>NULL</code> in the vtable slot of the newly allocated object.</code></code><p>
<code><code> The object allocated will be pinned, not finalizable and not an array.</code></code><p>
<code><code> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>- the size of the object to allocate. The high bit will never be set on this argument.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The newly allocated object.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Will be renamed to <code>gc_alloc_pinned_noclass()</code> to comply with accepted naming conventions. </dd></dl>
</code></code>
</div>
</div><p>
<a class="anchor" name="d6f110a15dd4ed4cf7b81d0100c1cefa"></a><!-- doxytag: member="gc.h::gc_alloc_pinned" ref="d6f110a15dd4ed4cf7b81d0100c1cefa" args="(unsigned size, Allocation_Handle type, void *thread_pointer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Managed_Object_Handle gc_alloc_pinned           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocation_Handle&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>thread_pointer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate pinned forever object. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Not implemented. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cd925b0759a881359bc139b9403a22de"></a><!-- doxytag: member="gc.h::gc_requires_barriers" ref="cd925b0759a881359bc139b9403a22de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean gc_requires_barriers           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the <a class="el" href="struct_g_c.html">GC</a> requires write barriers before every store to a field of a reference type. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="2a40bfac9c162aa2a5c3e20f159fc36b"></a><!-- doxytag: member="gc.h::gc_thread_init" ref="2a40bfac9c162aa2a5c3e20f159fc36b" args="(void *gc_information)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_thread_init           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>gc_information</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine is called during thread startup to set an initial nursery for the thread. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><code>gc_thread_init</code> and <code>gc_thread_kill</code> assume that the current thread is the one we are interested in. If we passed in the thread then these things could be cross inited and cross killed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d45e22b73f5a30732556861371759f8c"></a><!-- doxytag: member="gc.h::gc_thread_kill" ref="d45e22b73f5a30732556861371759f8c" args="(void *gc_information)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_thread_kill           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>gc_information</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is called just before the thread is reclaimed. 
<p>

</div>
</div><p>
<a class="anchor" name="c0c3197301e8aa22c395e71bc002b95e"></a><!-- doxytag: member="gc.h::vm_iterate_threads" ref="c0c3197301e8aa22c395e71bc002b95e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void vm_iterate_threads           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="struct_g_c.html">GC</a> may call this function asynchronously any time it wants to get thread list. 
<p>
This function signals VM to obtain thread lock and start thread iteration.<p>
<ul>
<li>vm obtains thread lock </li>
<li>vm repeatedly calls <code>gc_iterate_thread(thread)</code> </li>
<li>vm releases thread lock</li>
</ul>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Not implemented. </dd></dl>

</div>
</div><p>
<a class="anchor" name="102b8aa8e3719e76f39aebc111296ef4"></a><!-- doxytag: member="gc.h::gc_iterate_thread" ref="102b8aa8e3719e76f39aebc111296ef4" args="(Thread_Handle thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_iterate_thread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gc__for__class_8h.html#4527ed2193d8094d3b5a108abef2ba32">Thread_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
VM calls this method repeatedly to iterate over the list of java threads, initiated earlier by calling <code><a class="el" href="gc_8h.html#c0c3197301e8aa22c395e71bc002b95e" title="GC may call this function asynchronously any time it wants to get thread list.">vm_iterate_threads()</a></code>. 
<p>
Thread creation and termination is locked during this iteration.<p>
gc may do one of the following: 1. store thread handle for later use 2. enumerate thread right now, while holding thread lock (using <code>vm_suspend_thread(thread)</code> and <code>vm_enumerate_thread_root_set(thread)</code>).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Not implemented. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8ae27ead06e40ffe09ba4ca0939c466e"></a><!-- doxytag: member="gc.h::vm_suspend_thread" ref="8ae27ead06e40ffe09ba4ca0939c466e" args="(Thread_Handle thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void vm_suspend_thread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gc__for__class_8h.html#4527ed2193d8094d3b5a108abef2ba32">Thread_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="struct_g_c.html">GC</a> calls this method to request VM to suspend an individual thread. 
<p>
After the thread is suspended, 0 is returned on success<p>
Thread may have been terminated already, in this case non-zero value is returned, and no additional actions are taken.<p>
<a class="el" href="struct_g_c.html">GC</a> calls this VM function when it wants a thread to be suspended for stack enumeration or read/write barrier change.<p>
blocks until synchronously call <code>gc_thread_suspended(thread)</code> or asynchronously delegate enumeration to thread (self-enumeration)<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>We need a way to signal that process of thread suspension is complete.<p>
Not implemented. </dd></dl>

</div>
</div><p>
<a class="anchor" name="78522721ab44728df9d8449c14e8ba10"></a><!-- doxytag: member="gc.h::gc_thread_suspended" ref="78522721ab44728df9d8449c14e8ba10" args="(Thread_Handle thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_thread_suspended           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gc__for__class_8h.html#4527ed2193d8094d3b5a108abef2ba32">Thread_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
VM calls this <a class="el" href="struct_g_c.html">GC</a> callback when it's accomplished the requested operation of suspending a thread in gc-safe point. 
<p>
May be called synchronously from the same context as <code><a class="el" href="gc_8h.html#8ae27ead06e40ffe09ba4ca0939c466e" title="GC calls this method to request VM to suspend an individual thread.">vm_suspend_thread()</a></code> in case of cross-enumeration, or may be called asynchronously from the specified thread context in case of self-enumeration.<p>
After this function completes, the thread is resumed automatically.<p>
<a class="el" href="struct_g_c.html">GC</a> is expected to call a limited subset of GC-VM interface functions from this callback: <ul>
<li><code>vm_enumerate_thread_root_set(thread)</code> </li>
<li><code>vm_install_write_barrier(...)</code> (hypothetical, not designed yet) </li>
<li>make a thread stack snapshot for later analysis</li>
</ul>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Not implemented. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a50c9904148f0f1786bcee6caf5c6aca"></a><!-- doxytag: member="gc.h::vm_enumerate_thread_root_set" ref="a50c9904148f0f1786bcee6caf5c6aca" args="(Thread_Handle thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void vm_enumerate_thread_root_set           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gc__for__class_8h.html#4527ed2193d8094d3b5a108abef2ba32">Thread_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="struct_g_c.html">GC</a> calls this function to command VM to enumerate a thread, which was earlier suspenden using <code><a class="el" href="gc_8h.html#8ae27ead06e40ffe09ba4ca0939c466e" title="GC calls this method to request VM to suspend an individual thread.">vm_suspend_thread()</a></code>. 
<p>
In response to this call, VM repeatedly calls <code><a class="el" href="gc_8h.html#bbf60a495af4409510234b350e45bd63" title="Is called by the VM to enumerate the root reference.">gc_add_root_set_entry()</a></code> to enumerate thread stacks and local handles<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Not implemented. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dc32d8ca99b9c801d2fd3eebbef8b3d0"></a><!-- doxytag: member="gc.h::vm_enumerate_global_root_set" ref="dc32d8ca99b9c801d2fd3eebbef8b3d0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void vm_enumerate_global_root_set           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="struct_g_c.html">GC</a> calls this function to command VM to enumerate global slots. 
<p>
During enumeration of global root set, either all threads need to be suspended, or write barrier installed.<p>
Apparently some operations should be blocked in VM, like class loading, which itself creates new global reference slots. It is not clear to me if we should require stopping the world to use this function or introduce new system-wide lock on operations that change the number of global reference slots.<p>
This function calls <code><a class="el" href="gc_8h.html#bbf60a495af4409510234b350e45bd63" title="Is called by the VM to enumerate the root reference.">gc_add_root_set_entry()</a></code> for all global reference slots.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Not implemented. </dd></dl>

</div>
</div><p>
<a class="anchor" name="39127f4fd57eef7e8898a1ddefa07098"></a><!-- doxytag: member="gc.h::gc_force_gc" ref="39127f4fd57eef7e8898a1ddefa07098" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_force_gc           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
API for the VM to force a <a class="el" href="struct_g_c.html">GC</a>, typically in response to a call to <code>java.lang.Runtime.gc</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="7bcb1b938d1ab523ca0638db25526bd5"></a><!-- doxytag: member="gc.h::gc_total_memory" ref="7bcb1b938d1ab523ca0638db25526bd5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 gc_total_memory           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
API for the VM to determine the current <a class="el" href="struct_g_c.html">GC</a> heap size, typically in response to a call to <code>java.lang.Runtime.totalMemory</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="f6fdd3e193b8314444e6707f17043015"></a><!-- doxytag: member="gc.h::gc_max_memory" ref="f6fdd3e193b8314444e6707f17043015" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 gc_max_memory           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
API for the VM to determine the maximum <a class="el" href="struct_g_c.html">GC</a> heap size, typically in response to a call to <code>java.lang.Runtime.maxMemory</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="012dae57769b691038a0ce341675101d"></a><!-- doxytag: member="gc.h::gc_free_memory" ref="012dae57769b691038a0ce341675101d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 gc_free_memory           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
API for the VM to get an approximate view of the free space, typically in response to a call to <code>java.lang.Runtime.freeMemory</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="99d618103fc0cfc461905c5a01b36a7f"></a><!-- doxytag: member="gc.h::gc_is_object_pinned" ref="99d618103fc0cfc461905c5a01b36a7f" args="(Managed_Object_Handle obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean gc_is_object_pinned           </td>
          <td>(</td>
          <td class="paramtype">Managed_Object_Handle&nbsp;</td>
          <td class="paramname"> <em>obj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the object is pinned. </dd></dl>

<p>
Routine to support the functionality required by JNI to see if an object is pinned. 
</div>
</div><p>
<a class="anchor" name="76617bcedc9e24a83e47731bae2f1c30"></a><!-- doxytag: member="gc.h::gc_class_prepared" ref="76617bcedc9e24a83e47731bae2f1c30" args="(Class_Handle ch, VTable_Handle vth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_class_prepared           </td>
          <td>(</td>
          <td class="paramtype">Class_Handle&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VTable_Handle&nbsp;</td>
          <td class="paramname"> <em>vth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The VM calls this function after a new class has been prepared. 
<p>
The <a class="el" href="struct_g_c.html">GC</a> can use a call interface to gather relevant information about that class and store it in area of the VTable that is reserved for <a class="el" href="struct_g_c.html">GC</a>. The information cached in the VTable should be used by the <a class="el" href="struct_g_c.html">GC</a> in performance sensitive functions like object scanning. 
</div>
</div><p>
<a class="anchor" name="cdd1ae174432577e9446b89c23d9acca"></a><!-- doxytag: member="gc.h::gc_get_collection_count" ref="cdd1ae174432577e9446b89c23d9acca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 gc_get_collection_count           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of collections that have been executed by this collector. A value of <code>-1</code> means that collection counts are undefined for this collector. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of collections executed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fbbe2d49b86baa0778c09eefc420f926"></a><!-- doxytag: member="gc.h::gc_get_collection_time" ref="fbbe2d49b86baa0778c09eefc420f926" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 gc_get_collection_time           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The approximate, cumulative time (in microseconds) spent executing collections for this collector. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The time spent collecting garbage. </dd></dl>

</div>
</div><p>
<a class="anchor" name="926b00265b084669bae8725c69f9243d"></a><!-- doxytag: member="gc.h::gc_supports_compressed_references" ref="926b00265b084669bae8725c69f9243d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean gc_supports_compressed_references           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if references within objects and vector elements are to be treated as offsets rather than raw pointers. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="587b758904e50f4cddb3cac9b055fcc9"></a><!-- doxytag: member="gc.h::gc_write_barrier" ref="587b758904e50f4cddb3cac9b055fcc9" args="(Managed_Object_Handle p_base_of_obj_with_slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_write_barrier           </td>
          <td>(</td>
          <td class="paramtype">Managed_Object_Handle&nbsp;</td>
          <td class="paramname"> <em>p_base_of_obj_with_slot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
These interfaces are marked for replacement for the IPF by the following <code>gc_heap_write_mumble</code> interface. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Will be removed soon. </dd></dl>

</div>
</div><p>
<a class="anchor" name="af790401ccb8e6885578892182c958e5"></a><!-- doxytag: member="gc.h::gc_heap_wrote_object" ref="af790401ccb8e6885578892182c958e5" args="(Managed_Object_Handle p_base_of_object_just_written)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_heap_wrote_object           </td>
          <td>(</td>
          <td class="paramtype">Managed_Object_Handle&nbsp;</td>
          <td class="paramname"> <em>p_base_of_object_just_written</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
There are two flavors for historical reasons. 
<p>
The compiler for IA32 will produce code for the version using an offset.<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Will be removed soon. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7d1c590191db4b3ed837a152e721665c"></a><!-- doxytag: member="gc.h::gc_heap_write_global_slot" ref="7d1c590191db4b3ed837a152e721665c" args="(Managed_Object_Handle *p_slot, Managed_Object_Handle value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_heap_write_global_slot           </td>
          <td>(</td>
          <td class="paramtype">Managed_Object_Handle *&nbsp;</td>
          <td class="paramname"> <em>p_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Managed_Object_Handle&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
By calling this function VM notifies <a class="el" href="struct_g_c.html">GC</a> that a heap reference was written to global slot. 
<p>
There are some global slots that are shared by different threads. Write barriers implementation needs to know about writes to these slots. One example of such slots is in the string pools used by the class loader. 
</div>
</div><p>
<a class="anchor" name="49d8de1920a3f990e8daa819a6c259eb"></a><!-- doxytag: member="gc.h::gc_heap_write_global_slot_compressed" ref="49d8de1920a3f990e8daa819a6c259eb" args="(uint32 *p_slot, Managed_Object_Handle value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_heap_write_global_slot_compressed           </td>
          <td>(</td>
          <td class="paramtype">uint32 *&nbsp;</td>
          <td class="paramname"> <em>p_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Managed_Object_Handle&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
VM should call this function on heap reference writes to global slots. 
<p>
The "compressed" versions of the functions support updates to slots containing compressed references that are heap offsets; these functions handle details of converting raw reference pointers to compressed references before updating slots. 
</div>
</div><p>
<a class="anchor" name="e8422d2c3b6d4ed781a7c0141bb2d183"></a><!-- doxytag: member="gc.h::gc_heap_write_ref" ref="e8422d2c3b6d4ed781a7c0141bb2d183" args="(Managed_Object_Handle p_base_of_object_with_slot, unsigned offset, Managed_Object_Handle value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_heap_write_ref           </td>
          <td>(</td>
          <td class="paramtype">Managed_Object_Handle&nbsp;</td>
          <td class="paramname"> <em>p_base_of_object_with_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Managed_Object_Handle&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
VM should call this function on heap reference writes to heap objects. 
<p>

</div>
</div><p>
<a class="anchor" name="7ec5b262059f83483fd994ae98c8fdf0"></a><!-- doxytag: member="gc.h::gc_heap_slot_write_ref" ref="7ec5b262059f83483fd994ae98c8fdf0" args="(Managed_Object_Handle p_base_of_object_with_slot, Managed_Object_Handle *p_slot, Managed_Object_Handle value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_heap_slot_write_ref           </td>
          <td>(</td>
          <td class="paramtype">Managed_Object_Handle&nbsp;</td>
          <td class="paramname"> <em>p_base_of_object_with_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Managed_Object_Handle *&nbsp;</td>
          <td class="paramname"> <em>p_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Managed_Object_Handle&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
VM should call this function on heap reference writes to heap objects.  
<p>

</div>
</div><p>
<a class="anchor" name="8f13b25d23f673c350f4ec2dd572763a"></a><!-- doxytag: member="gc.h::gc_heap_slot_write_ref_compressed" ref="8f13b25d23f673c350f4ec2dd572763a" args="(Managed_Object_Handle p_base_of_object_with_slot, uint32 *p_slot, Managed_Object_Handle value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_heap_slot_write_ref_compressed           </td>
          <td>(</td>
          <td class="paramtype">Managed_Object_Handle&nbsp;</td>
          <td class="paramname"> <em>p_base_of_object_with_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&nbsp;</td>
          <td class="paramname"> <em>p_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Managed_Object_Handle&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
VM should call this function on heap reference writes to heap objects.  
<p>

</div>
</div><p>
<a class="anchor" name="2ef343f531ca2cacb28c328b15cf2b35"></a><!-- doxytag: member="gc.h::gc_pin_object" ref="2ef343f531ca2cacb28c328b15cf2b35" args="(Managed_Object_Handle *p_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_pin_object           </td>
          <td>(</td>
          <td class="paramtype">Managed_Object_Handle *&nbsp;</td>
          <td class="paramname"> <em>p_object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pin object. 
<p>

</div>
</div><p>
<a class="anchor" name="283cd2a6e4aec7a0318ef2a3de3df1a5"></a><!-- doxytag: member="gc.h::gc_unpin_object" ref="283cd2a6e4aec7a0318ef2a3de3df1a5" args="(Managed_Object_Handle *p_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_unpin_object           </td>
          <td>(</td>
          <td class="paramtype">Managed_Object_Handle *&nbsp;</td>
          <td class="paramname"> <em>p_object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unpin object. 
<p>

</div>
</div><p>
<a class="anchor" name="cd4f3b3443c91702a8eb799fbd1da0c5"></a><!-- doxytag: member="gc.h::gc_get_hashcode" ref="cd4f3b3443c91702a8eb799fbd1da0c5" args="(Managed_Object_Handle object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32 gc_get_hashcode           </td>
          <td>(</td>
          <td class="paramtype">Managed_Object_Handle&nbsp;</td>
          <td class="paramname"> <em>object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get identity hashcode. 
<p>

</div>
</div><p>
<a class="anchor" name="c46a0690d24ad5220a48bad40c0a0b45"></a><!-- doxytag: member="gc.h::gc_get_next_live_object" ref="c46a0690d24ad5220a48bad40c0a0b45" args="(void *iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Managed_Object_Handle gc_get_next_live_object           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterate all live objects in heap. 
<p>
Should be use only in classloader for class unloading purposes. 
</div>
</div><p>
<a class="anchor" name="39769b015d1fdf9f4c5fd3794fff2ffb"></a><!-- doxytag: member="gc.h::gc_iterate_heap" ref="39769b015d1fdf9f4c5fd3794fff2ffb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_iterate_heap           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterates all objects in the heap. 
<p>
This function calls <code>vm_iterate_object()</code> for each iterated object. Used for JVMTI Heap Iteration. Should be called only in stop-the-world setting<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><code>vm_gc.h.vm_iterate_object()</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="45feebf234662e53fb1e603a4150e98d"></a><!-- doxytag: member="gc.h::gc_finalize_on_exit" ref="45feebf234662e53fb1e603a4150e98d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_finalize_on_exit           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves all finalizable objects to vm finalization queue. 
<p>

</div>
</div><p>
<a class="anchor" name="705f0fd77ba651caf40fc6e760b67cbf"></a><!-- doxytag: member="gc.h::gc_set_mutator_block_flag" ref="705f0fd77ba651caf40fc6e760b67cbf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_set_mutator_block_flag           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the mutator need block flag in case of heavy finalizable object load. 
<p>

</div>
</div><p>
<a class="anchor" name="c340c4b34816da375f5908caeaf43999"></a><!-- doxytag: member="gc.h::gc_clear_mutator_block_flag" ref="c340c4b34816da375f5908caeaf43999" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean gc_clear_mutator_block_flag           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the mutator need block flag when heavy finalizable object load lightens. 
<p>

</div>
</div><p>
<a class="anchor" name="131d20043682252d19b81ed0b820b918"></a><!-- doxytag: member="gc.h::gc_supports_class_unloading" ref="131d20043682252d19b81ed0b820b918" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean gc_supports_class_unloading           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if references within objects and vector elements are to be treated as offsets rather than raw pointers. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="109e746eef78fb57ad759e83f3f33c10"></a><!-- doxytag: member="gc.h::Java_java_lang_ref_Reference_enqueue_reference" ref="109e746eef78fb57ad759e83f3f33c10" args="(JNIEnv *the_env, jobject p_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JNICALL Java_java_lang_ref_Reference_enqueue_reference           </td>
          <td>(</td>
          <td class="paramtype">JNIEnv *&nbsp;</td>
          <td class="paramname"> <em>the_env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">jobject&nbsp;</td>
          <td class="paramname"> <em>p_obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reference - the reference object to register. 
<p>
referent - the referent of the reference object that is to be retrieved with the get method.<p>
The weak reference code written in Java and the support code provide by the VM must agree on what the layout of a <code>Java.lang.ref.Reference</code> object looks like and agree that any subclassing will only append fields to the agreed upon layout. This seems reasonable.<p>
In addition the support code will have exclusive knowledge and control of a single field (called <code>the_referent</code>) which holds the reference to the target object. The java code will assume that this field is a read only integer and should not be traced by the gc. The <code>Java.lang.ref.ReferenceQueue</code> layout needs to also be known by the supporting code so that it can move reference objects onto the queues at the appropriate times. The Java code uses normal mechanisms to load the Reference classes and to create a reference.<p>
The constructor code however needs to call the appropriate register function listed below based upon whether we have a soft, weak, or phantom reference. The VM support code will fill in the referent field. The routine <code>gc_get_referent</code> will return the value in this field.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The phantom reference method get will not use the <code>gc_get_referent</code> but instead just return <code>NULL</code> as required by the spec.<p>
XXX Why are they in gc_export.h? -salikh </dd></dl>

</div>
</div><p>
<a class="anchor" name="73a3194f747ba5146fb79dad163e765d"></a><!-- doxytag: member="gc.h::Java_java_lang_ref_Reference_get" ref="73a3194f747ba5146fb79dad163e765d" args="(JNIEnv *the_env, jobject p_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">jobject JNICALL Java_java_lang_ref_Reference_get           </td>
          <td>(</td>
          <td class="paramtype">JNIEnv *&nbsp;</td>
          <td class="paramname"> <em>the_env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">jobject&nbsp;</td>
          <td class="paramname"> <em>p_obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reference - the reference object to register. 
<p>
referent - the referent of the reference object that is to be retrieved with the get method.<p>
The weak reference code written in Java and the support code provide by the VM must agree on what the layout of a <code>Java.lang.ref.Reference</code> object looks like and agree that any subclassing will only append fields to the agreed upon layout. This seems reasonable.<p>
In addition the support code will have exclusive knowledge and control of a single field (called <code>the_referent</code>) which holds the reference to the target object. The java code will assume that this field is a read only integer and should not be traced by the gc. The <code>Java.lang.ref.ReferenceQueue</code> layout needs to also be known by the supporting code so that it can move reference objects onto the queues at the appropriate times. The Java code uses normal mechanisms to load the Reference classes and to create a reference.<p>
The constructor code however needs to call the appropriate register function listed below based upon whether we have a soft, weak, or phantom reference. The VM support code will fill in the referent field. The routine <code>gc_get_referent</code> will return the value in this field.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The phantom reference method get will not use the <code>gc_get_referent</code> but instead just return <code>NULL</code> as required by the spec.<p>
XXX Why are they in gc_export.h? -salikh </dd></dl>

</div>
</div><p>
<a class="anchor" name="c70a9e906754c45cf5869995ecb48b0f"></a><!-- doxytag: member="gc.h::Java_java_lang_ref_Reference_register_phantom_ref" ref="c70a9e906754c45cf5869995ecb48b0f" args="(JNIEnv *the_env, jobject p_obj, jobject referent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JNICALL Java_java_lang_ref_Reference_register_phantom_ref           </td>
          <td>(</td>
          <td class="paramtype">JNIEnv *&nbsp;</td>
          <td class="paramname"> <em>the_env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">jobject&nbsp;</td>
          <td class="paramname"> <em>p_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">jobject&nbsp;</td>
          <td class="paramname"> <em>referent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reference - the reference object to register. 
<p>
referent - the referent of the reference object that is to be retrieved with the get method.<p>
The weak reference code written in Java and the support code provide by the VM must agree on what the layout of a <code>Java.lang.ref.Reference</code> object looks like and agree that any subclassing will only append fields to the agreed upon layout. This seems reasonable.<p>
In addition the support code will have exclusive knowledge and control of a single field (called <code>the_referent</code>) which holds the reference to the target object. The java code will assume that this field is a read only integer and should not be traced by the gc. The <code>Java.lang.ref.ReferenceQueue</code> layout needs to also be known by the supporting code so that it can move reference objects onto the queues at the appropriate times. The Java code uses normal mechanisms to load the Reference classes and to create a reference.<p>
The constructor code however needs to call the appropriate register function listed below based upon whether we have a soft, weak, or phantom reference. The VM support code will fill in the referent field. The routine <code>gc_get_referent</code> will return the value in this field.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The phantom reference method get will not use the <code>gc_get_referent</code> but instead just return <code>NULL</code> as required by the spec.<p>
XXX Why are they in gc_export.h? -salikh </dd></dl>

</div>
</div><p>
<a class="anchor" name="b4ca8f0ecdeb5fca563fc8decfd81903"></a><!-- doxytag: member="gc.h::Java_java_lang_ref_Reference_register_soft_ref" ref="b4ca8f0ecdeb5fca563fc8decfd81903" args="(JNIEnv *the_env, jobject p_obj, jobject referent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JNICALL Java_java_lang_ref_Reference_register_soft_ref           </td>
          <td>(</td>
          <td class="paramtype">JNIEnv *&nbsp;</td>
          <td class="paramname"> <em>the_env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">jobject&nbsp;</td>
          <td class="paramname"> <em>p_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">jobject&nbsp;</td>
          <td class="paramname"> <em>referent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reference - the reference object to register. 
<p>
referent - the referent of the reference object that is to be retrieved with the get method.<p>
The weak reference code written in Java and the support code provide by the VM must agree on what the layout of a <code>Java.lang.ref.Reference</code> object looks like and agree that any subclassing will only append fields to the agreed upon layout. This seems reasonable.<p>
In addition the support code will have exclusive knowledge and control of a single field (called <code>the_referent</code>) which holds the reference to the target object. The java code will assume that this field is a read only integer and should not be traced by the gc. The <code>Java.lang.ref.ReferenceQueue</code> layout needs to also be known by the supporting code so that it can move reference objects onto the queues at the appropriate times. The Java code uses normal mechanisms to load the Reference classes and to create a reference.<p>
The constructor code however needs to call the appropriate register function listed below based upon whether we have a soft, weak, or phantom reference. The VM support code will fill in the referent field. The routine <code>gc_get_referent</code> will return the value in this field.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The phantom reference method get will not use the <code>gc_get_referent</code> but instead just return <code>NULL</code> as required by the spec.<p>
XXX Why are they in gc_export.h? -salikh </dd></dl>

</div>
</div><p>
<a class="anchor" name="e85e9c734ee30f551bf6b78958d1c25f"></a><!-- doxytag: member="gc.h::Java_java_lang_ref_Reference_register_weak_ref" ref="e85e9c734ee30f551bf6b78958d1c25f" args="(JNIEnv *the_env, jobject p_obj, jobject referent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JNICALL Java_java_lang_ref_Reference_register_weak_ref           </td>
          <td>(</td>
          <td class="paramtype">JNIEnv *&nbsp;</td>
          <td class="paramname"> <em>the_env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">jobject&nbsp;</td>
          <td class="paramname"> <em>p_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">jobject&nbsp;</td>
          <td class="paramname"> <em>referent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reference - the reference object to register. 
<p>
referent - the referent of the reference object that is to be retrieved with the get method.<p>
The weak reference code written in Java and the support code provide by the VM must agree on what the layout of a <code>Java.lang.ref.Reference</code> object looks like and agree that any subclassing will only append fields to the agreed upon layout. This seems reasonable.<p>
In addition the support code will have exclusive knowledge and control of a single field (called <code>the_referent</code>) which holds the reference to the target object. The java code will assume that this field is a read only integer and should not be traced by the gc. The <code>Java.lang.ref.ReferenceQueue</code> layout needs to also be known by the supporting code so that it can move reference objects onto the queues at the appropriate times. The Java code uses normal mechanisms to load the Reference classes and to create a reference.<p>
The constructor code however needs to call the appropriate register function listed below based upon whether we have a soft, weak, or phantom reference. The VM support code will fill in the referent field. The routine <code>gc_get_referent</code> will return the value in this field.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The phantom reference method get will not use the <code>gc_get_referent</code> but instead just return <code>NULL</code> as required by the spec.<p>
XXX Why are they in gc_export.h? -salikh </dd></dl>

</div>
</div><p>
<a class="anchor" name="0e53a703c7a36ea4dedd2f6cfe6159ce"></a><!-- doxytag: member="gc.h::gc_time_since_last_gc" ref="0e53a703c7a36ea4dedd2f6cfe6159ce" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int gc_time_since_last_gc           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
API for the VM to get the time since the last <a class="el" href="struct_g_c.html">GC</a> happened. 
<p>
Returns an unsigned long value in milliseconds.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Is this call really needed in <a class="el" href="struct_g_c.html">GC</a> interface? -salikh 2005-05-12 </dd></dl>

</div>
</div><p>
<a class="anchor" name="b0860bb3e4ef0696ef42f686ed2f2ac9"></a><!-- doxytag: member="gc.h::gc_heap_base_address" ref="b0860bb3e4ef0696ef42f686ed2f2ac9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* gc_heap_base_address           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The base address of the heap. </dd></dl>

<p>
API for VM to determine the starting and ending adddresses of the heap. 
</div>
</div><p>
<a class="anchor" name="744cc230ff757e6f218ba2e622a7f2c3"></a><!-- doxytag: member="gc.h::gc_heap_ceiling_address" ref="744cc230ff757e6f218ba2e622a7f2c3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* gc_heap_ceiling_address           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The top address of the heap. </dd></dl>

<p>

</div>
</div><p>
<hr size="1">
<address style="text-align: center;">
  <small>
    <p>Genereated on Tue Mar 11 19:25:34 2008 by Doxygen.</p>
    <p>(c) Copyright 2005, 2008 The Apache Software Foundation or its licensors, as applicable. </p>
  </small>
</address>
</body>
</html>
