<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>VM Infrastructure: vm.h File Reference</title>
<link href="hydoxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Packages</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>vm.h File Reference</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cha_class_iterator.html">ChaClassIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This structure is meant to be opaque.  <a href="struct_cha_class_iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cha_method_iterator.html">ChaMethodIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This structure is meant to be opaque.  <a href="struct_cha_method_iterator.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#1c2db83ae24f45db4714bf69e96a91eb">O_A_H_VM_VMDIR</a>&nbsp;&nbsp;&nbsp;&quot;org.apache.harmony.vm.vmdir&quot;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">These are the functions that a VM built as a DLL must export.  <a href="#1c2db83ae24f45db4714bf69e96a91eb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#e7fa71235b87a1a3f51df10a460c0a22">get_vm_interface</a> (const char *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamic interface adaptor, should return specific API by its name.  <a href="#e7fa71235b87a1a3f51df10a460c0a22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#e05c3916d04ce05db693d2b2d4c0f034">get_system_object_class</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>A handle for the <code>Object</code> class. </dd></dl>
 <a href="#e05c3916d04ce05db693d2b2d4c0f034"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#fd630c046619ea391362af0ec6347e33">get_system_class_class</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>A handle for the <code><a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a></code> class. </dd></dl>
 <a href="#fd630c046619ea391362af0ec6347e33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#280420927898893865d7439375f8dd4c">get_system_string_class</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>A handle for the string class. </dd></dl>
 <a href="#280420927898893865d7439375f8dd4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#d3e20101c84322082deda1fd41e5e8e5">class_lookup_class_by_name_using_bootstrap_class_loader</a> (const char *<a class="el" href="jvmti__types_8h.html#f35794c5a3717fe860d6a053f96e29f9">name</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find already loaded class of a given name.  <a href="#d3e20101c84322082deda1fd41e5e8e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#8e0cff2c8329beae3f1274acc87f93b1">class_property_is_final</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The following three functions will be eventually renamed to.  <a href="#8e0cff2c8329beae3f1274acc87f93b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#124b46872e9acf0cc0d79920ed2935e1">class_property_is_abstract</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#9f0317165bae9b79e7cc1b32e7dfc872">class_property_is_interface2</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#0ed00ff8480e57ef25359117c3199608">class_hint_is_exceptiontype</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the class is likely to be used as an exception object. </dd></dl>
 <a href="#0ed00ff8480e57ef25359117c3199608"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#80c84bc95da855055fb5e08bc68d514a">class_is_valuetype</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the class is a value type. </dd></dl>
 <a href="#80c84bc95da855055fb5e08bc68d514a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#c2308d2769d9773e4543d020cf67cdbb">class_is_enum</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the class represents an enum. </dd></dl>
 <a href="#c2308d2769d9773e4543d020cf67cdbb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="types_8h.html#1365e2757cbbe0e35471ce583e41021f">VM_Data_Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#8555c03a1de74cf43aa026ec617085ac">class_get_enum_int_type</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function can only be called if (<code>class_is_enum(ch)</code> == <code>TRUE</code>) The returned value is the type of the underlying int type.  <a href="#8555c03a1de74cf43aa026ec617085ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#3a2c3a28ff2937cf8ff45120e2542784">class_is_primitive</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the class represents a primitive type (int, float, etc. </dd></dl>
 <a href="#3a2c3a28ff2937cf8ff45120e2542784"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#3783d694c54e304feec9e99da727396a">class_get_name</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The name of the class. </dd></dl>
 <a href="#3783d694c54e304feec9e99da727396a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#3ef326216973c41d9b153ee79d686599">class_get_package_name</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The name of the package containing the class. </dd></dl>
 <a href="#3ef326216973c41d9b153ee79d686599"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#8b727faa7737d410e2ea5d1a0e4b853e">class_get_super_class</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The super class of the current class.  <a href="#8b727faa7737d410e2ea5d1a0e4b853e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_v_table.html">VTable_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#373d247a210a4caab9aee29ada8deff3">class_get_vtable</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The vtable handle of the given class. </dd></dl>
 <a href="#373d247a210a4caab9aee29ada8deff3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="types_8h.html#d2df958921a4a27ea5068be5d7a3b7af">Allocation_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#3abe02cd830f62c6a996d2c2f5b7c4f9">class_get_allocation_handle</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The allocation handle to be used for the object allocation routines, given a class handle. </dd></dl>
 <a href="#3abe02cd830f62c6a996d2c2f5b7c4f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#7c6fb2cd1066858369d95fa6cd420f45">allocation_handle_get_class</a> (<a class="el" href="types_8h.html#d2df958921a4a27ea5068be5d7a3b7af">Allocation_Handle</a> ah)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The class handle corresponding to a given allocation handle. </dd></dl>
 <a href="#7c6fb2cd1066858369d95fa6cd420f45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="types_8h.html#1365e2757cbbe0e35471ce583e41021f">VM_Data_Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#b4809e481e5a45e8175c65d28757ce1e">class_get_primitive_type_of_class</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>An <code>VM_Data_Type</code> value for a given class. </dd></dl>
 <a href="#b4809e481e5a45e8175c65d28757ce1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#d81e599fc6b373440d07533b48aae8cf">class_get_class_of_primitive_type</a> (<a class="el" href="types_8h.html#1365e2757cbbe0e35471ce583e41021f">VM_Data_Type</a> typ)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>A class corresponding to a primitive type. </dd></dl>
 <a href="#d81e599fc6b373440d07533b48aae8cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#fbb7cb1df11b2be4d072bd0ab562e970">class_is_array</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> is the class is an array. </dd></dl>
 <a href="#fbb7cb1df11b2be4d072bd0ab562e970"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#aae93158267b0f7cd8299a98394331b5">class_is_instanceof</a> (<a class="el" href="struct_class.html">Class_Handle</a> s, <a class="el" href="struct_class.html">Class_Handle</a> t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if class <code>s</code> is assignment compatible with class <code>t</code>. </dd></dl>
 <a href="#aae93158267b0f7cd8299a98394331b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#e32f167635f4c0d32cc88195d6c01948">class_get_array_of_class</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a class handle <code>cl</code> construct a class handle of the type representing array of <code>cl</code>.  <a href="#e32f167635f4c0d32cc88195d6c01948"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#84329031561d759c3f4f82eb9ae9a60b">class_get_array_of_unboxed</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a class handle <code>cl</code> construct a class handle of the type representing array of <code>cl</code>.  <a href="#84329031561d759c3f4f82eb9ae9a60b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#1e92e3d608ea3e418dc4d50923fe1447">class_get_element_type_info</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>For a class that is an array return the type info for the elements of the array. </dd></dl>
 <a href="#1e92e3d608ea3e418dc4d50923fe1447"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#bc624119d6c61a64450029e3562fc7dd">class_is_initialized</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the class is already fully initialized. </dd></dl>
 <a href="#bc624119d6c61a64450029e3562fc7dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#ddcf6766135027ef2b2643b51e91f74c">class_needs_initialization</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the class is neither initialized nor in the process of being initialized. </dd></dl>
 <a href="#ddcf6766135027ef2b2643b51e91f74c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#970edf5079be7eea64e9175996f86017">class_is_before_field_init</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For Java returns <code>FALSE</code>.  <a href="#970edf5079be7eea64e9175996f86017"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#4ed45026d94038cebf00aacd000b3ece">class_num_instance_fields</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of instance fields defined in a class.  <a href="#4ed45026d94038cebf00aacd000b3ece"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#729237f6ae55ae0458a706d31d854cb1">class_get_instance_field</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the handle for a field.  <a href="#729237f6ae55ae0458a706d31d854cb1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a62c9bd82474ecce2405c4cbcfb60856">class_num_instance_fields_recursive</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of instance fields defined in a class.  <a href="#a62c9bd82474ecce2405c4cbcfb60856"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#9dfae36805b93f66b71785080275792d">class_get_instance_field_recursive</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the handle for a field.  <a href="#9dfae36805b93f66b71785080275792d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#9e32d49ce741b0bcb9e001e1c3c91ed4">class_get_number_methods</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of methods declared in the class.  <a href="#9e32d49ce741b0bcb9e001e1c3c91ed4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#796387e217b25781f944e151f4a63e5b">class_get_fast_instanceof_flag</a> (<a class="el" href="struct_class.html">Class_Handle</a> cl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if fast_instanceof is applicable for the class.  <a href="#796387e217b25781f944e151f4a63e5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#bb98234e80439fb00a4b840246308f97">class_get_method</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch, unsigned index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get handle for a method declared in class.  <a href="#bb98234e80439fb00a4b840246308f97"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#ce8cb51e9935888ede4f9b1d32bf8d23">class_is_pinned</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if all instances of this class are pinned. </dd></dl>
 <a href="#ce8cb51e9935888ede4f9b1d32bf8d23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#7d3bda1c94ce828d7542687167b27480">class_alloc_via_classloader</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch, int32 <a class="el" href="jvmti__types_8h.html#3d3621eb57d320cce49279c6c1d59656">size</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if all instances of this class are pinned. </dd></dl>
 <a href="#7d3bda1c94ce828d7542687167b27480"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#3a84438c604e485e08a131980698bdc8">class_is_non_ref_array</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if this is an array of primitives. </dd></dl>
 <a href="#3a84438c604e485e08a131980698bdc8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#cd27b4787353aada8f4c6d5481568810">class_is_finalizable</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the class has a non-trivial finalizer. </dd></dl>
 <a href="#cd27b4787353aada8f4c6d5481568810"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#ea014eb6f44773fcdbf6c8e708f1321a">class_get_alignment</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This exactly what I want.  <a href="#ea014eb6f44773fcdbf6c8e708f1321a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#eb382eb32a161bbbaf6920157c04534f">class_get_alignment_unboxed</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the alignment of the class when it's unboxed.  <a href="#eb382eb32a161bbbaf6920157c04534f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#cf23540daa2f6e63a154d79070f04d62">class_element_size</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>For a class handle that represents and array, return the size of the element of the array. </dd></dl>
 <a href="#cf23540daa2f6e63a154d79070f04d62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#c6fa8d8d18413dc76ee4906c17ec0e71">class_get_boxed_data_size</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The size in bytes of an instance in the heap. </dd></dl>
 <a href="#c6fa8d8d18413dc76ee4906c17ec0e71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#bfcca8baff598916f64b65d4c746354e">class_get_unboxed_data_offset</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The offset to the start of user data form the start of a boxed instance. </dd></dl>
 <a href="#bfcca8baff598916f64b65d4c746354e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#3cdd439496755a48b32a475e97360623">class_get_array_element_size</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The size of array element for the given array class </dd></dl>
 <a href="#3cdd439496755a48b32a475e97360623"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#43cc0dee1f629c7a65733c19b273d254">class_get_array_element_class</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The class of the array element of the given class. </dd></dl>
 <a href="#43cc0dee1f629c7a65733c19b273d254"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#678ccd04225d61a3f4f69e9dbc329549">vtable_get_super_array_offset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The offset from the start of the vtable at which the superclass hierarchy is stored. </dd></dl>
 <a href="#678ccd04225d61a3f4f69e9dbc329549"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#553cd6fad5f8b72d45ff53e3f019e2b8">vtable_get_class</a> (<a class="el" href="struct_v_table.html">VTable_Handle</a> vh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> handle given object's <code>VTable_Handle</code>. </dd></dl>
 <a href="#553cd6fad5f8b72d45ff53e3f019e2b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#f8f10b5d4772d1ea8ef6d50a6bf018f4">vm_max_fast_instanceof_depth</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of superclass hierarchy elements that are stored within the vtable. </dd></dl>
 <a href="#f8f10b5d4772d1ea8ef6d50a6bf018f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#cb3b1a91f211f87e9d7ad8178871003d">class_iterator_initialize</a> (<a class="el" href="struct_cha_class_iterator.html">ChaClassIterator</a> *, <a class="el" href="struct_class.html">Class_Handle</a> root_class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the <code>CHA_Class_Iterator</code>, to iterate over all classes that descend from <code>root_class</code>, including <code>root_class</code> itself.  <a href="#cb3b1a91f211f87e9d7ad8178871003d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#112e03218dfaa0fbd34082cc37b5785d">class_iterator_get_current</a> (<a class="el" href="struct_cha_class_iterator.html">ChaClassIterator</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The current class of the iterator. </dd></dl>
 <a href="#112e03218dfaa0fbd34082cc37b5785d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#961861d36977a5a62855e2dd57186c39">class_iterator_advance</a> (<a class="el" href="struct_cha_class_iterator.html">ChaClassIterator</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Advances the iterator.  <a href="#961861d36977a5a62855e2dd57186c39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#c287c38c58288de3dca1f67e5f0e5803">class_number_inner_classes</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> the number of inner classes. </dd></dl>
 <a href="#c287c38c58288de3dca1f67e5f0e5803"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#ea62375d263b01ef4ad15f94d57a5427">class_is_inner_class_public</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if an inner class is public. </dd></dl>
 <a href="#ea62375d263b01ef4ad15f94d57a5427"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#e4b782c7fe3345a77fb639deaabfc6ce">class_get_inner_class</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>an inner class </dd></dl>
 <a href="#e4b782c7fe3345a77fb639deaabfc6ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#7f9e1f9e288f07396e9c2ad012fa1c88">class_get_declaring_class</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>the class that declared this one, or <code>NULL</code> if top-level class </dd></dl>
 <a href="#7f9e1f9e288f07396e9c2ad012fa1c88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#576e6da1df5347a9300151905ddf3e0c">field_is_static</a> (<a class="el" href="struct_field.html">Field_Handle</a> fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> is the field is static. </dd></dl>
 <a href="#576e6da1df5347a9300151905ddf3e0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#d2badf8680e17dc0bf58b5fecb346de4">field_get_type_info_of_field_value</a> (<a class="el" href="struct_field.html">Field_Handle</a> fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The type info that represents the type of the field. </dd></dl>
 <a href="#d2badf8680e17dc0bf58b5fecb346de4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#7977d2a91ac12ddf6a853c0cf5ddfe3f">field_get_class_of_field_value</a> (<a class="el" href="struct_field.html">Field_Handle</a> fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The class that represents the type of the field. </dd></dl>
 <a href="#7977d2a91ac12ddf6a853c0cf5ddfe3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#2ad45c5a2b82e88249efbb171150813e">field_get_class</a> (<a class="el" href="struct_field.html">Field_Handle</a> fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The class that defined that field. </dd></dl>
 <a href="#2ad45c5a2b82e88249efbb171150813e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a72c23f992a64190058d995f8dbdc9c2">field_is_reference</a> (<a class="el" href="struct_field.html">Field_Handle</a> fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the field is of reference type </dd></dl>
 <a href="#a72c23f992a64190058d995f8dbdc9c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#35ae29e3265d1a068e3dadd4c04215c3">field_is_magic</a> (<a class="el" href="struct_field.html">Field_Handle</a> fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the field is a magic type field </dd></dl>
 <a href="#35ae29e3265d1a068e3dadd4c04215c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#3e4647afb03056d428c488a1353632e2">field_is_enumerable_reference</a> (<a class="el" href="struct_field.html">Field_Handle</a> fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the field must be enumerated by GC </dd></dl>
 <a href="#3e4647afb03056d428c488a1353632e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#9f8cb90776362ed9b7a1de7a67548ad1">field_is_literal</a> (<a class="el" href="struct_field.html">Field_Handle</a> fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the field is literal. </dd></dl>
 <a href="#9f8cb90776362ed9b7a1de7a67548ad1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#e0c50cd209ac917266521038044c57a6">field_is_unmanaged_static</a> (<a class="el" href="struct_field.html">Field_Handle</a> fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For Java always <code>FALSE</code>.  <a href="#e0c50cd209ac917266521038044c57a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#fe660da92c80af31f787b642a54e48b9">field_get_offset</a> (<a class="el" href="struct_field.html">Field_Handle</a> fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The offset to an instance field. </dd></dl>
 <a href="#fe660da92c80af31f787b642a54e48b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#93283287ccec99ba10cac85f0bda030e">field_get_address</a> (<a class="el" href="struct_field.html">Field_Handle</a> fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>An address of a static field. </dd></dl>
 <a href="#93283287ccec99ba10cac85f0bda030e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#9b300b07cbd1c9ad2e15d71fa8d024ef">field_get_name</a> (<a class="el" href="struct_field.html">Field_Handle</a> fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>A name of the field. </dd></dl>
 <a href="#9b300b07cbd1c9ad2e15d71fa8d024ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#4714a9a3e293af321a7055e3fb8ffa07">field_get_descriptor</a> (<a class="el" href="struct_field.html">Field_Handle</a> fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The field descriptor. </dd></dl>
 <a href="#4714a9a3e293af321a7055e3fb8ffa07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#12b6d0283bc2cf1e5c2c618f9b45d08b">field_is_final</a> (<a class="el" href="struct_field.html">Field_Handle</a> fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the field is final. </dd></dl>
 <a href="#12b6d0283bc2cf1e5c2c618f9b45d08b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#d0a5db491555a34124fe1c112f2fc51e">field_is_volatile</a> (<a class="el" href="struct_field.html">Field_Handle</a> fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the field is volatile. </dd></dl>
 <a href="#d0a5db491555a34124fe1c112f2fc51e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#7c8014018bf5b2358b6969d127466cc1">field_is_private</a> (<a class="el" href="struct_field.html">Field_Handle</a> fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the field is private. </dd></dl>
 <a href="#7c8014018bf5b2358b6969d127466cc1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#25a88ec668840528d1e619ddb5d7ac12">field_get_track_access_flag</a> (<a class="el" href="struct_field.html">Field_Handle</a> <a class="el" href="jvmti__types_8h.html#7844707fe085633366345dc47af60e09">field</a>, char **<a class="el" href="jvmti__types_8h.html#fab31af2c2005ed57cefa0380aa83d80">address</a>, char *mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The address and bit mask, for the flag which determine whether field access event should be sent. </dd></dl>
 <a href="#25a88ec668840528d1e619ddb5d7ac12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#0495c3b312b0877b00ea2d1e624fd6f7">field_get_track_modification_flag</a> (<a class="el" href="struct_field.html">Field_Handle</a> <a class="el" href="jvmti__types_8h.html#7844707fe085633366345dc47af60e09">field</a>, char **<a class="el" href="jvmti__types_8h.html#fab31af2c2005ed57cefa0380aa83d80">address</a>, char *mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>the address and bit mask, for the flag which determine whether field modification event should be sent. </dd></dl>
 <a href="#0495c3b312b0877b00ea2d1e624fd6f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#823c4ecab43ef660dfe0bc84d35d50de">method_is_java</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if this a Java method. </dd></dl>
 <a href="#823c4ecab43ef660dfe0bc84d35d50de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#8a99f803534850c32f4f6bf68b32f3fd">method_get_name</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The method name. </dd></dl>
 <a href="#8a99f803534850c32f4f6bf68b32f3fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#0ece2189effb8925008de07124cd54a7">method_get_descriptor</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The method descriptor. </dd></dl>
 <a href="#0ece2189effb8925008de07124cd54a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#0bfa9cd49898f612f8fc9855c6dec4fe">method_get_class</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>A class in which the method is declared. </dd></dl>
 <a href="#0bfa9cd49898f612f8fc9855c6dec4fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#d9ac81ed623ff2697b7e88061de9c5d8">method_lock</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#d9e0c4abe0a6c11f492f9dfa28f39f1c">method_unlock</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#5ffd0c652569732159db8934b8947df4">method_is_private</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the method is private. </dd></dl>
 <a href="#5ffd0c652569732159db8934b8947df4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#3c6ef4eadb5f059f10ff758af2785e12">method_is_static</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the method is static. </dd></dl>
 <a href="#3c6ef4eadb5f059f10ff758af2785e12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#e3d4360d25af7138a22a86b30addfda7">method_is_final</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the method is final. </dd></dl>
 <a href="#e3d4360d25af7138a22a86b30addfda7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#f5b7980cb6613c4e74c7b431d2b295fd">method_is_native</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the method is native. </dd></dl>
 <a href="#f5b7980cb6613c4e74c7b431d2b295fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#5d65dba9fd12b159fe92b6d4fa6ddfbb">method_is_synchronized</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the method is synchronized. </dd></dl>
 <a href="#5d65dba9fd12b159fe92b6d4fa6ddfbb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#27d465190cfdad167635f37bec15fac2">method_is_abstract</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the method is abstract. </dd></dl>
 <a href="#27d465190cfdad167635f37bec15fac2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#1732c7bf9268a1990110f0d6f225499d">method_is_strict</a> (<a class="el" href="struct_method.html">Method_Handle</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Java methods may have a flag set to indicate that floating point operations must be performed in the strict mode.  <a href="#1732c7bf9268a1990110f0d6f225499d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#55e7d296039fec6c3005fb000494a66f">method_is_overridden</a> (<a class="el" href="struct_method.html">Method_Handle</a> m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the method has been overriden in a subclass and <code>FALSE</code> otherwise. </dd></dl>
 <a href="#55e7d296039fec6c3005fb000494a66f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#9417466408fa3e2ecbcae6778d032797">method_is_no_inlining</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the method should not be inlined. </dd></dl>
 <a href="#9417466408fa3e2ecbcae6778d032797"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#697f074fe633fb3163719236c483818e">method_is_require_security_object</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Always <code>FALSE</code> for Java.  <a href="#697f074fe633fb3163719236c483818e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_method___signature.html">Method_Signature_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#70677b8f7cf07c05647770e02162f231">method_get_signature</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>A signature that can be used to iterate over method's arguments and query the type of the method result. </dd></dl>
 <a href="#70677b8f7cf07c05647770e02162f231"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#5ef853ad49620a1aefef75b9132311e7">method_find_overridden_method</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch, <a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> <code>ch</code> is a subclass of <code>method_get_class(mh)</code>.  <a href="#5ef853ad49620a1aefef75b9132311e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a8f23d162c6e5a36507f8e4bcefcb306">method_iterator_initialize</a> (<a class="el" href="struct_cha_method_iterator.html">ChaMethodIterator</a> *, <a class="el" href="struct_method.html">Method_Handle</a> <a class="el" href="jvmti__types_8h.html#03510b7e66271c729c629f2342b44c82">method</a>, <a class="el" href="struct_class.html">Class_Handle</a> root_class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the <code>CHA_Method_Iterator</code>, to iterate over all methods that match the method signature and descend from <code>root_class</code> (including <code>root_class</code> itself).  <a href="#a8f23d162c6e5a36507f8e4bcefcb306"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#3b2bd696014011b520793b6a0a38bd4c">method_iterator_get_current</a> (const <a class="el" href="struct_cha_method_iterator.html">ChaMethodIterator</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The current method of the iterator. </dd></dl>
 <a href="#3b2bd696014011b520793b6a0a38bd4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#302cf46b4982113aad369e0af8655c7a">method_iterator_advance</a> (<a class="el" href="struct_cha_method_iterator.html">ChaMethodIterator</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Advances the iterator.  <a href="#302cf46b4982113aad369e0af8655c7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#8d8b8aee1e1d67a10efcfafb08d1143a">method_sig_get_descriptor</a> (<a class="el" href="struct_method___signature.html">Method_Signature_Handle</a> s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The method descriptor for a given method signature. </dd></dl>
 <a href="#8d8b8aee1e1d67a10efcfafb08d1143a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_method___signature.html">Method_Signature_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#f6d6e154b310db9bcbeada2b0a7937b2">method_standalone_signature</a> (<a class="el" href="struct_class.html">Class_Handle</a> ch, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a signature that can be used to iterate over method's arguments and query the type of the method result.  <a href="#f6d6e154b310db9bcbeada2b0a7937b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#397a04552e5b0bdecdab04c921072579">method_vars_get_number</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of local variables defined for the method. </dd></dl>
 <a href="#397a04552e5b0bdecdab04c921072579"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#7bddff605c784c0ab32318952f65abe2">method_vars_get_type_info</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the type info of the local variable number idx.  <a href="#7bddff605c784c0ab32318952f65abe2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#6e78cff6f6932e91156a145d2b0e1ac2">method_vars_is_managed_pointer</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the local variable is a managed pointer. </dd></dl>
 <a href="#6e78cff6f6932e91156a145d2b0e1ac2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#4a5de76c491f78e239568d0acb773129">method_vars_is_pinned</a> (<a class="el" href="struct_method.html">Method_Handle</a> mh, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the local variable is pinned. </dd></dl>
 <a href="#4a5de76c491f78e239568d0acb773129"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#8212e3077b85cbe7102f1e9d107c672b">method_args_get_number</a> (<a class="el" href="struct_method___signature.html">Method_Signature_Handle</a> msh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of arguments defined for the method. </dd></dl>
 <a href="#8212e3077b85cbe7102f1e9d107c672b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#e56fd880462cb94aff60f24b9d5aa1c1">method_args_has_this</a> (<a class="el" href="struct_method___signature.html">Method_Signature_Handle</a> msh)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#95f92ad6ddff6814e0385d19a1add1fc">method_args_get_type_info</a> (<a class="el" href="struct_method___signature.html">Method_Signature_Handle</a> msh, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the class handle of the argument number idx.  <a href="#95f92ad6ddff6814e0385d19a1add1fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#b09adf75b34753db8f8ada7cb5623b51">method_args_is_managed_pointer</a> (<a class="el" href="struct_method___signature.html">Method_Signature_Handle</a> msh, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the argument is a managed pointer. </dd></dl>
 <a href="#b09adf75b34753db8f8ada7cb5623b51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#45313f07e76f2475cef647d44d30c48e">method_ret_type_get_type_info</a> (<a class="el" href="struct_method___signature.html">Method_Signature_Handle</a> msh)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#951eddf037ecbd47b5961a7a665eec80">method_ret_type_is_managed_pointer</a> (<a class="el" href="struct_method___signature.html">Method_Signature_Handle</a> msh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the return value is a managed pointer. </dd></dl>
 <a href="#951eddf037ecbd47b5961a7a665eec80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#be837c89781dcda6b9505e34fbfc3dd7">type_info_is_reference</a> (<a class="el" href="struct_type_desc.html">Type_Info_Handle</a> tih)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array shapes and custom modifiers are not implemented yet.  <a href="#be837c89781dcda6b9505e34fbfc3dd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#2ae5f1f09698a8152dc6cb263dc15ec2">type_info_is_unboxed</a> (<a class="el" href="struct_type_desc.html">Type_Info_Handle</a> tih)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If type info is unboxed, <code>type_info_get_class</code> will return the class of the unboxed type and <code>class_is_primitive<code> will return its <code>VM_Data_Type</code>. </code></code> <a href="#2ae5f1f09698a8152dc6cb263dc15ec2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#7f6256dc26a058d6f83f12b352788727">type_info_is_primitive</a> (<a class="el" href="struct_type_desc.html">Type_Info_Handle</a> tih)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the type is a primitive type. </dd></dl>
 <a href="#7f6256dc26a058d6f83f12b352788727"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#0b186d2c1c44f306b83f2b90a394fbbf">type_info_is_unmanaged_pointer</a> (<a class="el" href="struct_type_desc.html">Type_Info_Handle</a> tih)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <code>TRUE</code>, then <code>type_info_get_type_info</code> returns the type info that the pointer points to.  <a href="#0b186d2c1c44f306b83f2b90a394fbbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#bf4973d05a86fb5fd4606f9b185554a9">type_info_is_void</a> (<a class="el" href="struct_type_desc.html">Type_Info_Handle</a> tih)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For a return value a type can be void when it is not an unmanaged pointer.  <a href="#bf4973d05a86fb5fd4606f9b185554a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#f8584ed9c7880a5b510e7309d2f5957d">type_info_is_method_pointer</a> (<a class="el" href="struct_type_desc.html">Type_Info_Handle</a> tih)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <code>TRUE</code>, use <code>type_info_get_method_sig</code> to retrieve the method signature.  <a href="#f8584ed9c7880a5b510e7309d2f5957d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#928106b6baa0854fefaaaa2b269a6a3b">type_info_is_vector</a> (<a class="el" href="struct_type_desc.html">Type_Info_Handle</a> tih)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is it a vector, i.e., a one-dimensional, zero-based array.  <a href="#928106b6baa0854fefaaaa2b269a6a3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#daa547c858cf22735a82fb58c22899ae">type_info_is_general_array</a> (<a class="el" href="struct_type_desc.html">Type_Info_Handle</a> tih)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is it a general array, i.e., either multidimensional or non zero-based.  <a href="#daa547c858cf22735a82fb58c22899ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#97ca25e6014916159060e6d0ecf38a32">type_info_get_type_name</a> (<a class="el" href="struct_type_desc.html">Type_Info_Handle</a> tih)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of the class referenced by this type info handle.  <a href="#97ca25e6014916159060e6d0ecf38a32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#cfc7bd9eeb01be4002c906033edda57e">type_info_get_class</a> (<a class="el" href="struct_type_desc.html">Type_Info_Handle</a> tih)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the class if <code>type_info_is_reference</code> or <code>type_info_is_unboxed</code> returned <code>TRUE</code>.  <a href="#cfc7bd9eeb01be4002c906033edda57e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#2f58fb826594e617944884c717290d9f">type_info_create_from_java_descriptor</a> (<a class="el" href="struct_class_loader.html">ClassLoaderHandle</a> cl, const char *typeName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets Type_Info_Handle from the given type name.  <a href="#2f58fb826594e617944884c717290d9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#d07890138ae802f3c279b99fec48abfd">type_info_get_class_no_exn</a> (<a class="el" href="struct_type_desc.html">Type_Info_Handle</a> tih)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the class if <code>type_info_is_reference</code> or <code>type_info_is_unboxed</code> returned <code>TRUE</code>.  <a href="#d07890138ae802f3c279b99fec48abfd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_method___signature.html">Method_Signature_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#1c6072565daa536e203a8916a1c7ea26">type_info_get_method_sig</a> (<a class="el" href="struct_type_desc.html">Type_Info_Handle</a> tih)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the method signature if <code>type_info_is_method_pointer</code> returned <code>TRUE</code>.  <a href="#1c6072565daa536e203a8916a1c7ea26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a44986f81fb6e6e95c990d94763efc5e">type_info_get_type_info</a> (<a class="el" href="struct_type_desc.html">Type_Info_Handle</a> tih)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get recursively type info if <code>type_info_is_unmanaged_pointer</code>, <code>type_info_is_vector</code> or <code>type_info_is_general_array</code> returned <code>TRUE</code>.  <a href="#a44986f81fb6e6e95c990d94763efc5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="types_8h.html#1365e2757cbbe0e35471ce583e41021f">VM_Data_Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#f42622b70b3523bc915976172236b1de">type_info_get_type</a> (<a class="el" href="struct_type_desc.html">Type_Info_Handle</a> tih)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an <code>VM_Data_Type</code> corresponding to a type info.  <a href="#f42622b70b3523bc915976172236b1de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#f33cfb92fd74e7badf16976aea827593">type_info_is_resolved</a> (<a class="el" href="struct_type_desc.html">Type_Info_Handle</a> tih)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if a type referenced by the given type info handle is resolved.  <a href="#f33cfb92fd74e7badf16976aea827593"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#e4764a236fbe9b87afe36e50c4fb143c">type_info_get_num_array_dimensions</a> (<a class="el" href="struct_type_desc.html">Type_Info_Handle</a> tih)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns number of array dimension of a type referenced by the given type info handle.  <a href="#e4764a236fbe9b87afe36e50c4fb143c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#50007470d78f066505ebc80acadcf522">vector_length_offset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the offset to the length field of the array.  <a href="#50007470d78f066505ebc80acadcf522"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#1a48d5eb6ee48480c866f9fae1602da9">array_length_offset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deprecated.  <a href="#1a48d5eb6ee48480c866f9fae1602da9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#3496b252b56be4d193042da4e8618260">vector_first_element_offset</a> (<a class="el" href="types_8h.html#1365e2757cbbe0e35471ce583e41021f">VM_Data_Type</a> element_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the offset to the first element of the vector of the given type.  <a href="#3496b252b56be4d193042da4e8618260"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#2e16a0518554d0ac45c4b65650837f93">array_first_element_offset</a> (<a class="el" href="types_8h.html#1365e2757cbbe0e35471ce583e41021f">VM_Data_Type</a> element_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deprecated.  <a href="#2e16a0518554d0ac45c4b65650837f93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#fbad0481166bab7fad3b2247e7b2a14f">vector_first_element_offset_class_handle</a> (<a class="el" href="struct_class.html">Class_Handle</a> element_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the offset to the first element of the vector of the given type.  <a href="#fbad0481166bab7fad3b2247e7b2a14f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#2bfb6f6d450aabf6e5a6871db6e65c11">array_first_element_offset_class_handle</a> (<a class="el" href="struct_class.html">Class_Handle</a> element_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deprecated.  <a href="#2bfb6f6d450aabf6e5a6871db6e65c11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#573303b273de81b0fcd8764bef57ed8f">vector_first_element_offset_unboxed</a> (<a class="el" href="struct_class.html">Class_Handle</a> element_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the offset to the first element of the vector of the given type.  <a href="#573303b273de81b0fcd8764bef57ed8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#94333b53cb72440c0c517374af71448d">array_first_element_offset_unboxed</a> (<a class="el" href="struct_class.html">Class_Handle</a> element_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deprecated.  <a href="#94333b53cb72440c0c517374af71448d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a4e364fc018eb5221e511ab0fbed7826">vector_get_length</a> (<a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a> vector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the length of a vector.  <a href="#a4e364fc018eb5221e511ab0fbed7826"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="types_8h.html#ce9f204c38a2c82a917b9badec5a137e">Managed_Object_Handle</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#b94d88d41b5768c964d42813b8e98cb8">vector_get_element_address_ref</a> (<a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a> vector, int32 idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the address to an element of a vector of references.  <a href="#b94d88d41b5768c964d42813b8e98cb8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#067f2a252d0911b8404889f04c68cc34">vm_vector_size</a> (<a class="el" href="struct_class.html">Class_Handle</a> vector_class, int <a class="el" href="jvmti__types_8h.html#1ee8a4cdc2176352791e9feef77e1fd5">length</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the size of a vector of a given number of elements.  <a href="#067f2a252d0911b8404889f04c68cc34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#6ffe6796e756b7eec71175b775da7fa5">vm_references_are_compressed</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if references within objects and vector elements are to be treated as offsets rather than raw pointers. </dd></dl>
 <a href="#6ffe6796e756b7eec71175b775da7fa5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#60584ceb669817eca2b52517ce73c658">vm_heap_base_address</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The starting address of the GC heap. </dd></dl>
 <a href="#60584ceb669817eca2b52517ce73c658"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#fb97e32291132e6a69b4460e9cd1f5c4">vm_heap_ceiling_address</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The ending address of the GC heap. </dd></dl>
 <a href="#fb97e32291132e6a69b4460e9cd1f5c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#3239835bf1c23818d709cad5e85041f7">vm_vtable_pointers_are_compressed</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if vtable pointers within objects are to be treated as offsets rather than raw pointers. </dd></dl>
 <a href="#3239835bf1c23818d709cad5e85041f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#cca507647c9ada4e13ab829299e603f1">object_get_vtable_offset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The offset to the vtable pointer in an object. </dd></dl>
 <a href="#cca507647c9ada4e13ab829299e603f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT POINTER_SIZE_INT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#18502aec83bcdd6a0f7b198b45cb5108">vm_get_vtable_base</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The base address of the vtable memory area. </dd></dl>
 <a href="#18502aec83bcdd6a0f7b198b45cb5108"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#9fa3367a6cc544b8b4e73a391e95e77e">vm_get_vtable_ptr_size</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The width in bytes (e.g. </dd></dl>
 <a href="#9fa3367a6cc544b8b4e73a391e95e77e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#1a23d1956d2aa4f99721b7042222197f">method_sig_get_string</a> (<a class="el" href="struct_method___signature.html">Method_Signature_Handle</a> msh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>A printable signature. </dd></dl>
 <a href="#1a23d1956d2aa4f99721b7042222197f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#5a060c364368ea0d6b27c563c90b82bc">free_string_buffer</a> (char *buffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a string buffer returned by <code>method_sig_get_string</code>.  <a href="#5a060c364368ea0d6b27c563c90b82bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#381b2a8ede4108b3744d13e7372d0b70">set_property</a> (const char *key, const char *value, <a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a> table_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the property for <code>table_number</code> property table.  <a href="#381b2a8ede4108b3744d13e7372d0b70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#1b334224f93d894a6dcae53eab037508">get_property</a> (const char *key, <a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a> table_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property from <code>table_number</code> property table if it has been set by <code>set_property</code> function. </dd></dl>
 <a href="#1b334224f93d894a6dcae53eab037508"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#8c0b9897ff821b8bb41bcbab77c95247">destroy_property_value</a> (char *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safety frees memory of value returned by <code>get_property</code> function.  <a href="#8c0b9897ff821b8bb41bcbab77c95247"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#1c7390b5b8ec406aa085011881dbde54">is_property_set</a> (const char *key, <a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a> table_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if the property is set.  <a href="#1c7390b5b8ec406aa085011881dbde54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#41a27c04098250d67d3588c03bc9163c">unset_property</a> (const char *key, <a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a> table_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsets the property in <code>table_number</code> property table.  <a href="#41a27c04098250d67d3588c03bc9163c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#f712aec398f558fc886919ff824369f6">get_properties_keys</a> (<a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a> table_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>An array of keys from <code>table_number</code> properties table. </dd></dl>
 <a href="#f712aec398f558fc886919ff824369f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#39f9d82ba693d5b85a87881dcdefbd5d">get_properties_keys_staring_with</a> (const char *prefix, <a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a> table_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>An array of keys which start with specified prefix from <code>table_number</code> properties table. </dd></dl>
 <a href="#39f9d82ba693d5b85a87881dcdefbd5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#22d4821645395fe6e6c1f823f9cad5b4">destroy_properties_keys</a> (char **keys)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safety frees array of keys memory which returned by <code>get_properties_keys</code> or <code>get_properties_keys_staring_with</code> functions.  <a href="#22d4821645395fe6e6c1f823f9cad5b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT Boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#63f5858e59b94f63e5063a0988785ff9">get_boolean_property</a> (const char *property, Boolean default_value, <a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a> table_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to interpret property value as <code>Boolean</code> and returns it.  <a href="#63f5858e59b94f63e5063a0988785ff9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#eeb6adbcfe255289bd87f1a1bd991b6d">get_int_property</a> (const char *property_name, int default_value, <a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a> table_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to interpret property value as <code>int</code> and returns it.  <a href="#eeb6adbcfe255289bd87f1a1bd991b6d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#4604bb8b59ba1f07a522ca8a10ce9d7b">get_size_property</a> (const char *property_name, size_t default_value, <a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a> table_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to interpret property value as <code>int</code> and returns it.  <a href="#4604bb8b59ba1f07a522ca8a10ce9d7b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#3284a642b996558802c4a600c6c36844">get_numerical_property</a> (const char *property_name, int64 default_value, <a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a> table_number)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#50ea33d32d70e9049c1217ab5b7d0e13">get_method_entry_flag_address</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the address of the global flag that specifies whether MethodEntry event is enabled.  <a href="#50ea33d32d70e9049c1217ab5b7d0e13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#2f317cb9e7d8f46a37cca2ca68fc2b82">get_method_exit_flag_address</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the address of the global flag that specifies whether MethodExit event is enabled.  <a href="#2f317cb9e7d8f46a37cca2ca68fc2b82"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="1c2db83ae24f45db4714bf69e96a91eb"></a><!-- doxytag: member="vm.h::O_A_H_VM_VMDIR" ref="1c2db83ae24f45db4714bf69e96a91eb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define O_A_H_VM_VMDIR&nbsp;&nbsp;&nbsp;&quot;org.apache.harmony.vm.vmdir&quot;          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
These are the functions that a VM built as a DLL must export. 
<p>
Some functions may be optional and are marked as such. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="e7fa71235b87a1a3f51df10a460c0a22"></a><!-- doxytag: member="vm.h::get_vm_interface" ref="e7fa71235b87a1a3f51df10a460c0a22" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void* get_vm_interface           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dynamic interface adaptor, should return specific API by its name. 
<p>

</div>
</div><p>
<a class="anchor" name="e05c3916d04ce05db693d2b2d4c0f034"></a><!-- doxytag: member="vm.h::get_system_object_class" ref="e05c3916d04ce05db693d2b2d4c0f034" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> get_system_object_class           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A handle for the <code>Object</code> class. </dd></dl>

<p>
For Java applications, it's <code>java.lang.Object</code>. 
</div>
</div><p>
<a class="anchor" name="fd630c046619ea391362af0ec6347e33"></a><!-- doxytag: member="vm.h::get_system_class_class" ref="fd630c046619ea391362af0ec6347e33" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> get_system_class_class           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A handle for the <code><a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a></code> class. </dd></dl>

<p>
For Java applications, it's <code><a class="el" href="jvmti__internal_8h.html#9c158af314b0aa46ba0d0e19cef592d8">java.lang.Class</a></code>. 
</div>
</div><p>
<a class="anchor" name="280420927898893865d7439375f8dd4c"></a><!-- doxytag: member="vm.h::get_system_string_class" ref="280420927898893865d7439375f8dd4c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> get_system_string_class           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A handle for the string class. </dd></dl>

<p>
For Java applications, it's <a class="el" href="vm__util_8h.html#54ad19f2d17915dbf4eb4c2fa2fa8680">java.lang.String</a>. 
</div>
</div><p>
<a class="anchor" name="d3e20101c84322082deda1fd41e5e8e5"></a><!-- doxytag: member="vm.h::class_lookup_class_by_name_using_bootstrap_class_loader" ref="d3e20101c84322082deda1fd41e5e8e5" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> class_lookup_class_by_name_using_bootstrap_class_loader           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find already loaded class of a given name. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>NULL</code> if a class is not loaded. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8e0cff2c8329beae3f1274acc87f93b1"></a><!-- doxytag: member="vm.h::class_property_is_final" ref="8e0cff2c8329beae3f1274acc87f93b1" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_property_is_final           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The following three functions will be eventually renamed to. 
<p>
<ul>
<li><code>class_is_final</code> </li>
<li><code>class_is_abstract</code> </li>
<li><code>class_is_interface</code> but right now that would conflict with the names of some internal macros. </li>
</ul>

</div>
</div><p>
<a class="anchor" name="124b46872e9acf0cc0d79920ed2935e1"></a><!-- doxytag: member="vm.h::class_property_is_abstract" ref="124b46872e9acf0cc0d79920ed2935e1" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_property_is_abstract           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9f0317165bae9b79e7cc1b32e7dfc872"></a><!-- doxytag: member="vm.h::class_property_is_interface2" ref="9f0317165bae9b79e7cc1b32e7dfc872" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_property_is_interface2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0ed00ff8480e57ef25359117c3199608"></a><!-- doxytag: member="vm.h::class_hint_is_exceptiontype" ref="0ed00ff8480e57ef25359117c3199608" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_hint_is_exceptiontype           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the class is likely to be used as an exception object. </dd></dl>

<p>
This is a hint only. If the result is <code>FALSE</code>, the class may still be used for exceptions but it is less likely. 
</div>
</div><p>
<a class="anchor" name="80c84bc95da855055fb5e08bc68d514a"></a><!-- doxytag: member="vm.h::class_is_valuetype" ref="80c84bc95da855055fb5e08bc68d514a" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_is_valuetype           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the class is a value type. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="c2308d2769d9773e4543d020cf67cdbb"></a><!-- doxytag: member="vm.h::class_is_enum" ref="c2308d2769d9773e4543d020cf67cdbb" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_is_enum           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the class represents an enum. </dd></dl>

<p>
For Java 1.4 always returns <code>FALSE</code>. 
</div>
</div><p>
<a class="anchor" name="8555c03a1de74cf43aa026ec617085ac"></a><!-- doxytag: member="vm.h::class_get_enum_int_type" ref="8555c03a1de74cf43aa026ec617085ac" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="types_8h.html#1365e2757cbbe0e35471ce583e41021f">VM_Data_Type</a> class_get_enum_int_type           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function can only be called if (<code>class_is_enum(ch)</code> == <code>TRUE</code>) The returned value is the type of the underlying int type. 
<p>

</div>
</div><p>
<a class="anchor" name="3a2c3a28ff2937cf8ff45120e2542784"></a><!-- doxytag: member="vm.h::class_is_primitive" ref="3a2c3a28ff2937cf8ff45120e2542784" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_is_primitive           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the class represents a primitive type (int, float, etc. </dd></dl>

<p>
) 
</div>
</div><p>
<a class="anchor" name="3783d694c54e304feec9e99da727396a"></a><!-- doxytag: member="vm.h::class_get_name" ref="3783d694c54e304feec9e99da727396a" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT const char* class_get_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The name of the class. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="3ef326216973c41d9b153ee79d686599"></a><!-- doxytag: member="vm.h::class_get_package_name" ref="3ef326216973c41d9b153ee79d686599" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT const char* class_get_package_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The name of the package containing the class. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="8b727faa7737d410e2ea5d1a0e4b853e"></a><!-- doxytag: member="vm.h::class_get_super_class" ref="8b727faa7737d410e2ea5d1a0e4b853e" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> class_get_super_class           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The super class of the current class. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>NULL</code> for the system object class, i.e. <code>class_get_super_class</code>(<a class="el" href="vm_8h.html#e05c3916d04ce05db693d2b2d4c0f034" title="A handle for the Object class.">get_system_object_class()</a>) == NULL </dd></dl>

</div>
</div><p>
<a class="anchor" name="373d247a210a4caab9aee29ada8deff3"></a><!-- doxytag: member="vm.h::class_get_vtable" ref="373d247a210a4caab9aee29ada8deff3" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_v_table.html">VTable_Handle</a> class_get_vtable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The vtable handle of the given class. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="3abe02cd830f62c6a996d2c2f5b7c4f9"></a><!-- doxytag: member="vm.h::class_get_allocation_handle" ref="3abe02cd830f62c6a996d2c2f5b7c4f9" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="types_8h.html#d2df958921a4a27ea5068be5d7a3b7af">Allocation_Handle</a> class_get_allocation_handle           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The allocation handle to be used for the object allocation routines, given a class handle. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="7c6fb2cd1066858369d95fa6cd420f45"></a><!-- doxytag: member="vm.h::allocation_handle_get_class" ref="7c6fb2cd1066858369d95fa6cd420f45" args="(Allocation_Handle ah)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> allocation_handle_get_class           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#d2df958921a4a27ea5068be5d7a3b7af">Allocation_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ah</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The class handle corresponding to a given allocation handle. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="b4809e481e5a45e8175c65d28757ce1e"></a><!-- doxytag: member="vm.h::class_get_primitive_type_of_class" ref="b4809e481e5a45e8175c65d28757ce1e" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="types_8h.html#1365e2757cbbe0e35471ce583e41021f">VM_Data_Type</a> class_get_primitive_type_of_class           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An <code>VM_Data_Type</code> value for a given class. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="d81e599fc6b373440d07533b48aae8cf"></a><!-- doxytag: member="vm.h::class_get_class_of_primitive_type" ref="d81e599fc6b373440d07533b48aae8cf" args="(VM_Data_Type typ)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> class_get_class_of_primitive_type           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#1365e2757cbbe0e35471ce583e41021f">VM_Data_Type</a>&nbsp;</td>
          <td class="paramname"> <em>typ</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A class corresponding to a primitive type. </dd></dl>

<p>
For all primitive types t t == <code>class_get_primitive_type_of_class(class_get_class_of_primitive_type(t))</code> 
</div>
</div><p>
<a class="anchor" name="fbb7cb1df11b2be4d072bd0ab562e970"></a><!-- doxytag: member="vm.h::class_is_array" ref="fbb7cb1df11b2be4d072bd0ab562e970" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_is_array           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> is the class is an array. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="aae93158267b0f7cd8299a98394331b5"></a><!-- doxytag: member="vm.h::class_is_instanceof" ref="aae93158267b0f7cd8299a98394331b5" args="(Class_Handle s, Class_Handle t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_is_instanceof           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if class <code>s</code> is assignment compatible with class <code>t</code>. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="e32f167635f4c0d32cc88195d6c01948"></a><!-- doxytag: member="vm.h::class_get_array_of_class" ref="e32f167635f4c0d32cc88195d6c01948" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> class_get_array_of_class           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a class handle <code>cl</code> construct a class handle of the type representing array of <code>cl</code>. 
<p>
If class cl is value type, assume that the element is a reference to a boxed instance of that type. 
</div>
</div><p>
<a class="anchor" name="84329031561d759c3f4f82eb9ae9a60b"></a><!-- doxytag: member="vm.h::class_get_array_of_unboxed" ref="84329031561d759c3f4f82eb9ae9a60b" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> class_get_array_of_unboxed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a class handle <code>cl</code> construct a class handle of the type representing array of <code>cl</code>. 
<p>
<a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> <code>cl</code> is assumed to be a value type.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>NULL</code> if cl is not a value type. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e92e3d608ea3e418dc4d50923fe1447"></a><!-- doxytag: member="vm.h::class_get_element_type_info" ref="1e92e3d608ea3e418dc4d50923fe1447" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_type_desc.html">Type_Info_Handle</a> class_get_element_type_info           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>For a class that is an array return the type info for the elements of the array. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="bc624119d6c61a64450029e3562fc7dd"></a><!-- doxytag: member="vm.h::class_is_initialized" ref="bc624119d6c61a64450029e3562fc7dd" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_is_initialized           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the class is already fully initialized. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="ddcf6766135027ef2b2643b51e91f74c"></a><!-- doxytag: member="vm.h::class_needs_initialization" ref="ddcf6766135027ef2b2643b51e91f74c" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_needs_initialization           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the class is neither initialized nor in the process of being initialized. </dd></dl>

<p>
The intention is that the JIT will emit a call to <code>VM_RT_INITIALIZE_CLASS</code> before every access to a static field in Java. 
</div>
</div><p>
<a class="anchor" name="970edf5079be7eea64e9175996f86017"></a><!-- doxytag: member="vm.h::class_is_before_field_init" ref="970edf5079be7eea64e9175996f86017" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_is_before_field_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For Java returns <code>FALSE</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="4ed45026d94038cebf00aacd000b3ece"></a><!-- doxytag: member="vm.h::class_num_instance_fields" ref="4ed45026d94038cebf00aacd000b3ece" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned class_num_instance_fields           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of instance fields defined in a class. 
<p>
That doesn't include inherited fields. 
</div>
</div><p>
<a class="anchor" name="729237f6ae55ae0458a706d31d854cb1"></a><!-- doxytag: member="vm.h::class_get_instance_field" ref="729237f6ae55ae0458a706d31d854cb1" args="(Class_Handle ch, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_field.html">Field_Handle</a> class_get_instance_field           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the handle for a field. 
<p>
If <code>idx</code> is greater than or equal to <code>class_num_instance_fields</code>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>NULL</code></dd></dl>
The value of idx indexes into the fields defined in this class and doesn't include inherited fields. 
</div>
</div><p>
<a class="anchor" name="a62c9bd82474ecce2405c4cbcfb60856"></a><!-- doxytag: member="vm.h::class_num_instance_fields_recursive" ref="a62c9bd82474ecce2405c4cbcfb60856" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned class_num_instance_fields_recursive           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of instance fields defined in a class. 
<p>
This number includes inherited fields. 
</div>
</div><p>
<a class="anchor" name="9dfae36805b93f66b71785080275792d"></a><!-- doxytag: member="vm.h::class_get_instance_field_recursive" ref="9dfae36805b93f66b71785080275792d" args="(Class_Handle ch, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_field.html">Field_Handle</a> class_get_instance_field_recursive           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the handle for a field. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>NULL</code> if idx is greater than or equal to <code>class_num_instance_fields_recursive</code>.</dd></dl>
The value of idx indexes into the set of fields that includes both fields defined in this class and inherited fields. 
</div>
</div><p>
<a class="anchor" name="9e32d49ce741b0bcb9e001e1c3c91ed4"></a><!-- doxytag: member="vm.h::class_get_number_methods" ref="9e32d49ce741b0bcb9e001e1c3c91ed4" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned class_get_number_methods           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of methods declared in the class. 
<p>

</div>
</div><p>
<a class="anchor" name="796387e217b25781f944e151f4a63e5b"></a><!-- doxytag: member="vm.h::class_get_fast_instanceof_flag" ref="796387e217b25781f944e151f4a63e5b" args="(Class_Handle cl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_get_fast_instanceof_flag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>cl</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if fast_instanceof is applicable for the class. 
<p>

</div>
</div><p>
<a class="anchor" name="bb98234e80439fb00a4b840246308f97"></a><!-- doxytag: member="vm.h::class_get_method" ref="bb98234e80439fb00a4b840246308f97" args="(Class_Handle ch, unsigned index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_method.html">Method_Handle</a> class_get_method           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get handle for a method declared in class. 
<p>

</div>
</div><p>
<a class="anchor" name="ce8cb51e9935888ede4f9b1d32bf8d23"></a><!-- doxytag: member="vm.h::class_is_pinned" ref="ce8cb51e9935888ede4f9b1d32bf8d23" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_is_pinned           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if all instances of this class are pinned. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="7d3bda1c94ce828d7542687167b27480"></a><!-- doxytag: member="vm.h::class_alloc_via_classloader" ref="7d3bda1c94ce828d7542687167b27480" args="(Class_Handle ch, int32 size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void* class_alloc_via_classloader           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if all instances of this class are pinned. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="3a84438c604e485e08a131980698bdc8"></a><!-- doxytag: member="vm.h::class_is_non_ref_array" ref="3a84438c604e485e08a131980698bdc8" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_is_non_ref_array           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if this is an array of primitives. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="cd27b4787353aada8f4c6d5481568810"></a><!-- doxytag: member="vm.h::class_is_finalizable" ref="cd27b4787353aada8f4c6d5481568810" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_is_finalizable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the class has a non-trivial finalizer. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="ea014eb6f44773fcdbf6c8e708f1321a"></a><!-- doxytag: member="vm.h::class_get_alignment" ref="ea014eb6f44773fcdbf6c8e708f1321a" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned class_get_alignment           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This exactly what I want. 
<p>
Get the alignment of the class. 
</div>
</div><p>
<a class="anchor" name="eb382eb32a161bbbaf6920157c04534f"></a><!-- doxytag: member="vm.h::class_get_alignment_unboxed" ref="eb382eb32a161bbbaf6920157c04534f" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned class_get_alignment_unboxed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the alignment of the class when it's unboxed. 
<p>

</div>
</div><p>
<a class="anchor" name="cf23540daa2f6e63a154d79070f04d62"></a><!-- doxytag: member="vm.h::class_element_size" ref="cf23540daa2f6e63a154d79070f04d62" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned class_element_size           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>For a class handle that represents and array, return the size of the element of the array. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="c6fa8d8d18413dc76ee4906c17ec0e71"></a><!-- doxytag: member="vm.h::class_get_boxed_data_size" ref="c6fa8d8d18413dc76ee4906c17ec0e71" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned class_get_boxed_data_size           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The size in bytes of an instance in the heap. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="bfcca8baff598916f64b65d4c746354e"></a><!-- doxytag: member="vm.h::class_get_unboxed_data_offset" ref="bfcca8baff598916f64b65d4c746354e" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned class_get_unboxed_data_offset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The offset to the start of user data form the start of a boxed instance. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="3cdd439496755a48b32a475e97360623"></a><!-- doxytag: member="vm.h::class_get_array_element_size" ref="3cdd439496755a48b32a475e97360623" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned class_get_array_element_size           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The size of array element for the given array class </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="43cc0dee1f629c7a65733c19b273d254"></a><!-- doxytag: member="vm.h::class_get_array_element_class" ref="43cc0dee1f629c7a65733c19b273d254" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> class_get_array_element_class           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The class of the array element of the given class. </dd></dl>

<p>
The behavior is undefined if the parameter does not represent an array class. 
</div>
</div><p>
<a class="anchor" name="678ccd04225d61a3f4f69e9dbc329549"></a><!-- doxytag: member="vm.h::vtable_get_super_array_offset" ref="678ccd04225d61a3f4f69e9dbc329549" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT int vtable_get_super_array_offset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The offset from the start of the vtable at which the superclass hierarchy is stored. </dd></dl>

<p>
This is for use with fast type checking. 
</div>
</div><p>
<a class="anchor" name="553cd6fad5f8b72d45ff53e3f019e2b8"></a><!-- doxytag: member="vm.h::vtable_get_class" ref="553cd6fad5f8b72d45ff53e3f019e2b8" args="(VTable_Handle vh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> vtable_get_class           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_v_table.html">VTable_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>vh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> handle given object's <code>VTable_Handle</code>. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="f8f10b5d4772d1ea8ef6d50a6bf018f4"></a><!-- doxytag: member="vm.h::vm_max_fast_instanceof_depth" ref="f8f10b5d4772d1ea8ef6d50a6bf018f4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT int vm_max_fast_instanceof_depth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of superclass hierarchy elements that are stored within the vtable. </dd></dl>

<p>
This is for use with fast type checking. 
</div>
</div><p>
<a class="anchor" name="cb3b1a91f211f87e9d7ad8178871003d"></a><!-- doxytag: member="vm.h::class_iterator_initialize" ref="cb3b1a91f211f87e9d7ad8178871003d" args="(ChaClassIterator *, Class_Handle root_class)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_iterator_initialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cha_class_iterator.html">ChaClassIterator</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>root_class</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the <code>CHA_Class_Iterator</code>, to iterate over all classes that descend from <code>root_class</code>, including <code>root_class</code> itself. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if iteration is supported over <code>root_class</code>, <code>FALSE</code> if not. </dd></dl>

</div>
</div><p>
<a class="anchor" name="112e03218dfaa0fbd34082cc37b5785d"></a><!-- doxytag: member="vm.h::class_iterator_get_current" ref="112e03218dfaa0fbd34082cc37b5785d" args="(ChaClassIterator *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> class_iterator_get_current           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cha_class_iterator.html">ChaClassIterator</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current class of the iterator. </dd></dl>

<p>
<code>NULL</code> if there are no more classes. 
</div>
</div><p>
<a class="anchor" name="961861d36977a5a62855e2dd57186c39"></a><!-- doxytag: member="vm.h::class_iterator_advance" ref="961861d36977a5a62855e2dd57186c39" args="(ChaClassIterator *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void class_iterator_advance           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cha_class_iterator.html">ChaClassIterator</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Advances the iterator. 
<p>

</div>
</div><p>
<a class="anchor" name="c287c38c58288de3dca1f67e5f0e5803"></a><!-- doxytag: member="vm.h::class_number_inner_classes" ref="c287c38c58288de3dca1f67e5f0e5803" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned class_number_inner_classes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> the number of inner classes. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="ea62375d263b01ef4ad15f94d57a5427"></a><!-- doxytag: member="vm.h::class_is_inner_class_public" ref="ea62375d263b01ef4ad15f94d57a5427" args="(Class_Handle ch, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean class_is_inner_class_public           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if an inner class is public. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="e4b782c7fe3345a77fb639deaabfc6ce"></a><!-- doxytag: member="vm.h::class_get_inner_class" ref="e4b782c7fe3345a77fb639deaabfc6ce" args="(Class_Handle ch, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> class_get_inner_class           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an inner class </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="7f9e1f9e288f07396e9c2ad012fa1c88"></a><!-- doxytag: member="vm.h::class_get_declaring_class" ref="7f9e1f9e288f07396e9c2ad012fa1c88" args="(Class_Handle ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> class_get_declaring_class           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the class that declared this one, or <code>NULL</code> if top-level class </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="576e6da1df5347a9300151905ddf3e0c"></a><!-- doxytag: member="vm.h::field_is_static" ref="576e6da1df5347a9300151905ddf3e0c" args="(Field_Handle fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean field_is_static           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> is the field is static. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="d2badf8680e17dc0bf58b5fecb346de4"></a><!-- doxytag: member="vm.h::field_get_type_info_of_field_value" ref="d2badf8680e17dc0bf58b5fecb346de4" args="(Field_Handle fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_type_desc.html">Type_Info_Handle</a> field_get_type_info_of_field_value           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The type info that represents the type of the field. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="7977d2a91ac12ddf6a853c0cf5ddfe3f"></a><!-- doxytag: member="vm.h::field_get_class_of_field_value" ref="7977d2a91ac12ddf6a853c0cf5ddfe3f" args="(Field_Handle fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> field_get_class_of_field_value           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The class that represents the type of the field. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="2ad45c5a2b82e88249efbb171150813e"></a><!-- doxytag: member="vm.h::field_get_class" ref="2ad45c5a2b82e88249efbb171150813e" args="(Field_Handle fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> field_get_class           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The class that defined that field. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="a72c23f992a64190058d995f8dbdc9c2"></a><!-- doxytag: member="vm.h::field_is_reference" ref="a72c23f992a64190058d995f8dbdc9c2" args="(Field_Handle fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean field_is_reference           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the field is of reference type </dd></dl>

<p>
This function doesn't cause resolution of the class of the field. 
</div>
</div><p>
<a class="anchor" name="35ae29e3265d1a068e3dadd4c04215c3"></a><!-- doxytag: member="vm.h::field_is_magic" ref="35ae29e3265d1a068e3dadd4c04215c3" args="(Field_Handle fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean field_is_magic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the field is a magic type field </dd></dl>

<p>
This function doesn't cause resolution of the class of the field. 
</div>
</div><p>
<a class="anchor" name="3e4647afb03056d428c488a1353632e2"></a><!-- doxytag: member="vm.h::field_is_enumerable_reference" ref="3e4647afb03056d428c488a1353632e2" args="(Field_Handle fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean field_is_enumerable_reference           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the field must be enumerated by GC </dd></dl>

<p>
This function doesn't cause resolution of the class of the field. 
</div>
</div><p>
<a class="anchor" name="9f8cb90776362ed9b7a1de7a67548ad1"></a><!-- doxytag: member="vm.h::field_is_literal" ref="9f8cb90776362ed9b7a1de7a67548ad1" args="(Field_Handle fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean field_is_literal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the field is literal. </dd></dl>

<p>
In Java, it means that the field had the ConstantValue attribute set (JVMS2, Section 4.7.2). 
</div>
</div><p>
<a class="anchor" name="e0c50cd209ac917266521038044c57a6"></a><!-- doxytag: member="vm.h::field_is_unmanaged_static" ref="e0c50cd209ac917266521038044c57a6" args="(Field_Handle fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean field_is_unmanaged_static           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For Java always <code>FALSE</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="fe660da92c80af31f787b642a54e48b9"></a><!-- doxytag: member="vm.h::field_get_offset" ref="fe660da92c80af31f787b642a54e48b9" args="(Field_Handle fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned field_get_offset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The offset to an instance field. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="93283287ccec99ba10cac85f0bda030e"></a><!-- doxytag: member="vm.h::field_get_address" ref="93283287ccec99ba10cac85f0bda030e" args="(Field_Handle fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void* field_get_address           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An address of a static field. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="9b300b07cbd1c9ad2e15d71fa8d024ef"></a><!-- doxytag: member="vm.h::field_get_name" ref="9b300b07cbd1c9ad2e15d71fa8d024ef" args="(Field_Handle fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT const char* field_get_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A name of the field. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="4714a9a3e293af321a7055e3fb8ffa07"></a><!-- doxytag: member="vm.h::field_get_descriptor" ref="4714a9a3e293af321a7055e3fb8ffa07" args="(Field_Handle fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT const char* field_get_descriptor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The field descriptor. </dd></dl>

<p>
The descriptor is a string representation of the field types as defined by the JVM spec. 
</div>
</div><p>
<a class="anchor" name="12b6d0283bc2cf1e5c2c618f9b45d08b"></a><!-- doxytag: member="vm.h::field_is_final" ref="12b6d0283bc2cf1e5c2c618f9b45d08b" args="(Field_Handle fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean field_is_final           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the field is final. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="d0a5db491555a34124fe1c112f2fc51e"></a><!-- doxytag: member="vm.h::field_is_volatile" ref="d0a5db491555a34124fe1c112f2fc51e" args="(Field_Handle fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean field_is_volatile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the field is volatile. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="7c8014018bf5b2358b6969d127466cc1"></a><!-- doxytag: member="vm.h::field_is_private" ref="7c8014018bf5b2358b6969d127466cc1" args="(Field_Handle fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean field_is_private           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the field is private. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="25a88ec668840528d1e619ddb5d7ac12"></a><!-- doxytag: member="vm.h::field_get_track_access_flag" ref="25a88ec668840528d1e619ddb5d7ac12" args="(Field_Handle field, char **address, char *mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void field_get_track_access_flag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The address and bit mask, for the flag which determine whether field access event should be sent. </dd></dl>

<p>
JIT may use the following expression to determine if specified field access should be tracked: ( **address &amp; *mask != 0 )<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>field</em>&nbsp;</td><td>- handle of the field </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>- pointer to the address of the byte which contains the flag </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>- pointer to the bit mask of the flag </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0495c3b312b0877b00ea2d1e624fd6f7"></a><!-- doxytag: member="vm.h::field_get_track_modification_flag" ref="0495c3b312b0877b00ea2d1e624fd6f7" args="(Field_Handle field, char **address, char *mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void field_get_track_modification_flag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_field.html">Field_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the address and bit mask, for the flag which determine whether field modification event should be sent. </dd></dl>

<p>
JIT may use the following expression to determine if specified field modification should be tracked: ( **address &amp; *mask != 0 )<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>field</em>&nbsp;</td><td>- handle of the field </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>- pointer to the address of the byte which contains the flag </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>- pointer to the bit mask of the flag </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="823c4ecab43ef660dfe0bc84d35d50de"></a><!-- doxytag: member="vm.h::method_is_java" ref="823c4ecab43ef660dfe0bc84d35d50de" args="(Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_is_java           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if this a Java method. </dd></dl>

<p>
Every Java JIT must call this function before compiling a method and return <code>JIT_FAILURE</code> if <code>method_is_java</code> returned <code>FALSE</code>. 
</div>
</div><p>
<a class="anchor" name="8a99f803534850c32f4f6bf68b32f3fd"></a><!-- doxytag: member="vm.h::method_get_name" ref="8a99f803534850c32f4f6bf68b32f3fd" args="(Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT const char* method_get_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The method name. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="0ece2189effb8925008de07124cd54a7"></a><!-- doxytag: member="vm.h::method_get_descriptor" ref="0ece2189effb8925008de07124cd54a7" args="(Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT const char* method_get_descriptor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The method descriptor. </dd></dl>

<p>
The descriptor is a string representation of the parameter and return value types as defined by the JVM spec. 
</div>
</div><p>
<a class="anchor" name="0bfa9cd49898f612f8fc9855c6dec4fe"></a><!-- doxytag: member="vm.h::method_get_class" ref="0bfa9cd49898f612f8fc9855c6dec4fe" args="(Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> method_get_class           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A class in which the method is declared. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="d9ac81ed623ff2697b7e88061de9c5d8"></a><!-- doxytag: member="vm.h::method_lock" ref="d9ac81ed623ff2697b7e88061de9c5d8" args="(Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void method_lock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d9e0c4abe0a6c11f492f9dfa28f39f1c"></a><!-- doxytag: member="vm.h::method_unlock" ref="d9e0c4abe0a6c11f492f9dfa28f39f1c" args="(Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void method_unlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5ffd0c652569732159db8934b8947df4"></a><!-- doxytag: member="vm.h::method_is_private" ref="5ffd0c652569732159db8934b8947df4" args="(Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_is_private           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the method is private. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="3c6ef4eadb5f059f10ff758af2785e12"></a><!-- doxytag: member="vm.h::method_is_static" ref="3c6ef4eadb5f059f10ff758af2785e12" args="(Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_is_static           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the method is static. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="e3d4360d25af7138a22a86b30addfda7"></a><!-- doxytag: member="vm.h::method_is_final" ref="e3d4360d25af7138a22a86b30addfda7" args="(Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_is_final           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the method is final. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="f5b7980cb6613c4e74c7b431d2b295fd"></a><!-- doxytag: member="vm.h::method_is_native" ref="f5b7980cb6613c4e74c7b431d2b295fd" args="(Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_is_native           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the method is native. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="5d65dba9fd12b159fe92b6d4fa6ddfbb"></a><!-- doxytag: member="vm.h::method_is_synchronized" ref="5d65dba9fd12b159fe92b6d4fa6ddfbb" args="(Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_is_synchronized           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the method is synchronized. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="27d465190cfdad167635f37bec15fac2"></a><!-- doxytag: member="vm.h::method_is_abstract" ref="27d465190cfdad167635f37bec15fac2" args="(Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_is_abstract           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the method is abstract. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="1732c7bf9268a1990110f0d6f225499d"></a><!-- doxytag: member="vm.h::method_is_strict" ref="1732c7bf9268a1990110f0d6f225499d" args="(Method_Handle m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_is_strict           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Java methods may have a flag set to indicate that floating point operations must be performed in the strict mode. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code><a class="el" href="vm_8h.html#1732c7bf9268a1990110f0d6f225499d" title="Java methods may have a flag set to indicate that floating point operations must...">method_is_strict()</a></code> returns <code>TRUE</code> if the ACC_STRICT flag is set for a Java method and <code>FALSE</code> otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="55e7d296039fec6c3005fb000494a66f"></a><!-- doxytag: member="vm.h::method_is_overridden" ref="55e7d296039fec6c3005fb000494a66f" args="(Method_Handle m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_is_overridden           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the method has been overriden in a subclass and <code>FALSE</code> otherwise. </dd></dl>

<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If <code>method_is_overridden</code> returns <code>FALSE</code>, loading of a subclass later in the execution of the program may change invalidate this condition. If a JIT uses <code>method_is_overridden</code> to implement unconditional inlining, it must be prepared to patch the code later (see <code>vm_register_jit_overridden_method_callback</code>). </dd></dl>

</div>
</div><p>
<a class="anchor" name="9417466408fa3e2ecbcae6778d032797"></a><!-- doxytag: member="vm.h::method_is_no_inlining" ref="9417466408fa3e2ecbcae6778d032797" args="(Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_is_no_inlining           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the method should not be inlined. </dd></dl>

<p>
There may also be other reasons why a method shouldn't be inlined, e.g., native methods can't be inlined and in Java you can't inlined methods that are loaded by a different class loader than the caller. Always <code>FALSE</code> for Java. 
</div>
</div><p>
<a class="anchor" name="697f074fe633fb3163719236c483818e"></a><!-- doxytag: member="vm.h::method_is_require_security_object" ref="697f074fe633fb3163719236c483818e" args="(Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_is_require_security_object           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Always <code>FALSE</code> for Java. 
<p>

</div>
</div><p>
<a class="anchor" name="70677b8f7cf07c05647770e02162f231"></a><!-- doxytag: member="vm.h::method_get_signature" ref="70677b8f7cf07c05647770e02162f231" args="(Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_method___signature.html">Method_Signature_Handle</a> method_get_signature           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A signature that can be used to iterate over method's arguments and query the type of the method result. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="5ef853ad49620a1aefef75b9132311e7"></a><!-- doxytag: member="vm.h::method_find_overridden_method" ref="5ef853ad49620a1aefef75b9132311e7" args="(Class_Handle ch, Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_method.html">Method_Handle</a> method_find_overridden_method           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> <code>ch</code> is a subclass of <code>method_get_class(mh)</code>. 
<p>
The function returns a method handle for an accessible method overriding <code>mh</code> in <code>ch</code> or in its closest superclass that overrides <code>mh</code>. <a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> <code>ch</code> must be a class not an interface. 
</div>
</div><p>
<a class="anchor" name="a8f23d162c6e5a36507f8e4bcefcb306"></a><!-- doxytag: member="vm.h::method_iterator_initialize" ref="a8f23d162c6e5a36507f8e4bcefcb306" args="(ChaMethodIterator *, Method_Handle method, Class_Handle root_class)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_iterator_initialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cha_method_iterator.html">ChaMethodIterator</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>root_class</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the <code>CHA_Method_Iterator</code>, to iterate over all methods that match the method signature and descend from <code>root_class</code> (including <code>root_class</code> itself). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if iteration is supported over <code>root_class</code>, <code>FALSE</code> if not. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3b2bd696014011b520793b6a0a38bd4c"></a><!-- doxytag: member="vm.h::method_iterator_get_current" ref="3b2bd696014011b520793b6a0a38bd4c" args="(const ChaMethodIterator *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_method.html">Method_Handle</a> method_iterator_get_current           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_cha_method_iterator.html">ChaMethodIterator</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current method of the iterator. </dd></dl>

<p>
<code>NULL</code> is returned if therea are no more methods. 
</div>
</div><p>
<a class="anchor" name="302cf46b4982113aad369e0af8655c7a"></a><!-- doxytag: member="vm.h::method_iterator_advance" ref="302cf46b4982113aad369e0af8655c7a" args="(ChaMethodIterator *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void method_iterator_advance           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cha_method_iterator.html">ChaMethodIterator</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Advances the iterator. 
<p>

</div>
</div><p>
<a class="anchor" name="8d8b8aee1e1d67a10efcfafb08d1143a"></a><!-- doxytag: member="vm.h::method_sig_get_descriptor" ref="8d8b8aee1e1d67a10efcfafb08d1143a" args="(Method_Signature_Handle s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT const char* method_sig_get_descriptor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method___signature.html">Method_Signature_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The method descriptor for a given method signature. </dd></dl>

<p>
See <code><a class="el" href="vm_8h.html#0ece2189effb8925008de07124cd54a7" title="The method descriptor.">method_get_descriptor()</a></code>. 
</div>
</div><p>
<a class="anchor" name="f6d6e154b310db9bcbeada2b0a7937b2"></a><!-- doxytag: member="vm.h::method_standalone_signature" ref="f6d6e154b310db9bcbeada2b0a7937b2" args="(Class_Handle ch, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_method___signature.html">Method_Signature_Handle</a> method_standalone_signature           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a signature that can be used to iterate over method's arguments and query the type of the method result. 
<p>
Java doesn't have standalone signatures, so for Java, always return <code>NULL</code>. 
</div>
</div><p>
<a class="anchor" name="397a04552e5b0bdecdab04c921072579"></a><!-- doxytag: member="vm.h::method_vars_get_number" ref="397a04552e5b0bdecdab04c921072579" args="(Method_Handle mh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned method_vars_get_number           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of local variables defined for the method. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="7bddff605c784c0ab32318952f65abe2"></a><!-- doxytag: member="vm.h::method_vars_get_type_info" ref="7bddff605c784c0ab32318952f65abe2" args="(Method_Handle mh, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_type_desc.html">Type_Info_Handle</a> method_vars_get_type_info           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the type info of the local variable number idx. 
<p>
Since local variables are not typed in Java. this function always returns <code>NULL</code> for Java methods. 
</div>
</div><p>
<a class="anchor" name="6e78cff6f6932e91156a145d2b0e1ac2"></a><!-- doxytag: member="vm.h::method_vars_is_managed_pointer" ref="6e78cff6f6932e91156a145d2b0e1ac2" args="(Method_Handle mh, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_vars_is_managed_pointer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the local variable is a managed pointer. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="4a5de76c491f78e239568d0acb773129"></a><!-- doxytag: member="vm.h::method_vars_is_pinned" ref="4a5de76c491f78e239568d0acb773129" args="(Method_Handle mh, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_vars_is_pinned           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>mh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the local variable is pinned. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="8212e3077b85cbe7102f1e9d107c672b"></a><!-- doxytag: member="vm.h::method_args_get_number" ref="8212e3077b85cbe7102f1e9d107c672b" args="(Method_Signature_Handle msh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned method_args_get_number           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method___signature.html">Method_Signature_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>msh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of arguments defined for the method. </dd></dl>

<p>
This number automatically includes the this pointer (if present). 
</div>
</div><p>
<a class="anchor" name="e56fd880462cb94aff60f24b9d5aa1c1"></a><!-- doxytag: member="vm.h::method_args_has_this" ref="e56fd880462cb94aff60f24b9d5aa1c1" args="(Method_Signature_Handle msh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_args_has_this           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method___signature.html">Method_Signature_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>msh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="95f92ad6ddff6814e0385d19a1add1fc"></a><!-- doxytag: member="vm.h::method_args_get_type_info" ref="95f92ad6ddff6814e0385d19a1add1fc" args="(Method_Signature_Handle msh, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_type_desc.html">Type_Info_Handle</a> method_args_get_type_info           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method___signature.html">Method_Signature_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>msh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the class handle of the argument number idx. 
<p>
That's <code>TRUE</code> even for primitive types like int or float. 
</div>
</div><p>
<a class="anchor" name="b09adf75b34753db8f8ada7cb5623b51"></a><!-- doxytag: member="vm.h::method_args_is_managed_pointer" ref="b09adf75b34753db8f8ada7cb5623b51" args="(Method_Signature_Handle msh, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_args_is_managed_pointer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method___signature.html">Method_Signature_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>msh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the argument is a managed pointer. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="45313f07e76f2475cef647d44d30c48e"></a><!-- doxytag: member="vm.h::method_ret_type_get_type_info" ref="45313f07e76f2475cef647d44d30c48e" args="(Method_Signature_Handle msh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_type_desc.html">Type_Info_Handle</a> method_ret_type_get_type_info           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method___signature.html">Method_Signature_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>msh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="951eddf037ecbd47b5961a7a665eec80"></a><!-- doxytag: member="vm.h::method_ret_type_is_managed_pointer" ref="951eddf037ecbd47b5961a7a665eec80" args="(Method_Signature_Handle msh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean method_ret_type_is_managed_pointer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method___signature.html">Method_Signature_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>msh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the return value is a managed pointer. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="be837c89781dcda6b9505e34fbfc3dd7"></a><!-- doxytag: member="vm.h::type_info_is_reference" ref="be837c89781dcda6b9505e34fbfc3dd7" args="(Type_Info_Handle tih)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean type_info_is_reference           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>tih</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array shapes and custom modifiers are not implemented yet. 
<p>
If type info is a reference, <code>type_info_get_class</code> will return the class of the reference. 
</div>
</div><p>
<a class="anchor" name="2ae5f1f09698a8152dc6cb263dc15ec2"></a><!-- doxytag: member="vm.h::type_info_is_unboxed" ref="2ae5f1f09698a8152dc6cb263dc15ec2" args="(Type_Info_Handle tih)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean type_info_is_unboxed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>tih</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If type info is unboxed, <code>type_info_get_class</code> will return the class of the unboxed type and <code>class_is_primitive<code> will return its <code>VM_Data_Type</code>. </code></code>
<p>

</div>
</div><p>
<a class="anchor" name="7f6256dc26a058d6f83f12b352788727"></a><!-- doxytag: member="vm.h::type_info_is_primitive" ref="7f6256dc26a058d6f83f12b352788727" args="(Type_Info_Handle tih)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean type_info_is_primitive           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>tih</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the type is a primitive type. </dd></dl>

<p>
<code>type_info_is_primitive</code> does not cause resolution in contrast to the otherwise equivalentcall sequence suggested in the description of <code>type_info_is_unboxed</code> (i.e. <code>type_info_is_unboxed--&gt;type_info_get_class--&gt;class_is_primitive</code>). 
</div>
</div><p>
<a class="anchor" name="0b186d2c1c44f306b83f2b90a394fbbf"></a><!-- doxytag: member="vm.h::type_info_is_unmanaged_pointer" ref="0b186d2c1c44f306b83f2b90a394fbbf" args="(Type_Info_Handle tih)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean type_info_is_unmanaged_pointer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>tih</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If <code>TRUE</code>, then <code>type_info_get_type_info</code> returns the type info that the pointer points to. 
<p>

</div>
</div><p>
<a class="anchor" name="bf4973d05a86fb5fd4606f9b185554a9"></a><!-- doxytag: member="vm.h::type_info_is_void" ref="bf4973d05a86fb5fd4606f9b185554a9" args="(Type_Info_Handle tih)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean type_info_is_void           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>tih</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For a return value a type can be void when it is not an unmanaged pointer. 
<p>
In all other contexts, if <code>type_info_is_void</code> is <code>TRUE</code> then <code>type_info_is_unmanaged_pointer</code> is <code>TRUE</code> too. 
</div>
</div><p>
<a class="anchor" name="f8584ed9c7880a5b510e7309d2f5957d"></a><!-- doxytag: member="vm.h::type_info_is_method_pointer" ref="f8584ed9c7880a5b510e7309d2f5957d" args="(Type_Info_Handle tih)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean type_info_is_method_pointer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>tih</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If <code>TRUE</code>, use <code>type_info_get_method_sig</code> to retrieve the method signature. 
<p>

</div>
</div><p>
<a class="anchor" name="928106b6baa0854fefaaaa2b269a6a3b"></a><!-- doxytag: member="vm.h::type_info_is_vector" ref="928106b6baa0854fefaaaa2b269a6a3b" args="(Type_Info_Handle tih)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean type_info_is_vector           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>tih</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is it a vector, i.e., a one-dimensional, zero-based array. 
<p>

</div>
</div><p>
<a class="anchor" name="daa547c858cf22735a82fb58c22899ae"></a><!-- doxytag: member="vm.h::type_info_is_general_array" ref="daa547c858cf22735a82fb58c22899ae" args="(Type_Info_Handle tih)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean type_info_is_general_array           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>tih</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is it a general array, i.e., either multidimensional or non zero-based. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>FALSE</code> for vectors. Always <code>FALSE</code> for Java. </dd></dl>

</div>
</div><p>
<a class="anchor" name="97ca25e6014916159060e6d0ecf38a32"></a><!-- doxytag: member="vm.h::type_info_get_type_name" ref="97ca25e6014916159060e6d0ecf38a32" args="(Type_Info_Handle tih)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT const char* type_info_get_type_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>tih</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the name of the class referenced by this type info handle. 
<p>

</div>
</div><p>
<a class="anchor" name="cfc7bd9eeb01be4002c906033edda57e"></a><!-- doxytag: member="vm.h::type_info_get_class" ref="cfc7bd9eeb01be4002c906033edda57e" args="(Type_Info_Handle tih)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> type_info_get_class           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>tih</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the class if <code>type_info_is_reference</code> or <code>type_info_is_unboxed</code> returned <code>TRUE</code>. 
<p>
If the type info is a vector or a general array, return the class handle for the array type (not the element type). 
</div>
</div><p>
<a class="anchor" name="2f58fb826594e617944884c717290d9f"></a><!-- doxytag: member="vm.h::type_info_create_from_java_descriptor" ref="2f58fb826594e617944884c717290d9f" args="(ClassLoaderHandle cl, const char *typeName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_type_desc.html">Type_Info_Handle</a> type_info_create_from_java_descriptor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class_loader.html">ClassLoaderHandle</a>&nbsp;</td>
          <td class="paramname"> <em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>typeName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets Type_Info_Handle from the given type name. 
<p>
Does'n resolve type if not resolved 
</div>
</div><p>
<a class="anchor" name="d07890138ae802f3c279b99fec48abfd"></a><!-- doxytag: member="vm.h::type_info_get_class_no_exn" ref="d07890138ae802f3c279b99fec48abfd" args="(Type_Info_Handle tih)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_class.html">Class_Handle</a> type_info_get_class_no_exn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>tih</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the class if <code>type_info_is_reference</code> or <code>type_info_is_unboxed</code> returned <code>TRUE</code>. 
<p>
If the type info is a vector or a general array, return the class handle for the array type (not the element type). Invokes class loader with no exception but preserves previously raised exception. 
</div>
</div><p>
<a class="anchor" name="1c6072565daa536e203a8916a1c7ea26"></a><!-- doxytag: member="vm.h::type_info_get_method_sig" ref="1c6072565daa536e203a8916a1c7ea26" args="(Type_Info_Handle tih)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_method___signature.html">Method_Signature_Handle</a> type_info_get_method_sig           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>tih</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the method signature if <code>type_info_is_method_pointer</code> returned <code>TRUE</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="a44986f81fb6e6e95c990d94763efc5e"></a><!-- doxytag: member="vm.h::type_info_get_type_info" ref="a44986f81fb6e6e95c990d94763efc5e" args="(Type_Info_Handle tih)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_type_desc.html">Type_Info_Handle</a> type_info_get_type_info           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>tih</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get recursively type info if <code>type_info_is_unmanaged_pointer</code>, <code>type_info_is_vector</code> or <code>type_info_is_general_array</code> returned <code>TRUE</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="f42622b70b3523bc915976172236b1de"></a><!-- doxytag: member="vm.h::type_info_get_type" ref="f42622b70b3523bc915976172236b1de" args="(Type_Info_Handle tih)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="types_8h.html#1365e2757cbbe0e35471ce583e41021f">VM_Data_Type</a> type_info_get_type           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>tih</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return an <code>VM_Data_Type</code> corresponding to a type info. 
<p>
This function is provided for convenience as it can be implemented in terms of other functions provided in this interface. 
</div>
</div><p>
<a class="anchor" name="f33cfb92fd74e7badf16976aea827593"></a><!-- doxytag: member="vm.h::type_info_is_resolved" ref="f33cfb92fd74e7badf16976aea827593" args="(Type_Info_Handle tih)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean type_info_is_resolved           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>tih</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if a type referenced by the given type info handle is resolved. 
<p>

</div>
</div><p>
<a class="anchor" name="e4764a236fbe9b87afe36e50c4fb143c"></a><!-- doxytag: member="vm.h::type_info_get_num_array_dimensions" ref="e4764a236fbe9b87afe36e50c4fb143c" args="(Type_Info_Handle tih)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT uint32 type_info_get_num_array_dimensions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html">Type_Info_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>tih</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns number of array dimension of a type referenced by the given type info handle. 
<p>

</div>
</div><p>
<a class="anchor" name="50007470d78f066505ebc80acadcf522"></a><!-- doxytag: member="vm.h::vector_length_offset" ref="50007470d78f066505ebc80acadcf522" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT int vector_length_offset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the offset to the length field of the array. 
<p>
That field has the same offset for vectors of all types. 
</div>
</div><p>
<a class="anchor" name="1a48d5eb6ee48480c866f9fae1602da9"></a><!-- doxytag: member="vm.h::array_length_offset" ref="1a48d5eb6ee48480c866f9fae1602da9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT int array_length_offset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deprecated. 
<p>
Please use <code>vector_length_offset</code> instead. 
</div>
</div><p>
<a class="anchor" name="3496b252b56be4d193042da4e8618260"></a><!-- doxytag: member="vm.h::vector_first_element_offset" ref="3496b252b56be4d193042da4e8618260" args="(VM_Data_Type element_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT int vector_first_element_offset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#1365e2757cbbe0e35471ce583e41021f">VM_Data_Type</a>&nbsp;</td>
          <td class="paramname"> <em>element_type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the offset to the first element of the vector of the given type. 
<p>
This function is provided for the cases when the class handle of the element is not available. 
</div>
</div><p>
<a class="anchor" name="2e16a0518554d0ac45c4b65650837f93"></a><!-- doxytag: member="vm.h::array_first_element_offset" ref="2e16a0518554d0ac45c4b65650837f93" args="(VM_Data_Type element_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT int array_first_element_offset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#1365e2757cbbe0e35471ce583e41021f">VM_Data_Type</a>&nbsp;</td>
          <td class="paramname"> <em>element_type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deprecated. 
<p>
Please use <code>vector_first_element_offset</code> instead. 
</div>
</div><p>
<a class="anchor" name="fbad0481166bab7fad3b2247e7b2a14f"></a><!-- doxytag: member="vm.h::vector_first_element_offset_class_handle" ref="fbad0481166bab7fad3b2247e7b2a14f" args="(Class_Handle element_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT int vector_first_element_offset_class_handle           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>element_type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the offset to the first element of the vector of the given type. 
<p>
Assume that the elements are boxed. Byte offset. 
</div>
</div><p>
<a class="anchor" name="2bfb6f6d450aabf6e5a6871db6e65c11"></a><!-- doxytag: member="vm.h::array_first_element_offset_class_handle" ref="2bfb6f6d450aabf6e5a6871db6e65c11" args="(Class_Handle element_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT int array_first_element_offset_class_handle           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>element_type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deprecated. 
<p>
Please use <code>vector_first_element_offset_class_handle</code> instead. 
</div>
</div><p>
<a class="anchor" name="573303b273de81b0fcd8764bef57ed8f"></a><!-- doxytag: member="vm.h::vector_first_element_offset_unboxed" ref="573303b273de81b0fcd8764bef57ed8f" args="(Class_Handle element_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT int vector_first_element_offset_unboxed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>element_type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the offset to the first element of the vector of the given type. 
<p>
If the class is a value type, assume that elements are unboxed. If the class is not a value type, assume that elements are references. 
</div>
</div><p>
<a class="anchor" name="94333b53cb72440c0c517374af71448d"></a><!-- doxytag: member="vm.h::array_first_element_offset_unboxed" ref="94333b53cb72440c0c517374af71448d" args="(Class_Handle element_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT int array_first_element_offset_unboxed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>element_type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deprecated. 
<p>
Please use <code>vector_first_element_offset_unboxed</code> instead. 
</div>
</div><p>
<a class="anchor" name="a4e364fc018eb5221e511ab0fbed7826"></a><!-- doxytag: member="vm.h::vector_get_length" ref="a4e364fc018eb5221e511ab0fbed7826" args="(Vector_Handle vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT int32 vector_get_length           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>vector</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the length of a vector. 
<p>
The caller must ensure that GC will not move or deallocate the vector while <a class="el" href="vm_8h.html#a4e364fc018eb5221e511ab0fbed7826" title="Return the length of a vector.">vector_get_length()</a> is active. 
</div>
</div><p>
<a class="anchor" name="b94d88d41b5768c964d42813b8e98cb8"></a><!-- doxytag: member="vm.h::vector_get_element_address_ref" ref="b94d88d41b5768c964d42813b8e98cb8" args="(Vector_Handle vector, int32 idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="types_8h.html#ce9f204c38a2c82a917b9badec5a137e">Managed_Object_Handle</a>* vector_get_element_address_ref           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the address to an element of a vector of references. 
<p>
The caller must ensure that GC will not move or deallocate the vector while <a class="el" href="vm_8h.html#b94d88d41b5768c964d42813b8e98cb8" title="Return the address to an element of a vector of references.">vector_get_element_address_ref()</a> is active. 
</div>
</div><p>
<a class="anchor" name="067f2a252d0911b8404889f04c68cc34"></a><!-- doxytag: member="vm.h::vm_vector_size" ref="067f2a252d0911b8404889f04c68cc34" args="(Class_Handle vector_class, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned vm_vector_size           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>vector_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the size of a vector of a given number of elements. 
<p>
The size is rounded up to take alignment into account. 
</div>
</div><p>
<a class="anchor" name="6ffe6796e756b7eec71175b775da7fa5"></a><!-- doxytag: member="vm.h::vm_references_are_compressed" ref="6ffe6796e756b7eec71175b775da7fa5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean vm_references_are_compressed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if references within objects and vector elements are to be treated as offsets rather than raw pointers. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="60584ceb669817eca2b52517ce73c658"></a><!-- doxytag: member="vm.h::vm_heap_base_address" ref="60584ceb669817eca2b52517ce73c658" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void* vm_heap_base_address           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The starting address of the GC heap. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="fb97e32291132e6a69b4460e9cd1f5c4"></a><!-- doxytag: member="vm.h::vm_heap_ceiling_address" ref="fb97e32291132e6a69b4460e9cd1f5c4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void* vm_heap_ceiling_address           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The ending address of the GC heap. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="3239835bf1c23818d709cad5e85041f7"></a><!-- doxytag: member="vm.h::vm_vtable_pointers_are_compressed" ref="3239835bf1c23818d709cad5e85041f7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean vm_vtable_pointers_are_compressed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>TRUE</code> if vtable pointers within objects are to be treated as offsets rather than raw pointers. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="cca507647c9ada4e13ab829299e603f1"></a><!-- doxytag: member="vm.h::object_get_vtable_offset" ref="cca507647c9ada4e13ab829299e603f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT int object_get_vtable_offset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The offset to the vtable pointer in an object. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="18502aec83bcdd6a0f7b198b45cb5108"></a><!-- doxytag: member="vm.h::vm_get_vtable_base" ref="18502aec83bcdd6a0f7b198b45cb5108" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT POINTER_SIZE_INT vm_get_vtable_base           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The base address of the vtable memory area. </dd></dl>

<p>
This value will never change and can be cached at startup. 
</div>
</div><p>
<a class="anchor" name="9fa3367a6cc544b8b4e73a391e95e77e"></a><!-- doxytag: member="vm.h::vm_get_vtable_ptr_size" ref="9fa3367a6cc544b8b4e73a391e95e77e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT unsigned vm_get_vtable_ptr_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The width in bytes (e.g. </dd></dl>

<p>
4 or 8) of the vtable type information in each object's header. This is typically used by the JIT for generating type-checking code, e.g. for inlined type checks or for inlining of virtual methods. 
</div>
</div><p>
<a class="anchor" name="1a23d1956d2aa4f99721b7042222197f"></a><!-- doxytag: member="vm.h::method_sig_get_string" ref="1a23d1956d2aa4f99721b7042222197f" args="(Method_Signature_Handle msh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT char* method_sig_get_string           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_method___signature.html">Method_Signature_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>msh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A printable signature. </dd></dl>

<p>
The character buffer is owned by the caller. Call <code>free_string_buffer</code> to reclaim the memory. 
</div>
</div><p>
<a class="anchor" name="5a060c364368ea0d6b27c563c90b82bc"></a><!-- doxytag: member="vm.h::free_string_buffer" ref="5a060c364368ea0d6b27c563c90b82bc" args="(char *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void free_string_buffer           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a string buffer returned by <code>method_sig_get_string</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="381b2a8ede4108b3744d13e7372d0b70"></a><!-- doxytag: member="vm.h::set_property" ref="381b2a8ede4108b3744d13e7372d0b70" args="(const char *key, const char *value, PropertyTable table_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void set_property           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a>&nbsp;</td>
          <td class="paramname"> <em>table_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the property for <code>table_number</code> property table. 
<p>
<code>NULL</code> value is supported. 
</div>
</div><p>
<a class="anchor" name="1b334224f93d894a6dcae53eab037508"></a><!-- doxytag: member="vm.h::get_property" ref="1b334224f93d894a6dcae53eab037508" args="(const char *key, PropertyTable table_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT char* get_property           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a>&nbsp;</td>
          <td class="paramname"> <em>table_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property from <code>table_number</code> property table if it has been set by <code>set_property</code> function. </dd></dl>

<p>
Otherwise <code>NULL</code>. 
</div>
</div><p>
<a class="anchor" name="8c0b9897ff821b8bb41bcbab77c95247"></a><!-- doxytag: member="vm.h::destroy_property_value" ref="8c0b9897ff821b8bb41bcbab77c95247" args="(char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void destroy_property_value           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Safety frees memory of value returned by <code>get_property</code> function. 
<p>

</div>
</div><p>
<a class="anchor" name="1c7390b5b8ec406aa085011881dbde54"></a><!-- doxytag: member="vm.h::is_property_set" ref="1c7390b5b8ec406aa085011881dbde54" args="(const char *key, PropertyTable table_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT int is_property_set           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a>&nbsp;</td>
          <td class="paramname"> <em>table_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the property is set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 if <code>table_number</code> is incorrect.<br>
 1 if property is set in <code>table_number</code> property table.<br>
 0 otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="41a27c04098250d67d3588c03bc9163c"></a><!-- doxytag: member="vm.h::unset_property" ref="41a27c04098250d67d3588c03bc9163c" args="(const char *key, PropertyTable table_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void unset_property           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a>&nbsp;</td>
          <td class="paramname"> <em>table_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unsets the property in <code>table_number</code> property table. 
<p>

</div>
</div><p>
<a class="anchor" name="f712aec398f558fc886919ff824369f6"></a><!-- doxytag: member="vm.h::get_properties_keys" ref="f712aec398f558fc886919ff824369f6" args="(PropertyTable table_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT char** get_properties_keys           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a>&nbsp;</td>
          <td class="paramname"> <em>table_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An array of keys from <code>table_number</code> properties table. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="39f9d82ba693d5b85a87881dcdefbd5d"></a><!-- doxytag: member="vm.h::get_properties_keys_staring_with" ref="39f9d82ba693d5b85a87881dcdefbd5d" args="(const char *prefix, PropertyTable table_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT char** get_properties_keys_staring_with           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a>&nbsp;</td>
          <td class="paramname"> <em>table_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An array of keys which start with specified prefix from <code>table_number</code> properties table. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="22d4821645395fe6e6c1f823f9cad5b4"></a><!-- doxytag: member="vm.h::destroy_properties_keys" ref="22d4821645395fe6e6c1f823f9cad5b4" args="(char **keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT void destroy_properties_keys           </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>keys</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Safety frees array of keys memory which returned by <code>get_properties_keys</code> or <code>get_properties_keys_staring_with</code> functions. 
<p>

</div>
</div><p>
<a class="anchor" name="63f5858e59b94f63e5063a0988785ff9"></a><!-- doxytag: member="vm.h::get_boolean_property" ref="63f5858e59b94f63e5063a0988785ff9" args="(const char *property, Boolean default_value, PropertyTable table_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT Boolean get_boolean_property           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean&nbsp;</td>
          <td class="paramname"> <em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a>&nbsp;</td>
          <td class="paramname"> <em>table_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to interpret property value as <code>Boolean</code> and returns it. 
<p>
In case of failure returns <code>default_value</code>. 
</div>
</div><p>
<a class="anchor" name="eeb6adbcfe255289bd87f1a1bd991b6d"></a><!-- doxytag: member="vm.h::get_int_property" ref="eeb6adbcfe255289bd87f1a1bd991b6d" args="(const char *property_name, int default_value, PropertyTable table_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT int get_int_property           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a>&nbsp;</td>
          <td class="paramname"> <em>table_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to interpret property value as <code>int</code> and returns it. 
<p>
In case of failure returns <code>default_value</code>. 
</div>
</div><p>
<a class="anchor" name="4604bb8b59ba1f07a522ca8a10ce9d7b"></a><!-- doxytag: member="vm.h::get_size_property" ref="4604bb8b59ba1f07a522ca8a10ce9d7b" args="(const char *property_name, size_t default_value, PropertyTable table_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT size_t get_size_property           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a>&nbsp;</td>
          <td class="paramname"> <em>table_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to interpret property value as <code>int</code> and returns it. 
<p>
In case of failure returns <code>default_value</code>. 
</div>
</div><p>
<a class="anchor" name="3284a642b996558802c4a600c6c36844"></a><!-- doxytag: member="vm.h::get_numerical_property" ref="3284a642b996558802c4a600c6c36844" args="(const char *property_name, int64 default_value, PropertyTable table_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT int64 get_numerical_property           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&nbsp;</td>
          <td class="paramname"> <em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#20945f6a5a30e2d7e488ecae48f8c6fa">PropertyTable</a>&nbsp;</td>
          <td class="paramname"> <em>table_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="50ea33d32d70e9049c1217ab5b7d0e13"></a><!-- doxytag: member="vm.h::get_method_entry_flag_address" ref="50ea33d32d70e9049c1217ab5b7d0e13" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT char* get_method_entry_flag_address           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the address of the global flag that specifies whether MethodEntry event is enabled. 
<p>
JIT should call this function in case a method is compiled with exe_notify_method_entry flag set. 
</div>
</div><p>
<a class="anchor" name="2f317cb9e7d8f46a37cca2ca68fc2b82"></a><!-- doxytag: member="vm.h::get_method_exit_flag_address" ref="2f317cb9e7d8f46a37cca2ca68fc2b82" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT char* get_method_exit_flag_address           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the address of the global flag that specifies whether MethodExit event is enabled. 
<p>
JIT should call this function in case a method is compiled with exe_notify_method_exit flag set. 
</div>
</div><p>
<hr size="1">
<address style="text-align: center;">
  <small>
    <p>Genereated on Tue Mar 11 19:25:58 2008 by Doxygen.</p>
    <p>(c) Copyright 2005, 2008 The Apache Software Foundation or its licensors, as applicable. </p>
  </small>
</address>
</body>
</html>
