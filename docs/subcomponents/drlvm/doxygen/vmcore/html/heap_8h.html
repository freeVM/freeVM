<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>VM Infrastructure: heap.h File Reference</title>
<link href="hydoxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Packages</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>heap.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This include file specifies the precise interface to heap to be used by all VM components. 
<p>
This is needed in order to provide interface more convenient than raw GC interface.<p>
Using these methods instead of direct GC interface will improve readability, make code more concise, and automatically ensure that all needed checks (like out of memory) are done properly.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>VM Component internal interface </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="">VM interfaces classification </a> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8h.html#3cd28acbcd92ccb5914dc8e5c3f1021c">vm_malloc_with_thread_pointer</a> (unsigned <a class="el" href="jvmti__types_8h.html#3d3621eb57d320cce49279c6c1d59656">size</a>, <a class="el" href="types_8h.html#d2df958921a4a27ea5068be5d7a3b7af">Allocation_Handle</a> ah, void *tp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">calls gc_alloc and checks for OutOfMemoryError by comparing allocation result with NULL and throwing exception as appropriate.  <a href="#3cd28acbcd92ccb5914dc8e5c3f1021c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8h.html#8c8cc7e08b00073315a4aaaa85b38b0c">vm_new_vector</a> (<a class="el" href="struct_class.html">Class</a> *array_class, int <a class="el" href="jvmti__types_8h.html#1ee8a4cdc2176352791e9feef77e1fd5">length</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">allocate new vector.  <a href="#8c8cc7e08b00073315a4aaaa85b38b0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8h.html#d6880fa230b95da93fef89c88cbc21bb">vm_new_vector_primitive</a> (<a class="el" href="struct_class.html">Class</a> *array_class, int <a class="el" href="jvmti__types_8h.html#1ee8a4cdc2176352791e9feef77e1fd5">length</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">allocate new primitive vector.  <a href="#d6880fa230b95da93fef89c88cbc21bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8h.html#568a78a09174fd11e4da71a53d05d6eb">vm_new_vector_or_null</a> (<a class="el" href="struct_class.html">Class</a> *array_class, int <a class="el" href="jvmti__types_8h.html#1ee8a4cdc2176352791e9feef77e1fd5">length</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">allocates new vector.  <a href="#568a78a09174fd11e4da71a53d05d6eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8h.html#dc2a2a010b9602d743c68b5843426a80">vm_new_vector_using_vtable_and_thread_pointer</a> (int <a class="el" href="jvmti__types_8h.html#1ee8a4cdc2176352791e9feef77e1fd5">length</a>, <a class="el" href="types_8h.html#d2df958921a4a27ea5068be5d7a3b7af">Allocation_Handle</a> vector_handle, void *tp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">allocates new vector.  <a href="#dc2a2a010b9602d743c68b5843426a80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8h.html#0bab7b6a08c6d90740a8355d690a7371">vm_new_vector_or_null_using_vtable_and_thread_pointer</a> (int <a class="el" href="jvmti__types_8h.html#1ee8a4cdc2176352791e9feef77e1fd5">length</a>, <a class="el" href="types_8h.html#d2df958921a4a27ea5068be5d7a3b7af">Allocation_Handle</a> vector_handle, void *tp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">allocates new vector.  <a href="#0bab7b6a08c6d90740a8355d690a7371"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8h.html#a8245c7b0a3da9321abce7233afb5847">vm_multianewarray_recursive</a> (<a class="el" href="struct_class.html">Class</a> *clss, int *length_array, unsigned dimensions)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">alocates new multidimensional array recursively.  <a href="#a8245c7b0a3da9321abce7233afb5847"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8h.html#0e5cfb68d29eeb6dba1d33562e1cf71f">vm_multianewarray_resolved</a> (<a class="el" href="struct_class.html">Class</a> *clss, unsigned dimensions,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">allocates new multidimensional array.  <a href="#0e5cfb68d29eeb6dba1d33562e1cf71f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8h.html#a370f724f90e93b228676a1493bd7920">vm_new_vector_update_stats</a> (int <a class="el" href="jvmti__types_8h.html#1ee8a4cdc2176352791e9feef77e1fd5">length</a>, <a class="el" href="types_8h.html#d2df958921a4a27ea5068be5d7a3b7af">Allocation_Handle</a> vector_handle, void *tp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">updates statistics of vertor allocation.  <a href="#a370f724f90e93b228676a1493bd7920"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_managed_object.html">ManagedObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8h.html#9226807d9d0b7404d19b28e902943775">class_alloc_new_object</a> (<a class="el" href="struct_class.html">Class</a> *clss)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">allocate new object using its <a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> structure.  <a href="#9226807d9d0b7404d19b28e902943775"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VMEXPORT <a class="el" href="struct_managed_object.html">ManagedObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8h.html#df889e4e0305b9ffb1b480086d596238">class_alloc_new_object_using_vtable</a> (<a class="el" href="struct_v_table.html">VTable</a> *vtable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">allocates new object using its <a class="el" href="struct_v_table.html">VTable</a> structure.  <a href="#df889e4e0305b9ffb1b480086d596238"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_managed_object.html">ManagedObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8h.html#8ef16fb1904cc92015069f3fd6e57892">class_alloc_new_object_and_run_default_constructor</a> (<a class="el" href="struct_class.html">Class</a> *clss)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">allocates new object and runs its default () constructor.  <a href="#8ef16fb1904cc92015069f3fd6e57892"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_managed_object.html">ManagedObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8h.html#cc6d6e87c1360f71674f2f349a862cc2">class_alloc_new_object_and_run_constructor</a> (<a class="el" href="struct_class.html">Class</a> *clss, <a class="el" href="struct_method.html">Method</a> *constructor, uint8 *constructor_args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">allocates new object and runs specified constructor.  <a href="#cc6d6e87c1360f71674f2f349a862cc2"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="3cd28acbcd92ccb5914dc8e5c3f1021c"></a><!-- doxytag: member="heap.h::vm_malloc_with_thread_pointer" ref="3cd28acbcd92ccb5914dc8e5c3f1021c" args="(unsigned size, Allocation_Handle ah, void *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* vm_malloc_with_thread_pointer           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#d2df958921a4a27ea5068be5d7a3b7af">Allocation_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>ah</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
calls gc_alloc and checks for OutOfMemoryError by comparing allocation result with NULL and throwing exception as appropriate. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Implemented in jit_runtime_support.cpp </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c8cc7e08b00073315a4aaaa85b38b0c"></a><!-- doxytag: member="heap.h::vm_new_vector" ref="8c8cc7e08b00073315a4aaaa85b38b0c" args="(Class *array_class, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a> vm_new_vector           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class</a> *&nbsp;</td>
          <td class="paramname"> <em>array_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
allocate new vector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array_class</em>&nbsp;</td><td><a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> structure of array to be allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length of array to be allocated. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the allocated array, NULL if exception occured, and context is not unwindable, no-return if exception occured in unwindable context.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OutOfMemoryError</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>in case that this method is called from jitted code, unwinding is performed, and this method never returns. In all other cases, current thread exception is set, and control is returned. <p>
implemented in vm_arrays.cpp </dd></dl>

</div>
</div><p>
<a class="anchor" name="d6880fa230b95da93fef89c88cbc21bb"></a><!-- doxytag: member="heap.h::vm_new_vector_primitive" ref="d6880fa230b95da93fef89c88cbc21bb" args="(Class *array_class, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a> vm_new_vector_primitive           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class</a> *&nbsp;</td>
          <td class="paramname"> <em>array_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
allocate new primitive vector. 
<p>
allocate new vector. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array_class</em>&nbsp;</td><td><a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> structure of array to be allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length of array to be allocated. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the allocated array, NULL if exception occured, and context is not unwindable, no-return if exception occured in unwindable context.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OutOfMemoryError</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>in case that this method is called from jitted code, unwinding is performed, and this method never returns. In all other cases, current thread exception is set, and control is returned. <p>
implemented in vm_arrays.cpp </dd></dl>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>attempt to pass non-primitive array class to this function will cause undefined results. </dd></dl>

</div>
</div><p>
<a class="anchor" name="568a78a09174fd11e4da71a53d05d6eb"></a><!-- doxytag: member="heap.h::vm_new_vector_or_null" ref="568a78a09174fd11e4da71a53d05d6eb" args="(Class *array_class, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a> vm_new_vector_or_null           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class</a> *&nbsp;</td>
          <td class="paramname"> <em>array_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
allocates new vector. 
<p>
allocate new vector. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array_class</em>&nbsp;</td><td><a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> structure of array to be allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length of array to be allocated. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the allocated array, NULL if exception occured, and context is not unwindable, no-return if exception occured in unwindable context.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OutOfMemoryError</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>in case that this method is called from jitted code, unwinding is performed, and this method never returns. In all other cases, current thread exception is set, and control is returned. <p>
implemented in vm_arrays.cpp </dd></dl>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>XXX The purpose of this function is not clear. -salikh </dd></dl>

</div>
</div><p>
<a class="anchor" name="dc2a2a010b9602d743c68b5843426a80"></a><!-- doxytag: member="heap.h::vm_new_vector_using_vtable_and_thread_pointer" ref="dc2a2a010b9602d743c68b5843426a80" args="(int length, Allocation_Handle vector_handle, void *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a> vm_new_vector_using_vtable_and_thread_pointer           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#d2df958921a4a27ea5068be5d7a3b7af">Allocation_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>vector_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
allocates new vector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vector_handle</em>&nbsp;</td><td><a class="el" href="struct_v_table.html">VTable</a> structure of array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length of array to be allocated. NULL if exception occured, and context is not unwindable, no-return if exception occured in unwindable context. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>pointer to thread-local data.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the allocated array,</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OutOfMemoryError</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>implemented in vm_arrays.cpp<p>
in case that this method is called from jitted code, unwinding is performed, and this method never returns. In all other cases, current thread exception is set, and control is returned. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0bab7b6a08c6d90740a8355d690a7371"></a><!-- doxytag: member="heap.h::vm_new_vector_or_null_using_vtable_and_thread_pointer" ref="0bab7b6a08c6d90740a8355d690a7371" args="(int length, Allocation_Handle vector_handle, void *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a> vm_new_vector_or_null_using_vtable_and_thread_pointer           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#d2df958921a4a27ea5068be5d7a3b7af">Allocation_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>vector_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
allocates new vector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vector_handle</em>&nbsp;</td><td>pointer to array vtable. allocates new vector.  </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>pointer to thread-local data.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>XXX The purpose of this function is not clear. -salikh </dd></dl>

</div>
</div><p>
<a class="anchor" name="a8245c7b0a3da9321abce7233afb5847"></a><!-- doxytag: member="heap.h::vm_multianewarray_recursive" ref="a8245c7b0a3da9321abce7233afb5847" args="(Class *clss, int *length_array, unsigned dimensions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a> vm_multianewarray_recursive           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class</a> *&nbsp;</td>
          <td class="paramname"> <em>clss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>length_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>dimensions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
alocates new multidimensional array recursively. 
<p>
Recursive allocation means that all subarray are also allocated, and references are stored to top-level multidimensional array, downto simple reference arrays (arrays of dimension 1).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clss</em>&nbsp;</td><td><a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> structure of the multidimensional array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length_array</em>&nbsp;</td><td>dimensions of the array specified as int array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dimensions</em>&nbsp;</td><td>a number of array dimensions </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0e5cfb68d29eeb6dba1d33562e1cf71f"></a><!-- doxytag: member="heap.h::vm_multianewarray_resolved" ref="0e5cfb68d29eeb6dba1d33562e1cf71f" args="(Class *clss, unsigned dimensions,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#123be76de7a06413a3a19da47e67033a">Vector_Handle</a> vm_multianewarray_resolved           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class</a> *&nbsp;</td>
          <td class="paramname"> <em>clss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
allocates new multidimensional array. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clss</em>&nbsp;</td><td><a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> structure of the multidimensional array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dimensions</em>&nbsp;</td><td>a number of array dimensions </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>XXX The full specification of this function is not clear. -salikh </dd></dl>

</div>
</div><p>
<a class="anchor" name="a370f724f90e93b228676a1493bd7920"></a><!-- doxytag: member="heap.h::vm_new_vector_update_stats" ref="a370f724f90e93b228676a1493bd7920" args="(int length, Allocation_Handle vector_handle, void *tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vm_new_vector_update_stats           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#d2df958921a4a27ea5068be5d7a3b7af">Allocation_Handle</a>&nbsp;</td>
          <td class="paramname"> <em>vector_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
updates statistics of vertor allocation. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>XXX is it used in debug version only? -salikh </dd></dl>

</div>
</div><p>
<a class="anchor" name="9226807d9d0b7404d19b28e902943775"></a><!-- doxytag: member="heap.h::class_alloc_new_object" ref="9226807d9d0b7404d19b28e902943775" args="(Class *clss)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_managed_object.html">ManagedObject</a>* class_alloc_new_object           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class</a> *&nbsp;</td>
          <td class="paramname"> <em>clss</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
allocate new object using its <a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> structure. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clss</em>&nbsp;</td><td><a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> structure of the object. </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>XXX exception and out of memory semantics are not specified -salikh </dd></dl>

</div>
</div><p>
<a class="anchor" name="df889e4e0305b9ffb1b480086d596238"></a><!-- doxytag: member="heap.h::class_alloc_new_object_using_vtable" ref="df889e4e0305b9ffb1b480086d596238" args="(VTable *vtable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMEXPORT <a class="el" href="struct_managed_object.html">ManagedObject</a>* class_alloc_new_object_using_vtable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_v_table.html">VTable</a> *&nbsp;</td>
          <td class="paramname"> <em>vtable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
allocates new object using its <a class="el" href="struct_v_table.html">VTable</a> structure. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vtable</em>&nbsp;</td><td><a class="el" href="struct_v_table.html">VTable</a> structure of the object. </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>XXX exception and out of memory semantics are not specified -salikh </dd></dl>

</div>
</div><p>
<a class="anchor" name="8ef16fb1904cc92015069f3fd6e57892"></a><!-- doxytag: member="heap.h::class_alloc_new_object_and_run_default_constructor" ref="8ef16fb1904cc92015069f3fd6e57892" args="(Class *clss)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_managed_object.html">ManagedObject</a>* class_alloc_new_object_and_run_default_constructor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class</a> *&nbsp;</td>
          <td class="paramname"> <em>clss</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
allocates new object and runs its default () constructor. 
<p>
allocate new object using its <a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> structure. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clss</em>&nbsp;</td><td><a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> structure of the object. </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>XXX exception and out of memory semantics are not specified -salikh </dd></dl>
 <dl class="note" compact><dt><b>Note:</b></dt><dd>XXX exception and out of memory semantics are not specified -salikh </dd></dl>

</div>
</div><p>
<a class="anchor" name="cc6d6e87c1360f71674f2f349a862cc2"></a><!-- doxytag: member="heap.h::class_alloc_new_object_and_run_constructor" ref="cc6d6e87c1360f71674f2f349a862cc2" args="(Class *clss, Method *constructor, uint8 *constructor_args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_managed_object.html">ManagedObject</a>* class_alloc_new_object_and_run_constructor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_class.html">Class</a> *&nbsp;</td>
          <td class="paramname"> <em>clss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_method.html">Method</a> *&nbsp;</td>
          <td class="paramname"> <em>constructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&nbsp;</td>
          <td class="paramname"> <em>constructor_args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
allocates new object and runs specified constructor. 
<p>
allocate new object using its <a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> structure. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clss</em>&nbsp;</td><td><a class="el" href="struct_class.html" title="VM representation of Java class.">Class</a> structure of the object. </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>XXX exception and out of memory semantics are not specified -salikh </dd></dl>
 <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>constructor</em>&nbsp;</td><td><a class="el" href="struct_method.html">Method</a> structure of constructor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>constructor_args</em>&nbsp;</td><td>arguments to be passed to constructor </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>XXX exception and out of memory semantics are not specified -salikh </dd></dl>

</div>
</div><p>
<hr size="1">
<address style="text-align: center;">
  <small>
    <p>Genereated on Tue Mar 11 19:25:56 2008 by Doxygen.</p>
    <p>(c) Copyright 2005, 2008 The Apache Software Foundation or its licensors, as applicable. </p>
  </small>
</address>
</body>
</html>
