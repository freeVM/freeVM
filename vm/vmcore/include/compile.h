/*
 *  Copyright 2005-2006 The Apache Software Foundation or its licensors, as applicable.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
/** 
 * @author Intel, Alexei Fedotov
 * @version $Revision: 1.1.2.1.4.3 $
 */  


#ifndef _COMPILE_H_
#define _COMPILE_H_

#include "vm_core_types.h"
#include "environment.h"

class JIT;

extern JIT *jit_compilers[];

void vm_add_jit(JIT *jit);
void vm_delete_all_jits();
void vm_initialize_all_jits();

// Protect arguments from GC
// The arguments are those passed to the last M2nFrame
// The given method's signature describes what arguments were passed
void compile_protect_arguments(Method_Handle method, GcFrame* gc);

// Code has been generated by writing it to memory.
// Ensure that it is visible to all instruction fetchers.
// The first function flushes a particular block of code,
// the other should be called after all blocks are flushed.
void compile_flush_generated_code_block(Byte*, size_t);
void compile_flush_generated_code();

/**
 * Execution manager uses this method to call back to VM to compile
 * a method using a specific JIT.
 */
JIT_Result compile_do_compilation_jit(Method* method, JIT* jit);

NativeCodePtr compile_gen_compile_me(Method_Handle method);
//NativeCodePtr compile_gen_compile_me_exc_throw(int exp);

void patch_code_with_threads_suspended(Byte *code_block, Byte *new_code, size_t size);


// On IPF this type is actually a Merced_Code_Emitter*, while on IA32 it is a char* pointer to a code block for the stub.
typedef void *Emitter_Handle;

// The following function is IA32 only.
// If reference on the stack is null, throw a null pointer exception.
Emitter_Handle gen_throw_if_managed_null_ia32(Emitter_Handle emitter, unsigned stack_pointer_offset);
// The following two null reference conversion procedures are IA32 only.
// Convert a reference on the stack, if null, from a managed (heap_base) to an unmanaged null (NULL/0).
Emitter_Handle gen_convert_managed_to_unmanaged_null_ia32(Emitter_Handle emitter, unsigned stack_pointer_offset);
// Convert a reference on the stack, if null, from an unmanaged (NULL/0) to an managed null (heap_base).
Emitter_Handle gen_convert_unmanaged_to_managed_null_ia32(Emitter_Handle emitter, unsigned stack_pointer_offset);

// The following two null reference conversion procedures are IPF only.
// Convert a reference in register "reg", if null, from a managed null (heap_base) to an unmanaged one (NULL/0). Uses SCRATCH_GENERAL_REG.
void gen_convert_managed_to_unmanaged_null_ipf(Emitter_Handle emitter, unsigned reg);
// Convert a reference in a register, if null, from an unmanaged null (NULL/0) to an managed one (heap_base).
void gen_convert_unmanaged_to_managed_null_ipf(Emitter_Handle emitter, unsigned reg);



struct Compilation_Handle {
    Global_Env* env;
    JIT*        jit;
};

Global_Env* compile_handle_to_environment(Compile_Handle);

// Create a LIL stub for JNI interfacing
NativeCodePtr compile_create_lil_jni_stub(Method_Handle method, void* func, NativeStubOverride nso);

// Create a LIL stub for JNI interfacing
NativeCodePtr interpreter_compile_create_lil_jni_stub(Method_Handle method, void* func, NativeStubOverride nso);


// Create a LIL stub for PINVOKE interfacing
NativeCodePtr compile_create_lil_pinvoke_stub(Method_Handle method, void* func, NativeStubOverride nso);


// The final action taken by a create_call_native_proc_stub() stub after calling "proc_addr". For example, methods are JITed 
// by having the stub jump to the new method's code (CNP_JmpToRetAddrFinalAction) after jit_a_method finishes compiling it.
enum CNP_FinalAction {
    CNP_ReturnFinalAction,        // return after calling the native procedure (e.g. delegate Invoke)
    CNP_JmpToRetAddrFinalAction  // branch to the procedure whose address is returned by "proc_addr" (e.g. JIT compile method)
};


// If CNP_Final_Action is CNP_ReturnFinalAction, the type returned by the called "proc_addr". 
// NB: "proc_addr" MUST return any result in eax/edx as a long (int64) value; The CNP_ReturnType determines 
// what registers to set.from this value.
enum CNP_ReturnType {
    CNP_VoidReturnType,
    CNP_IntReturnType,           // leave the int32/int64 result in eax/edx
    CNP_FloatReturnType,         // move the float32 value in eax to ST(0), the top of the FP stack
    CNP_DoubleReturnType,        // move the float64 value in eax/edx to ST(0), the top of the FP stack
    CNP_NumberOfReturnTypes      // must be last
};


// create_call_native_proc_stub() creates a semi-customized stub that can be used to call a native procedure from managed code.
void *create_call_native_proc_stub(char *proc_addr, char *stub_name, CNP_FinalAction final_action, CNP_ReturnType return_type);


//
// Support for stub override code sequences 
//

typedef void (Override_Generator)(Emitter_Handle, Method *);
typedef unsigned (Override_Size)(Method *);

typedef struct Stub_Override_Entry {
    char *class_name;
    char *method_name;
    char *descriptor;
    Override_Generator *override_generator;
    Override_Size *override_size;
} Stub_Override_Entry;

// Points to an an array of override entries with sizeof_stub_override_entries entries.
extern Stub_Override_Entry *stub_override_entries;

extern int sizeof_stub_override_entries;

// does this method need an override?
bool needs_override(Method*);


//
// Method instrumentation support.
//

// Type of the instrumentation procedures called before invoking methods.
typedef void (*MethodInstrumentationProc)(CodeChunkInfo *callee);

// Interpose on calls to the specified method by calling the instr_proc.
NativeCodePtr compile_do_instrumentation(CodeChunkInfo *callee, MethodInstrumentationProc instr_proc);

// A MethodInstrumentationProc that records the number of calls from the caller code chunk to the callee.
void count_method_calls(CodeChunkInfo *callee);

#endif
