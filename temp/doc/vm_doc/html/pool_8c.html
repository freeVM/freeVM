<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Harmony Class Library Porting: native-src/win.IA32/pool/pool.c File Reference</title>
<link href="hydoxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">native-src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_000001.html">win.IA32</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_000006.html">pool</a></div>
<h1>pool.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Pool primitives (creation, iteration, deletion, etc. 
<p>
)
<p>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &quot;<a class="el" href="hypool_8h.html">hypool.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HyPool *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#a4">pool_new</a> (U_32 structSize, U_32 minNumberElements, U_32 elementAlignment, UDATA poolFlags, void *(VMCALL *memAlloc)(void *, U_32), void(VMCALL *memFree)(void *, void *), void *userData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#a5">pool_kill</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocates all memory associated with a pool.  <a href="#a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#a6">pool_newElement</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asks for the address of a new pool element.  <a href="#a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#a7">pool_removeElement</a> (HyPool *aPool, void *anElement)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocates an element from a pool.  <a href="#a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#a8">pool_do</a> (HyPool *aPool, void(*aFunction)(void *anElement, void *userData), void *userData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls a user provided function for each element in the list.  <a href="#a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#a9">pool_numElements</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of elements in a given pool.  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#a10">pool_startDo</a> (HyPool *aPool, pool_state *lastHandle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#a11">pool_nextDo</a> (pool_state *lastHandle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#a12">pool_sortFree</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the free list of the current pool.  <a href="#a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HyPool *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#a13">pool_forPortLib</a> (U_32 structSize, <a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *portLibrary)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shortcut for <a class="el" href="pool_8c.html#pool_new">pool_new</a>, using the default malloc/free from the portLibrary.  <a href="#a13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8c.html#a14">pool_clear</a> (HyPool *aPool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the contents of a pool but not delete it.  <a href="#a14"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a14"></a><!-- doxytag: member="pool.c::pool_clear" ref="a14" args="(HyPool *aPool)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">pool_clear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>aPool</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clear the contents of a pool but not delete it. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Make no assumptions about the contents of the pool after invoking this method (it currently does not zero the memory)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool to clear</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8"></a><!-- doxytag: member="pool.c::pool_do" ref="a8" args="(HyPool *aPool, void(*aFunction)(void *anElement, void *userData), void *userData)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">pool_do           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname" nowrap> <em>aPool</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void(*)(void *anElement, void *userData)&nbsp;</td>
          <td class="mdname" nowrap> <em>aFunction</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>userData</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calls a user provided function for each element in the list. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool to "do" things to </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aFunction</em>&nbsp;</td><td>Pointer to function which will "do" things to the elements of aPool </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>Pointer to data to be passed to "do" function, along with each pool-element</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>pool_startDo, pool_nextDo</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13"></a><!-- doxytag: member="pool.c::pool_forPortLib" ref="a13" args="(U_32 structSize, HyPortLibrary *portLibrary)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">pool_forPortLib           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">U_32&nbsp;</td>
          <td class="mdname" nowrap> <em>structSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structHyPortLibrary.html">HyPortLibrary</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>portLibrary</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Shortcut for <a class="el" href="pool_8c.html#pool_new">pool_new</a>, using the default malloc/free from the portLibrary. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>structSize</em>&nbsp;</td><td>size of pool-element </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portLibrary</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>pointer to a Pool</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>pool_new</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5"></a><!-- doxytag: member="pool.c::pool_kill" ref="a5" args="(HyPool *aPool)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">pool_kill           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>aPool</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deallocates all memory associated with a pool. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>Pool to be deallocated</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4"></a><!-- doxytag: member="pool.c::pool_new" ref="a4" args="(U_32 structSize, U_32 minNumberElements, U_32 elementAlignment, UDATA poolFlags, void *(VMCALL *memAlloc)(void *, U_32), void(VMCALL *memFree)(void *, void *), void *userData)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">pool_new           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">U_32&nbsp;</td>
          <td class="mdname" nowrap> <em>structSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>U_32&nbsp;</td>
          <td class="mdname" nowrap> <em>minNumberElements</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>U_32&nbsp;</td>
          <td class="mdname" nowrap> <em>elementAlignment</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>UDATA&nbsp;</td>
          <td class="mdname" nowrap> <em>poolFlags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>(VMCALL *memAlloc)(void *, U_32), </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void(VMCALL *memFree)(void *, void *)&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>userData</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<h2><a class="anchor" name="pool_new">
pool_new</a></h2>
Returns a handle to a variable sized pool of structures. This handle should be passed into all other pool functions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>structSize</em>&nbsp;</td><td>Size of the pool-elements </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>minNumberElements</em>&nbsp;</td><td>If zero, will default to 1 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>elementAlignment</em>&nbsp;</td><td>If zero will default to MIN_GRANULARITY </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>poolFlags</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>memAlloc</em>&nbsp;</td><td>Allocate function pointer </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>memFree</em>&nbsp;</td><td>Free function pointer </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>pointer to a new pool</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a6"></a><!-- doxytag: member="pool.c::pool_newElement" ref="a6" args="(HyPool *aPool)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">pool_newElement           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>aPool</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Asks for the address of a new pool element. 
<p>
If it succeeds, the address returned will have space for one element of the correct structure size. The contents of the element are undefined. If the current pool is full, a new one will be grafted onto the end of the pool chain and memory from there will be used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NULL on error <p>
pointer to a new element otherwise</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11"></a><!-- doxytag: member="pool.c::pool_nextDo" ref="a11" args="(pool_state *lastHandle)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">pool_nextDo           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pool_state *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>lastHandle</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<h2><a class="anchor" name="pool_nextDo">
pool_nextDo</a></h2>
Continue an iteration based on state passed in by lastHandle. It is safe to stop an iteration midway through.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lastHandle</em>&nbsp;</td><td>pointer for current iteration state</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NULL nothing more to be done <p>
pointer to next element to be processed otherwise</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hypool_8h.html#a12">pool_do</a>, pool_startDo</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9"></a><!-- doxytag: member="pool.c::pool_numElements" ref="a9" args="(HyPool *aPool)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">pool_numElements           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>aPool</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of elements in a given pool. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on error <p>
the number of elements in the pool otherwise</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a7"></a><!-- doxytag: member="pool.c::pool_removeElement" ref="a7" args="(HyPool *aPool, void *anElement)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">pool_removeElement           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname" nowrap> <em>aPool</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>anElement</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deallocates an element from a pool. 
<p>
It is safe to call <a class="el" href="pool_8c.html#a7">pool_removeElement()</a> while looping over the pool with <a class="el" href="pool_8c.html#pool_startDo">pool_startDo</a> / <a class="el" href="pool_8c.html#pool_nextDo">pool_nextDo</a> on the element returned by those calls. This is because the free element is always inserted at either the head of the free list or before the nextFree element in the pool_state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>anElement</em>&nbsp;</td><td>Pointer to the element to be removed</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12"></a><!-- doxytag: member="pool.c::pool_sortFree" ref="a12" args="(HyPool *aPool)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">pool_sortFree           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>aPool</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sorts the free list of the current pool. 
<p>
(ie: does not follow nextPool pointers...) This is a O(n) most of the time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool to be sorted</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a10"></a><!-- doxytag: member="pool.c::pool_startDo" ref="a10" args="(HyPool *aPool, pool_state *lastHandle)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">pool_startDo           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HyPool *&nbsp;</td>
          <td class="mdname" nowrap> <em>aPool</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>pool_state *&nbsp;</td>
          <td class="mdname" nowrap> <em>lastHandle</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<h2><a class="anchor" name="pool_startDo">
pool_startDo</a></h2>
Start of an iteration set that will return when code is to be executed. This is based strongly on pool_sortFreeAndIterateUsed. Pass in a pointer to an empty pool_state and it will be filled in.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPool</em>&nbsp;</td><td>The pool to "do" things to </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lastHandle</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NULL <p>
pointer to element otherwise</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hypool_8h.html#a12">pool_do</a>, pool_nextDo</dd></dl>
    </td>
  </tr>
</table>
<hr size="1">
<address style="text-align: center;">
  <small>
    (c) Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
  </small>
</address>
</body>
</html>
