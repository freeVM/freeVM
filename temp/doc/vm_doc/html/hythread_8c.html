<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Harmony Class Library Porting: native-src/win.IA32/thread/hythread.c File Reference</title>
<link href="hydoxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">native-src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_000001.html">win.IA32</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_000008.html">thread</a></div>
<h1>hythread.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Threading and synchronization support. 
<p>

<p>
<code>#include &quot;threaddef.h&quot;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a103">hythread_shutdown</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shut down the threading library associated with the current thread.  <a href="#a103"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a107">hythread_init</a> (hythread_library_t lib)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a threading library.  <a href="#a107"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">hythread_t VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a128">hythread_self</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the hythread_t for the current thread.  <a href="#a128"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a129">hythread_create</a> (hythread_t *handle, UDATA stacksize, UDATA priority, UDATA suspend, hythread_entrypoint_t entrypoint, void *entryarg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new OS thread.  <a href="#a129"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a130">hythread_attach</a> (hythread_t *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach an OS thread to the threading library.  <a href="#a130"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a131">hythread_suspend</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suspend the current thread.  <a href="#a131"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a132">hythread_resume</a> (hythread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resume a thread.  <a href="#a132"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a133">hythread_yield</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Yield the processor.  <a href="#a133"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a136">hythread_monitor_destroy</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a monitor.  <a href="#a136"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a137">hythread_monitor_enter</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enter a monitor.  <a href="#a137"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a138">hythread_monitor_exit</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exit a monitor.  <a href="#a138"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a139">hythread_monitor_wait</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait on a monitor until notified.  <a href="#a139"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a140">hythread_monitor_notify</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify a single thread waiting on a monitor.  <a href="#a140"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a141">hythread_monitor_notify_all</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify all threads waiting on a monitor.  <a href="#a141"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a142">hythread_tls_alloc</a> (hythread_tls_key_t *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a thread local storage (TLS) key.  <a href="#a142"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a143">hythread_tls_free</a> (hythread_tls_key_t key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a TLS key.  <a href="#a143"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a144">hythread_tls_set</a> (hythread_t thread, hythread_tls_key_t key, void *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a thread's TLS value.  <a href="#a144"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a145">hythread_set_priority</a> (hythread_t thread, UDATA priority)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a thread's execution priority.  <a href="#a145"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a146">hythread_interrupt</a> (hythread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interrupt a thread.  <a href="#a146"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a147">hythread_interrupted</a> (hythread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of a thread's interrupted flag.  <a href="#a147"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a148">hythread_clear_interrupted</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the interrupted flag of the current thread and return its previous value.  <a href="#a148"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a149">hythread_sleep_interruptable</a> (I_64 millis, IDATA nanos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suspend the current thread from executing for at least the specified time.  <a href="#a149"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a150">hythread_sleep</a> (I_64 millis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suspend the current thread from executing for at least the specified time.  <a href="#a150"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a153">hythread_cancel</a> (hythread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Terminate a running thread.  <a href="#a153"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a154">hythread_detach</a> (hythread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach a thread from the threading library.  <a href="#a154"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL NORETURN&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a155">hythread_exit</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exit the current thread.  <a href="#a155"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a156">hythread_priority_interrupt</a> (hythread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Priority interrupt a thread.  <a href="#a156"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a157">hythread_priority_interrupted</a> (hythread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of a thread's priority interrupted flag.  <a href="#a157"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a158">hythread_clear_priority_interrupted</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the priority interrupted flag of the current thread and return its previous value.  <a href="#a158"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a159">hythread_monitor_try_enter</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to enter a monitor without blocking.  <a href="#a159"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a160">hythread_monitor_wait_timed</a> (hythread_monitor_t monitor, I_64 millis, IDATA nanos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait on a monitor until notified or timed out.  <a href="#a160"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA *VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a161">hythread_global</a> (char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch or create a 'named global'.  <a href="#a161"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a166">hythread_monitor_wait_interruptable</a> (hythread_monitor_t monitor, I_64 millis, IDATA nanos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait on a monitor until notified, interrupted (priority or normal), or timed out.  <a href="#a166"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a167">hythread_monitor_num_waiting</a> (hythread_monitor_t monitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns how many threads are currently waiting on a monitor.  <a href="#a167"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a168">hythread_monitor_exit_using_threadId</a> (hythread_monitor_t monitor, hythread_t threadId)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exit a monitor.  <a href="#a168"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a169">hythread_monitor_enter_using_threadId</a> (hythread_monitor_t monitor, hythread_t threadId)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enter a monitor.  <a href="#a169"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a170">hythread_monitor_try_enter_using_threadId</a> (hythread_monitor_t monitor, hythread_t threadId)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to enter a monitor without blocking.  <a href="#a170"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a175">hythread_lib_get_flags</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get threading library global flags.  <a href="#a175"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a176">hythread_lib_set_flags</a> (UDATA flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set threading library global flags.  <a href="#a176"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a177">hythread_lib_clear_flags</a> (UDATA flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear specified threading library global flags.  <a href="#a177"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a178">hythread_monitor_init_with_name</a> (hythread_monitor_t *handle, UDATA flags, char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire and initialize a new monitor from the threading library.  <a href="#a178"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a181">hythread_lib_lock</a> (hythread_t self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire the threading library's global lock.  <a href="#a181"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a182">hythread_lib_unlock</a> (hythread_t self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the threading library's global lock.  <a href="#a182"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a183">hythread_park</a> (I_64 millis, IDATA nanos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">'Park' the current thread.  <a href="#a183"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a184">hythread_unpark</a> (hythread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">'Unpark' the specified thread.  <a href="#a184"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a185">hythread_tls_alloc_with_finalizer</a> (hythread_tls_key_t *handle, hythread_tls_finalizer_t finalizer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a thread local storage (TLS) key.  <a href="#a185"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UDATA VMCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hythread_8c.html#a186">hythread_current_stack_free</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the remaining useable bytes of the current thread's OS stack.  <a href="#a186"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a130"></a><!-- doxytag: member="hythread.c::hythread_attach" ref="a130" args="(hythread_t *handle)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_attach           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>handle</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Attach an OS thread to the threading library. 
<p>
Create a new hythread_t to represent the existing OS thread. Attaching a thread is required when a thread was created outside of the threading library wants to use any of the threading library functionality.<p>
If the OS thread is already attached, handle is set to point to the existing hythread_t.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>pointer to a hythread_t to be set (will be ignored if null) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or negative value on failure</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a154">hythread_detach</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a153"></a><!-- doxytag: member="hythread.c::hythread_cancel" ref="a153" args="(hythread_t thread)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void VMCALL hythread_cancel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>thread</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Terminate a running thread. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>This should only be used as a last resort. The system may be in an unpredictable state once a thread is cancelled. In addition, the thread may not even stop running if it refuses to cancel.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>a thread to be terminated </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a148"></a><!-- doxytag: member="hythread.c::hythread_clear_interrupted" ref="a148" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">UDATA VMCALL hythread_clear_interrupted           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clear the interrupted flag of the current thread and return its previous value. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>previous value of interrupted flag: non-zero if the thread had been interrupted.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a158"></a><!-- doxytag: member="hythread.c::hythread_clear_priority_interrupted" ref="a158" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">UDATA VMCALL hythread_clear_priority_interrupted           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clear the priority interrupted flag of the current thread and return its previous value. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>previous value of priority interrupted flag: nonzero if the thread had been priority interrupted.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a129"></a><!-- doxytag: member="hythread.c::hythread_create" ref="a129" args="(hythread_t *handle, UDATA stacksize, UDATA priority, UDATA suspend, hythread_entrypoint_t entrypoint, void *entryarg)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_create           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>UDATA&nbsp;</td>
          <td class="mdname" nowrap> <em>stacksize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>UDATA&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>UDATA&nbsp;</td>
          <td class="mdname" nowrap> <em>suspend</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>hythread_entrypoint_t&nbsp;</td>
          <td class="mdname" nowrap> <em>entrypoint</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>entryarg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new OS thread. 
<p>
The created thread is attached to the threading library.<br>
 <br>
 Unlike POSIX, this doesn't require an attributes structure. Instead, any interesting attributes (e.g. stacksize) are passed in with the arguments.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>a pointer to a hythread_t which will point to the thread (if successfully created) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stacksize</em>&nbsp;</td><td>the size of the new thread's stack (bytes)<br>
 0 indicates use default size </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>priorities range from HYTHREAD_PRIORITY_MIN to HYTHREAD_PRIORITY_MAX (inclusive) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>suspend</em>&nbsp;</td><td>set to non-zero to create the thread in a suspended state. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>entrypoint</em>&nbsp;</td><td>pointer to the function which the thread will run </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>entryarg</em>&nbsp;</td><td>a value to pass to the entrypoint function</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or negative value on failure</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a155">hythread_exit</a>, <a class="el" href="hythread_8c.html#a132">hythread_resume</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a186"></a><!-- doxytag: member="hythread.c::hythread_current_stack_free" ref="a186" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">UDATA VMCALL hythread_current_stack_free           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the remaining useable bytes of the current thread's OS stack. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>OS stack free size in bytes, 0 if it cannot be determined.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a154"></a><!-- doxytag: member="hythread.c::hythread_detach" ref="a154" args="(hythread_t thread)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void VMCALL hythread_detach           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>thread</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Detach a thread from the threading library. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Assumes that the thread being detached is already attached.<br>
</dd></dl>
If the thread is an attached thread, then detach should only be called by the thread itself. Internal resources associated with the thread are freed.<p>
If the thread is already dead, this call will destroy it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>a hythread_t representing the thread to be detached. If this is NULL, the current thread is detached. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a130">hythread_attach</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a155"></a><!-- doxytag: member="hythread.c::hythread_exit" ref="a155" args="(hythread_monitor_t monitor)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void VMCALL NORETURN hythread_exit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_monitor_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>monitor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Exit the current thread. 
<p>
If the thread has been detached, it is destroyed.<p>
If monitor is not NULL, the monitor will be exited before the thread terminates. This is useful if the thread wishes to signal its termination to a watcher, since it exits the monitor and terminates the thread without ever returning control to the thread's routine, which might be running in a DLL which is about to be closed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>monitor to be exited before exiting (ignored if NULL) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a161"></a><!-- doxytag: member="hythread.c::hythread_global" ref="a161" args="(char *name)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">UDATA* VMCALL hythread_global           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fetch or create a 'named global'. 
<p>
Return a pointer to the data associated with a named global with the specified name.<br>
 A new named global is created if a named global with the specified name can't be found.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>name of named global to read/create </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to a UDATA associated with name<br>
 0 on failure.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a107"></a><!-- doxytag: member="hythread.c::hythread_init" ref="a107" args="(hythread_library_t lib)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void VMCALL hythread_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_library_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>lib</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a threading library. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>This must only be called once.</dd></dl>
If any OS threads were created before calling this function, they must be attached using hythread_attach before accessing any thread library functions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lib</em>&nbsp;</td><td>pointer to the thread library to be initialized (non-NULL) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The thead library's initStatus will be set to 0 on success or a negative value on failure.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a130">hythread_attach</a>, <a class="el" href="hythread_8c.html#a103">hythread_shutdown</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a146"></a><!-- doxytag: member="hythread.c::hythread_interrupt" ref="a146" args="(hythread_t thread)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void VMCALL hythread_interrupt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>thread</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Interrupt a thread. 
<p>
If the thread is currently blocked (i.e. waiting on a monitor_wait or sleeping) resume the thread and cause it to return from the blocking function with HYTHREAD_INTERRUPTED.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>a thead to be interrupted </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a147"></a><!-- doxytag: member="hythread.c::hythread_interrupted" ref="a147" args="(hythread_t thread)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">UDATA VMCALL hythread_interrupted           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>thread</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the value of a thread's interrupted flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>thread to be queried </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if not interrupted, non-zero if interrupted</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a177"></a><!-- doxytag: member="hythread.c::hythread_lib_clear_flags" ref="a177" args="(UDATA flags)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">UDATA VMCALL hythread_lib_clear_flags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">UDATA&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>flags</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clear specified threading library global flags. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a176">hythread_lib_set_flags</a>, <a class="el" href="hythread_8c.html#a175">hythread_lib_get_flags</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>flags to be cleared (bit vector: 1 means clear the flag, 0 means ignore) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>old flags values</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a175"></a><!-- doxytag: member="hythread.c::hythread_lib_get_flags" ref="a175" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">UDATA VMCALL hythread_lib_get_flags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get threading library global flags. 
<p>
Returns the flags for the threading library associated with the current thread.<p>
<dl compact><dt><b>Note:</b></dt><dd>: assumes caller has global lock</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a177">hythread_lib_clear_flags</a>, <a class="el" href="hythread_8c.html#a176">hythread_lib_set_flags</a>, <a class="el" href="hythread_8c.html#a181">hythread_lib_lock</a> </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>current flags value</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a181"></a><!-- doxytag: member="hythread.c::hythread_lib_lock" ref="a181" args="(hythread_t self)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void VMCALL hythread_lib_lock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Acquire the threading library's global lock. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>This must not be called recursively by a thread that already owns the global lock. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>self</em>&nbsp;</td><td>hythread_t for the current thread </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a182">hythread_lib_unlock</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a176"></a><!-- doxytag: member="hythread.c::hythread_lib_set_flags" ref="a176" args="(UDATA flags)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">UDATA VMCALL hythread_lib_set_flags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">UDATA&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>flags</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set threading library global flags. 
<p>
Sets the flags for the threading library associated with the current thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>flags to be set (bit vector: 1 means set the flag, 0 means ignore) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>old flags values </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a177">hythread_lib_clear_flags</a>, <a class="el" href="hythread_8c.html#a175">hythread_lib_get_flags</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a182"></a><!-- doxytag: member="hythread.c::hythread_lib_unlock" ref="a182" args="(hythread_t self)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void VMCALL hythread_lib_unlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Release the threading library's global lock. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>This must be called only by the thread that currently has the global lock locked. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>self</em>&nbsp;</td><td>hythread_t for the current thread </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a181">hythread_lib_lock</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a136"></a><!-- doxytag: member="hythread.c::hythread_monitor_destroy" ref="a136" args="(hythread_monitor_t monitor)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_monitor_destroy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_monitor_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>monitor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy a monitor. 
<p>
Destroying a monitor frees the internal resources associated with it.<p>
<dl compact><dt><b>Note:</b></dt><dd>A monitor must NOT be destroyed if threads are waiting on it, or if it is currently owned.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be destroyed </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or non-0 on failure (the monitor is in use)</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a178">hythread_monitor_init_with_name</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a137"></a><!-- doxytag: member="hythread.c::hythread_monitor_enter" ref="a137" args="(hythread_monitor_t monitor)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_monitor_enter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_monitor_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>monitor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enter a monitor. 
<p>
A thread may re-enter a monitor it owns multiple times, but must exit the monitor the same number of times before any other thread wanting to enter the monitor is permitted to continue.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be entered </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success<br>
 HYTHREAD_PRIORITY_INTERRUPTED if the thread was priority interrupted while blocked</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a169">hythread_monitor_enter_using_threadId</a>, <a class="el" href="hythread_8c.html#a138">hythread_monitor_exit</a>, <a class="el" href="hythread_8c.html#a168">hythread_monitor_exit_using_threadId</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a169"></a><!-- doxytag: member="hythread.c::hythread_monitor_enter_using_threadId" ref="a169" args="(hythread_monitor_t monitor, hythread_t threadId)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_monitor_enter_using_threadId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_monitor_t&nbsp;</td>
          <td class="mdname" nowrap> <em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>hythread_t&nbsp;</td>
          <td class="mdname" nowrap> <em>threadId</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enter a monitor. 
<p>
This is a slightly faster version of hythread_monitor_enter because the hythread_t for the current thread doesn't have to be looked up<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be entered </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadId</em>&nbsp;</td><td>hythread_t for the current thread </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success<br>
 HYTHREAD_PRIORITY_INTERRUPTED if the thread was priority interrupted while blocked</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a137">hythread_monitor_enter</a>, <a class="el" href="hythread_8c.html#a138">hythread_monitor_exit</a>, <a class="el" href="hythread_8c.html#a168">hythread_monitor_exit_using_threadId</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a138"></a><!-- doxytag: member="hythread.c::hythread_monitor_exit" ref="a138" args="(hythread_monitor_t monitor)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_monitor_exit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_monitor_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>monitor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Exit a monitor. 
<p>
Exit a monitor, and if the owning count is zero, release it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be exited </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, <br>
HYTHREAD_ILLEGAL_MONITOR_STATE if the current thread does not own the monitor</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a168">hythread_monitor_exit_using_threadId</a>, <a class="el" href="hythread_8c.html#a137">hythread_monitor_enter</a>, <a class="el" href="hythread_8c.html#a169">hythread_monitor_enter_using_threadId</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a168"></a><!-- doxytag: member="hythread.c::hythread_monitor_exit_using_threadId" ref="a168" args="(hythread_monitor_t monitor, hythread_t threadId)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_monitor_exit_using_threadId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_monitor_t&nbsp;</td>
          <td class="mdname" nowrap> <em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>hythread_t&nbsp;</td>
          <td class="mdname" nowrap> <em>threadId</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Exit a monitor. 
<p>
This is a slightly faster version of hythread_monitor_exit because the hythread_t for the current thread doesn't have to be looked up<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be exited </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadId</em>&nbsp;</td><td>hythread_t for the current thread </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success<br>
 HYTHREAD_ILLEGAL_MONITOR_STATE if the current thread does not own the monitor</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a138">hythread_monitor_exit</a>, <a class="el" href="hythread_8c.html#a137">hythread_monitor_enter</a>, <a class="el" href="hythread_8c.html#a169">hythread_monitor_enter_using_threadId</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a178"></a><!-- doxytag: member="hythread.c::hythread_monitor_init_with_name" ref="a178" args="(hythread_monitor_t *handle, UDATA flags, char *name)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_monitor_init_with_name           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_monitor_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>UDATA&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Acquire and initialize a new monitor from the threading library. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>pointer to a hythread_monitor_t to be set to point to the new monitor </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>initial flag values for the monitor </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>pointer to a C string with a description of how the monitor will be used (may be NULL)<br>
 If non-NULL, the C string must be valid for the entire life of the monitor</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or negative value on failure</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a136">hythread_monitor_destroy</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a140"></a><!-- doxytag: member="hythread.c::hythread_monitor_notify" ref="a140" args="(hythread_monitor_t monitor)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_monitor_notify           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_monitor_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>monitor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Notify a single thread waiting on a monitor. 
<p>
A thread is considered to be waiting on the monitor if it is currently blocked while executing hythread_monitor_wait on the monitor.<p>
If no threads are waiting, no action is taken.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be signaled </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 once the monitor has been signaled<br>
 HYTHREAD_ILLEGAL_MONITOR_STATE if the current thread does not own the monitor</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a141">hythread_monitor_notify_all</a>, <a class="el" href="hythread_8c.html#a137">hythread_monitor_enter</a>, <a class="el" href="hythread_8c.html#a139">hythread_monitor_wait</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a141"></a><!-- doxytag: member="hythread.c::hythread_monitor_notify_all" ref="a141" args="(hythread_monitor_t monitor)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_monitor_notify_all           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_monitor_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>monitor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Notify all threads waiting on a monitor. 
<p>
A thread is considered to be waiting on the monitor if it is currently blocked while executing hythread_monitor_wait on the monitor.<p>
If no threads are waiting, no action is taken.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be signaled </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 once the monitor has been signaled<br>
 HYTHREAD_ILLEGAL_MONITOR_STATE if the current thread does not own the monitor</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a140">hythread_monitor_notify</a>, <a class="el" href="hythread_8c.html#a137">hythread_monitor_enter</a>, <a class="el" href="hythread_8c.html#a139">hythread_monitor_wait</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a167"></a><!-- doxytag: member="hythread.c::hythread_monitor_num_waiting" ref="a167" args="(hythread_monitor_t monitor)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">UDATA VMCALL hythread_monitor_num_waiting           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_monitor_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>monitor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns how many threads are currently waiting on a monitor. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>This can only be called by the owner of this monitor.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>number of threads waiting on the monitor (&gt;=0)</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a159"></a><!-- doxytag: member="hythread.c::hythread_monitor_try_enter" ref="a159" args="(hythread_monitor_t monitor)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_monitor_try_enter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_monitor_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>monitor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Attempt to enter a monitor without blocking. 
<p>
If the thread must block before it enters the monitor this function returns immediately with a negative value to indicate failure.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or negative value on failure</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a170">hythread_monitor_try_enter_using_threadId</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a170"></a><!-- doxytag: member="hythread.c::hythread_monitor_try_enter_using_threadId" ref="a170" args="(hythread_monitor_t monitor, hythread_t threadId)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_monitor_try_enter_using_threadId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_monitor_t&nbsp;</td>
          <td class="mdname" nowrap> <em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>hythread_t&nbsp;</td>
          <td class="mdname" nowrap> <em>threadId</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Attempt to enter a monitor without blocking. 
<p>
If the thread must block before it enters the monitor this function returns immediately with a negative value to indicate failure.<br>
<p>
This is a slightly faster version of hythread_monitor_try_enter because the current thread's hythread_t doesn't have to be looked up.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadId</em>&nbsp;</td><td>the current thread </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or negative value on failure</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a159">hythread_monitor_try_enter</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a139"></a><!-- doxytag: member="hythread.c::hythread_monitor_wait" ref="a139" args="(hythread_monitor_t monitor)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_monitor_wait           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_monitor_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>monitor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait on a monitor until notified. 
<p>
Release the monitor, wait for a signal (notification), then re-acquire the monitor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be waited on </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the monitor has been waited on, notified, and reobtained<br>
 HYTHREAD_INVALID_ARGUMENT if millis or nanos is out of range (millis or nanos &lt; 0, or nanos &gt;= 1E6)<br>
 HYTHREAD_ILLEGAL_MONITOR_STATE if the current thread does not own the monitor</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a166">hythread_monitor_wait_interruptable</a>, <a class="el" href="hythread_8c.html#a160">hythread_monitor_wait_timed</a>, <a class="el" href="hythread_8c.html#a137">hythread_monitor_enter</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a166"></a><!-- doxytag: member="hythread.c::hythread_monitor_wait_interruptable" ref="a166" args="(hythread_monitor_t monitor, I_64 millis, IDATA nanos)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_monitor_wait_interruptable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_monitor_t&nbsp;</td>
          <td class="mdname" nowrap> <em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>I_64&nbsp;</td>
          <td class="mdname" nowrap> <em>millis</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>IDATA&nbsp;</td>
          <td class="mdname" nowrap> <em>nanos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait on a monitor until notified, interrupted (priority or normal), or timed out. 
<p>
A timeout of 0 (0ms, 0ns) indicates wait indefinitely.<p>
If 'interruptable' is non-zero, the wait may be interrupted by one of the interrupt functions. (i.e. hythread_interrupt, hythread_priority_interrupt);<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be waited on </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>millis</em>&nbsp;</td><td>&gt;=0 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nanos</em>&nbsp;</td><td>&gt;=0 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>interruptable</em>&nbsp;</td><td>non-zero if the wait is to be interruptable</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 the monitor has been waited on, notified, and reobtained<br>
 HYTHREAD_INVALID_ARGUMENT if millis or nanos is out of range (millis or nanos &lt; 0, or nanos &gt;= 1E6)<br>
 HYTHREAD_ILLEGAL_MONITOR_STATE if the current thread does not own the monitor<br>
 HYTHREAD_INTERRUPTED if the thread was interrupted while waiting<br>
 HYTHREAD_PRIORITY_INTERRUPTED if the thread was priority interrupted while waiting, or while re-obtaining the monitor<br>
 HYTHREAD_TIMED_OUT if the timeout expired<br>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a139">hythread_monitor_wait</a>, <a class="el" href="hythread_8c.html#a160">hythread_monitor_wait_timed</a>, <a class="el" href="hythread_8c.html#a137">hythread_monitor_enter</a> <p>
<a class="el" href="hythread_8c.html#a146">hythread_interrupt</a>, <a class="el" href="hythread_8c.html#a156">hythread_priority_interrupt</a> *</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a160"></a><!-- doxytag: member="hythread.c::hythread_monitor_wait_timed" ref="a160" args="(hythread_monitor_t monitor, I_64 millis, IDATA nanos)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_monitor_wait_timed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_monitor_t&nbsp;</td>
          <td class="mdname" nowrap> <em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>I_64&nbsp;</td>
          <td class="mdname" nowrap> <em>millis</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>IDATA&nbsp;</td>
          <td class="mdname" nowrap> <em>nanos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait on a monitor until notified or timed out. 
<p>
A timeout of 0 (0ms, 0ns) indicates wait indefinitely.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>monitor</em>&nbsp;</td><td>a monitor to be waited on </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>millis</em>&nbsp;</td><td>&gt;=0 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nanos</em>&nbsp;</td><td>&gt;=0</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 the monitor has been waited on, notified, and reobtained<br>
 HYTHREAD_INVALID_ARGUMENT millis or nanos is out of range (millis or nanos &lt; 0, or nanos &gt;= 1E6)<br>
 HYTHREAD_ILLEGAL_MONITOR_STATE the current thread does not own the monitor<br>
 HYTHREAD_TIMED_OUT the timeout expired</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a139">hythread_monitor_wait</a>, <a class="el" href="hythread_8c.html#a166">hythread_monitor_wait_interruptable</a>, <a class="el" href="hythread_8c.html#a137">hythread_monitor_enter</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a183"></a><!-- doxytag: member="hythread.c::hythread_park" ref="a183" args="(I_64 millis, IDATA nanos)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_park           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">I_64&nbsp;</td>
          <td class="mdname" nowrap> <em>millis</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>IDATA&nbsp;</td>
          <td class="mdname" nowrap> <em>nanos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
'Park' the current thread. 
<p>
Stop the current thread from executing until it is unparked, interrupted, or the specified timeout elapses.<p>
Unlike wait or sleep, the interrupted flag is NOT cleared by this API.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>millis</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nanos</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the thread is unparked HYTHREAD_INTERRUPTED if the thread was interrupted while parked<br>
 HYTHREAD_PRIORITY_INTERRUPTED if the thread was priority interrupted while parked<br>
 HYTHREAD_TIMED_OUT if the timeout expired<br>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a184">hythread_unpark</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a156"></a><!-- doxytag: member="hythread.c::hythread_priority_interrupt" ref="a156" args="(hythread_t thread)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void VMCALL hythread_priority_interrupt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>thread</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Priority interrupt a thread. 
<p>
If the thread is currently blocked (i.e. waiting on a monitor_wait or sleeping) resume the thread and return from the blocking function with HYTHREAD_PRIORITY_INTERRUPTED<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>a thead to be priority interrupted </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a157"></a><!-- doxytag: member="hythread.c::hythread_priority_interrupted" ref="a157" args="(hythread_t thread)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">UDATA VMCALL hythread_priority_interrupted           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>thread</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the value of a thread's priority interrupted flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>thread to be queried </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if not priority interrupted, non-zero if priority interrupted flag set</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a132"></a><!-- doxytag: member="hythread.c::hythread_resume" ref="a132" args="(hythread_t thread)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void VMCALL hythread_resume           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>thread</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resume a thread. 
<p>
Take a threads out of the suspended state.<p>
If the thread is not suspended, no action is taken.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>a thread to be resumed </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a129">hythread_create</a>, <a class="el" href="hythread_8c.html#a131">hythread_suspend</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a128"></a><!-- doxytag: member="hythread.c::hythread_self" ref="a128" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">hythread_t VMCALL hythread_self           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the hythread_t for the current thread. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Must be called only by an attached thread</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>hythread_t for the current thread</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a130">hythread_attach</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a145"></a><!-- doxytag: member="hythread.c::hythread_set_priority" ref="a145" args="(hythread_t thread, UDATA priority)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_set_priority           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_t&nbsp;</td>
          <td class="mdname" nowrap> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>UDATA&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a thread's execution priority. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>a thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>Use the following symbolic constants for priorities:<br>
 HYTHREAD_PRIORITY_MAX<br>
 HYTHREAD_PRIORITY_USER_MAX<br>
 HYTHREAD_PRIORITY_NORMAL<br>
 HYTHREAD_PRIORITY_USER_MIN<br>
 HYTHREAD_PRIORITY_MIN<br>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or negative value on failure (priority wasn't changed)</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a103"></a><!-- doxytag: member="hythread.c::hythread_shutdown" ref="a103" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void VMCALL hythread_shutdown           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Shut down the threading library associated with the current thread. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a107">hythread_init</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a150"></a><!-- doxytag: member="hythread.c::hythread_sleep" ref="a150" args="(I_64 millis)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_sleep           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">I_64&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>millis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Suspend the current thread from executing for at least the specified time. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>millis</em>&nbsp;</td><td>minimum number of milliseconds to sleep </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success<br>
 HYTHREAD_INVALID_ARGUMENT if millis &lt; 0</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a149">hythread_sleep_interruptable</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a149"></a><!-- doxytag: member="hythread.c::hythread_sleep_interruptable" ref="a149" args="(I_64 millis, IDATA nanos)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_sleep_interruptable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">I_64&nbsp;</td>
          <td class="mdname" nowrap> <em>millis</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>IDATA&nbsp;</td>
          <td class="mdname" nowrap> <em>nanos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Suspend the current thread from executing for at least the specified time. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>millis</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nanos</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success<br>
 HYTHREAD_INVALID_ARGUMENT if the arguments are invalid<br>
 HYTHREAD_INTERRUPTED if the sleep was interrupted</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a150">hythread_sleep</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a131"></a><!-- doxytag: member="hythread.c::hythread_suspend" ref="a131" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void VMCALL hythread_suspend           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Suspend the current thread. 
<p>
Stop the current thread from executing until it is resumed.<p>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a132">hythread_resume</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a142"></a><!-- doxytag: member="hythread.c::hythread_tls_alloc" ref="a142" args="(hythread_tls_key_t *handle)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_tls_alloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_tls_key_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>handle</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a thread local storage (TLS) key. 
<p>
Create and return a new, unique key for thread local storage.<p>
<dl compact><dt><b>Note:</b></dt><dd>The hande returned will be &gt;=0, so it is safe to test the handle against 0 to see if it's been allocated yet.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>pointer to a key to be initialized with a key value </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or negative value if a key could not be allocated (i.e. all TLS has been allocated)</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a143">hythread_tls_free</a>, <a class="el" href="hythread_8c.html#a144">hythread_tls_set</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a185"></a><!-- doxytag: member="hythread.c::hythread_tls_alloc_with_finalizer" ref="a185" args="(hythread_tls_key_t *handle, hythread_tls_finalizer_t finalizer)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_tls_alloc_with_finalizer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_tls_key_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>hythread_tls_finalizer_t&nbsp;</td>
          <td class="mdname" nowrap> <em>finalizer</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a thread local storage (TLS) key. 
<p>
Create and return a new, unique key for thread local storage.<p>
<dl compact><dt><b>Note:</b></dt><dd>The hande returned will be &gt;=0, so it is safe to test the handle against 0 to see if it's been allocated yet.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>pointer to a key to be initialized with a key value </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>a</em>&nbsp;</td><td>finalizer function which will be invoked when a thread is detached or terminates if the thread's TLS entry for this key is non-NULL </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or negative value if a key could not be allocated (i.e. all TLS has been allocated)</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a143">hythread_tls_free</a>, <a class="el" href="hythread_8c.html#a144">hythread_tls_set</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a143"></a><!-- doxytag: member="hythread.c::hythread_tls_free" ref="a143" args="(hythread_tls_key_t key)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_tls_free           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_tls_key_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>key</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Release a TLS key. 
<p>
Release a TLS key previously allocated by hythread_tls_alloc.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>TLS key to be freed </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or negative value on failure</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a142">hythread_tls_alloc</a>, <a class="el" href="hythread_8c.html#a144">hythread_tls_set</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a144"></a><!-- doxytag: member="hythread.c::hythread_tls_set" ref="a144" args="(hythread_t thread, hythread_tls_key_t key, void *value)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IDATA VMCALL hythread_tls_set           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_t&nbsp;</td>
          <td class="mdname" nowrap> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>hythread_tls_key_t&nbsp;</td>
          <td class="mdname" nowrap> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a thread's TLS value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thread</em>&nbsp;</td><td>a thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>key to have TLS value set (any value returned by hythread_alloc) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>value to be stored in TLS </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success or negative value on failure</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a142">hythread_tls_alloc</a>, <a class="el" href="hythread_8c.html#a143">hythread_tls_free</a>, <a class="el" href="hythreadinspect_8c.html#a15">hythread_tls_get</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a184"></a><!-- doxytag: member="hythread.c::hythread_unpark" ref="a184" args="(hythread_t thread)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void VMCALL hythread_unpark           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">hythread_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>thread</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
'Unpark' the specified thread. 
<p>
If the thread is parked, it will return from park. If the thread is not parked, its 'UNPARKED' flag will be set, and it will return immediately the next time it is parked.<p>
Note that unparks are not counted. Unparking a thread once is the same as unparking it n times.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="hythread_8c.html#a183">hythread_park</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a133"></a><!-- doxytag: member="hythread.c::hythread_yield" ref="a133" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void VMCALL hythread_yield           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Yield the processor. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
    </td>
  </tr>
</table>
<hr size="1">
<address style="text-align: center;">
  <small>
    (c) Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
  </small>
</address>
</body>
</html>
