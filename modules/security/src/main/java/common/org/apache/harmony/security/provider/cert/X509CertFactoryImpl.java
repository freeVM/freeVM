/*
 *  Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

/**
* @author Alexander Y. Kleymenov
* @version $Revision$
*/

package org.apache.harmony.security.provider.cert;


import java.io.IOException;
import java.io.InputStream;
import java.security.cert.CRL;
import java.security.cert.CRLException;
import java.security.cert.CertPath;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactorySpi;
import java.security.cert.X509CRL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import org.apache.harmony.luni.util.Base64;
import org.apache.harmony.security.asn1.ASN1Constants;
import org.apache.harmony.security.asn1.BerInputStream;
import org.apache.harmony.security.pkcs7.ContentInfo;
import org.apache.harmony.security.pkcs7.SignedData;
import org.apache.harmony.security.x509.CertificateList;

/**
 * X509 Certificate Factory Service Provider Interface Implementation.
 * It supports CRLs and Certificates in (PEM) ASN.1 DER encoded form,
 * and Certification Paths in PkiPath and PKCS7 formats.
 * For Certificates and CRLs factory maintains the caching
 * mechanisms allowing to speed up repeated Certificate/CRL
 * generation.
 * @see Cache
 */
public class X509CertFactoryImpl extends CertificateFactorySpi {

    // certificate cache
    private static Cache CERT_CASHE = new Cache();
    // crl cache, 24 leading/trailing bytes will be used for hash computation
    private static Cache CRL_CASHE = new Cache(24);

    /**
     * Default constructor.
     * Creates the instance of Certificate Factory SPI ready for use.
     */
    public X509CertFactoryImpl() { }

    /**
     * Generates the X.509 certificate from the data in the stream.
     * The data in the stream can be either in ASN.1 DER encoded X.509
     * certificate, or PEM (Base64 encoding bounded by
     * <code>"-----BEGIN CERTIFICATE-----"</code> at the beginning and
     * <code>"-----END CERTIFICATE-----"</code> at the end) representation
     * of the former encoded form.
     *
     * Before the generation the attempt the encoded form is looked up in
     * the cache. If the cache contains the certificate with requested encoded
     * form it is returned from it, otherwise it is generated by ASN.1
     * decoder.
     *
     * @see java.security.cert.CertificateFactorySpi#engineGenerateCertificate(InputStream)
     * method documentation for more info
     */
    public Certificate engineGenerateCertificate(InputStream inStream)
            throws CertificateException {
        if (inStream == null) {
            throw new CertificateException("Input stream should not be null.");
        }
        try {
            if (!inStream.markSupported()) {
                // create the mark supporting wrapper
                inStream = new RestoringInputStream(inStream);
            }
            // mark is needed to recognize the format of the provided encoding
            // (ASN.1 or PEM)
            inStream.mark(32);
            byte[] buff = new byte[28];
            // read the prefix of the encoding
            if (inStream.read(buff) < 28) {
                throw new CertificateException(
                        "Input Stream contains not enought data.");
            }
            // check whether the provided certificate is in PEM encoded form
            if ("-----BEGIN CERTIFICATE-----".equals(new String(buff, 0, 27))) {
                byte[] encoding = decodePEM(inStream, "CERTIFICATE");
                
                long hash = CERT_CASHE.getHash(encoding);
                if (CERT_CASHE.contains(hash)) {
                    Certificate res = 
                        (Certificate) CERT_CASHE.get(hash, encoding);
                    if (res != null) {
                        return res;
                    }
                }
                Certificate res = new X509CertImpl(encoding);
                CERT_CASHE.put(hash, encoding, res);
                return res;
            } else {
                // read ASN.1 DER encoded form
                inStream.reset();
                // check whether certificate has already been generated and
                // stored in the cache
                long hash = CERT_CASHE.getHash(buff);
                if (CERT_CASHE.contains(hash)) {
                    // preliminary check is successful, do more accurate check.
                    byte[] encoding = new byte[BerInputStream.getLength(buff)];
                    // read full encoding form from the stream
                    inStream.read(encoding);
                    // try to retrieve from the cache
                    Certificate res =
                        (Certificate) CERT_CASHE.get(hash, encoding);
                    if (res != null) {
                        // found in the cache
                        return res;
                    }
                    // there is no generated certificate in the cache,
                    // so generate it
                    res = new X509CertImpl(encoding);
                    // put newly generated certificate in the cache
                    CERT_CASHE.put(hash, encoding, res);
                    return res;
                } else {
                    // there is no generated certificate in the cache,
                    // so generate it
                    Certificate res = new X509CertImpl(inStream);
                    // put newly generated certificate in the cache
                    CERT_CASHE.put(hash, res.getEncoded(), res);
                    return res;
                }
            }
        } catch (IOException e) {
            throw new CertificateException(e);
        }
    }

    /**
     * Generates the collection of the certificates on the base of provided
     * via input stream encodings.
     * @see java.security.cert.CertificateFactorySpi#engineGenerateCertificates(InputStream)
     * method documentation for more info
     */
    public Collection<? extends Certificate>
            engineGenerateCertificates(InputStream inStream)
                throws CertificateException {
        if (inStream == null) {
            throw new CertificateException("Input stream should not be null.");
        }
        ArrayList result = new ArrayList();
        try {
            if (!inStream.markSupported()) {
                // create the mark supporting wrapper
                inStream = new RestoringInputStream(inStream);
            }
            boolean isPKCS7 = false;
            boolean isPEM = false;
            // check whether it is a PKCS7 structure
            inStream.mark(33);
            if (inStream.read() == '-') { // it is Base64 encoded form
                // check the boundary delimiter
                byte[] delimiter = new byte[20];
                inStream.read(delimiter);
                if (new String(delimiter).startsWith("----BEGIN PKCS7-----")) {
                    // this is PEM encoded PKCS7 structure
                    isPKCS7 = true;
                    isPEM = true;
                } else {
                    inStream.reset();
                }
            } else {
                // it is plain ASN.1 DER encoded form, 
                // so reset the stream and check the structure
                inStream.reset();
                BerInputStream in = new BerInputStream(inStream);
                if (in.next() == ASN1Constants.TAG_OID) { 
                    // this is PKCS7 structure
                    isPKCS7 = true;
                }
                inStream.reset();
            }
            if (isPKCS7) {
                ContentInfo info;
                if (isPEM) {
                    info = (ContentInfo) 
                        ContentInfo.ASN1.decode(decodePEM(inStream, "PKCS7"));
                } else {
                    info = (ContentInfo) ContentInfo.ASN1.decode(inStream);
                }
                SignedData data = info.getSignedData();
                if (data == null) {
                    throw new CertificateException("Invalid PKCS7 data provided");
                }
                List certificates = data.getCertificates();
                if (certificates != null) {
                    for (int i = 0; i < certificates.size(); i++) {
                        result.add(new X509CertImpl(
                            (org.apache.harmony.security.x509.Certificate)
                            certificates.get(i)));
                    }
                }
                return result;
            } else {
                inStream.mark(1);
                while (inStream.read() != -1) {
                    inStream.reset();
                    result.add(engineGenerateCertificate(inStream));
                    inStream.mark(1);
                }
            }
        } catch (IOException e) {
            throw new CertificateException(e);
        }
        return result;
    }

    /**
     * @see java.security.cert.CertificateFactorySpi#engineGenerateCRL(InputStream)
     * method documentation for more info
     */
    public CRL engineGenerateCRL(InputStream inStream)
            throws CRLException {
        if (inStream == null) {
            throw new CRLException("Input stream should not be null.");
        }
        try {
            if (!inStream.markSupported()) {
                // create the mark supporting wrapper
                inStream = new RestoringInputStream(inStream);
            }
            // mark is needed to recognize the format of the provided encoding
            // (ASN.1 or PEM)
            inStream.mark(32);
            byte[] buff = new byte[25]; // take one byte for new line
            // read the prefix of the encoding
            if (inStream.read(buff) < 25) {
                throw new CRLException(
                        "Input Stream contains not enought data.");
            }
            // check whether the provided crl is in PEM encoded form
            if ("-----BEGIN X509 CRL-----".equals(new String(buff, 0, 24))) {
                byte[] encoding = decodePEM(inStream, "X509 CRL");
                long hash = CRL_CASHE.getHash(encoding);
                if (CRL_CASHE.contains(hash)) {
                    X509CRL res = (X509CRL) CRL_CASHE.get(hash, encoding);
                    if (res != null) {
                        return res;
                    }
                }
                X509CRL res = new X509CRLImpl(encoding);
                CRL_CASHE.put(hash, encoding, res);
                return res;
            } else {
                inStream.reset();
                long hash = CRL_CASHE.getHash(buff);
                if (CRL_CASHE.contains(hash)) {
                    byte[] encoding = new byte[BerInputStream.getLength(buff)];
                    inStream.read(encoding);
                    CRL res =
                        (CRL) CRL_CASHE.get(hash, encoding);
                    if (res != null) {
                        return res;
                    }
                    res = new X509CRLImpl(encoding);
                    CRL_CASHE.put(hash, encoding, res);
                    return res;
                } else {
                    X509CRL res = new X509CRLImpl(inStream);
                    CRL_CASHE.put(hash, res.getEncoded(), res);
                    return res;
                }
            }
        } catch (IOException e) {
            throw new CRLException(e);
        }
    }

    /**
     * @see java.security.cert.CertificateFactorySpi#engineGenerateCRLs(InputStream)
     * method documentation for more info
     */
    public Collection<? extends CRL> engineGenerateCRLs(InputStream inStream)
            throws CRLException {
        if (inStream == null) {
            throw new CRLException("Null input stream provided.");
        }
        ArrayList result = new ArrayList();
        try {
            if (!inStream.markSupported()) {
                inStream = new RestoringInputStream(inStream);
            }
            boolean isPKCS7 = false;
            boolean isPEM = false;
            // check whether it is a PKCS7 structure
            inStream.mark(33);
            if (inStream.read() == '-') { // it is Base64 encoded form
                // check the boundary delimiter
                byte[] delimiter = new byte[20];
                inStream.read(delimiter);
                if (new String(delimiter).startsWith("----BEGIN PKCS7-----")) {
                    // this is PEM encoded PKCS7 structure
                    isPKCS7 = true;
                    isPEM = true;
                } else {
                    inStream.reset();
                }
            } else {
                // it is plain ASN.1 DER encoded form, 
                // so reset the stream and check the structure
                inStream.reset();
                BerInputStream in = new BerInputStream(inStream);
                if (in.next() == ASN1Constants.TAG_OID) { 
                    // this is PKCS7 structure
                    isPKCS7 = true;
                }
                inStream.reset();
            }
            if (isPKCS7) {
                // decode ContentInfo structure
                ContentInfo info;
                if (isPEM) {
                    info = (ContentInfo) 
                        ContentInfo.ASN1.decode(decodePEM(inStream, "PKCS7"));
                } else {
                    info = (ContentInfo) ContentInfo.ASN1.decode(inStream);
                }
                // retrieve SignedData
                SignedData data = info.getSignedData();
                if (data == null) {
                    throw new CRLException("Invalid PKCS7 data provided");
                }
                List crls = data.getCRLs();
                if (crls != null) {
                    for (int i = 0; i < crls.size(); i++) {
                        result.add(new X509CRLImpl(
                            (CertificateList) crls.get(i)));
                    }
                }
                return result;
            } else {
                inStream.mark(1);
                while (inStream.read() != -1) {
                    inStream.reset();
                    result.add(engineGenerateCRL(inStream));
                    inStream.mark(1);
                }
            }
        } catch (IOException e) {
            throw new CRLException(e);
        }
        return result;
    }

    /**
     * @see java.security.cert.CertificateFactorySpi#engineGenerateCertPath(InputStream)
     * method documentation for more info
     */
    public CertPath engineGenerateCertPath(InputStream inStream)
            throws CertificateException {
        return X509CertPathImpl.getInstance(inStream);
    }

    /**
     * @see java.security.cert.CertificateFactorySpi#engineGenerateCertPath(InputStream,String)
     * method documentation for more info
     */
    public CertPath engineGenerateCertPath(
            InputStream inStream, String encoding) throws CertificateException {
        return X509CertPathImpl.getInstance(inStream, encoding);
    }

    /**
     * @see java.security.cert.CertificateFactorySpi#engineGenerateCertPath(List)
     * method documentation for more info
     */
    public CertPath engineGenerateCertPath(List certificates)
            throws CertificateException {
        return new X509CertPathImpl(certificates);
    }

    /**
     * @see java.security.cert.CertificateFactorySpi#engineGetCertPathEncodings()
     * method documentation for more info
     */
    public Iterator<String> engineGetCertPathEncodings() {
        return X509CertPathImpl.encodings.iterator();
    }

    // Method retirieves the PEM encoded data from the stream 
    // and returns its decoded representation.
    // It is supposed that the data is bounded by
    // "-----END" + boundary_mark + "-----" at the end.
    private byte[] decodePEM(InputStream inStream, String boundary_mark) 
                                                        throws IOException {
        int size = 1024; // the size of the buffer containing Base64 data
        byte[] buff = new byte[size];
        int index=0, ch;
        // read bytes while boundary delimiter is not reached
        while ((ch = inStream.read()) != '-') {
            if (ch == -1) {
                throw new IOException(
                        "Incorrect Base64 encoding: unexpected EOF.");
            }
            buff[index++] = (byte) ch;
            if (index == size) {
                // enlarge the buffer
                byte[] newbuff = new byte[size+1024];
                System.arraycopy(buff, 0, newbuff, 0, size);
                buff = newbuff;
                size += 1024;
            }
        }
        // Check the boundary delimiter 
        // one '-' has been already read
        String boundary_delimiter = "----END " + boundary_mark + "-----";
        byte[] tmp = new byte[boundary_delimiter.length()];
        inStream.read(tmp);
        if (!new String(tmp).startsWith(boundary_delimiter)) {
            throw new IOException(
                "Incorrect Base64 encoding: boundary delimiter expected '"
                + boundary_delimiter + "'");
        }
        // skip trailing line breaks
        inStream.mark(1);
        while (((ch = inStream.read()) != -1) && (ch == '\n' || ch == '\r')) {
            inStream.mark(1);
        }
        inStream.reset();
        buff = Base64.decode(buff, index);
        if (buff == null) {
            throw new IOException("Incorrect Base64 encoding.");
        }
        return buff;
    };
    
    /*
     * This class extends any existing input stream with
     * mark functionality. It acts as a wrapper over the
     * stream and supports reset to the
     * marked state with readlimit no more than BUFF_SIZE.
     */
    private static class RestoringInputStream extends InputStream {

        // wrapped input stream
        private final InputStream inStream;
        // specifies how much of the read data is buffered
        // after the mark has been set up
        private static final int BUFF_SIZE = 32;
        // buffer to keep the bytes read after the mark has been set up
        private final int[] buff = new int[BUFF_SIZE*2];
        // position of the next byte to read,
        // the value of -1 indicates that the buffer is not used
        // (mark was not set up or was invalidated, or reset to the marked
        // position has been done and all the buffered data was read out)
        private int pos = -1;
        // position of the last buffered byte
        private int bar = 0;
        // position in the buffer where the mark becomes invalidated
        private int end = 0;

        /**
         * Creates the mark supporting wrapper over the stream.
         */
        public RestoringInputStream(InputStream inStream) {
            this.inStream = inStream;
        }

        /**
         * @see java.io.InputStream#available()
         * method documentation for more info
         */
        public int available() throws IOException {
            return (bar - pos) + inStream.available();
        }

        /**
         * @see java.io.InputStream#close()
         * method documentation for more info
         */
        public void close() throws IOException {
            inStream.close();
        }

        /**
         * @see java.io.InputStream#mark(int readlimit)
         * method documentation for more info
         */
        public void mark(int readlimit) {
            if (pos < 0) {
                pos = 0;
                bar = 0;
                end = BUFF_SIZE - 1;
            } else {
                end = (pos + BUFF_SIZE - 1) % BUFF_SIZE;
            }
        }

        /**
         * @see java.io.InputStream#markSupported()
         * method documentation for more info
         */
        public boolean markSupported() {
            return true;
        }

        /**
         * Reads the byte from the stream. If mark has been set up
         * and was not invalidated byte is read from the underlying
         * stream and saved into the buffer. If the current read position
         * has been reset to the marked position and there are remaining
         * bytes in the buffer, the byte is taken from it. In the other cases
         * (if mark has been invalidated, or there are no buffered bytes)
         * the byte is taken directly from the underlying stream and it is
         * returned without saving to the buffer.
         *
         * @see java.io.InputStream#read()
         * method documentation for more info
         */
        public int read() throws IOException {
            // if buffer is currently used
            if (pos >= 0) {
                // current position in the buffer
                int cur = pos % BUFF_SIZE;
                // check whether the buffer contains the data to be read
                if (cur < bar) {
                    // return the data from the buffer
                    pos++;
                    return buff[cur];
                }
                // check whether buffer has free space
                if (cur != end) {
                    // it has, so read the data from the wrapped stream
                    // and place it in the buffer
                    buff[cur] = inStream.read();
                    bar = cur+1;
                    pos++;
                    return buff[cur];
                } else {
                    // buffer if full and can not operate
                    // any more, so invalidate the mark position
                    // and turn off the using of buffer
                    pos = -1;
                }
            }
            // buffer is not used, so return the data from the wrapped stream
            return inStream.read();
        }

        /**
         * @see java.io.InputStream#read(byte[] b)
         * method documentation for more info
         */
        public int read(byte[] b) throws IOException {
            return read(b, 0, b.length);
        }

        /**
         * @see java.io.InputStream#read(byte[] b, int off, int len)
         * method documentation for more info
         */
        public int read(byte[] b, int off, int len) throws IOException {
            int read_b;
            int i;
            for (i=0; i<len; i++) {
                if ((read_b = read()) == -1) {
                    return (i == 0) ? -1 : i;
                }
                b[off+i] = (byte) read_b;
            }
            return i;
        }

        /**
         * @see java.io.InputStream#reset()
         * method documentation for more info
         */
        public void reset() throws IOException {
            if (pos >= 0) {
                pos = (end + 1) % BUFF_SIZE;
            } else {
                throw new IOException("Could not reset the stream: "
                    + "position became invalid or stream has not been marked.");
            }
        }

        /**
         * @see java.io.InputStream#skip(long n)
         * method documentation for more info
         */
        public long skip(long n) throws IOException {
            if (pos >= 0) {
                long i = 0;
                int av = available();
                if (av < n) {
                    n = av;
                }
                while ((i < n) && (read() != -1)) {
                    i++;
                }
                return i;
            } else {
                return inStream.skip(n);
            }
        }
    }
}

